{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { emojiComponents } from '../data.mjs';\nimport { getEmojiSequenceKeyword } from '../format.mjs';\nimport '../convert.mjs';\nfunction mapEmojiTestDataComponents(testSequences) {\n  const results = {\n    converted: /* @__PURE__ */new Map(),\n    items: /* @__PURE__ */new Map(),\n    names: /* @__PURE__ */new Map(),\n    types: {},\n    keywords: {}\n  };\n  for (const key in emojiComponents) {\n    const type = key;\n    const range = emojiComponents[type];\n    for (let number = range[0]; number < range[1]; number++) {\n      const keyword = getEmojiSequenceKeyword([number]);\n      const item = testSequences[keyword];\n      if (!item) {\n        throw new Error(`Missing emoji component in test sequence: \"${keyword}\"`);\n      }\n      results.converted.set(number, keyword);\n      results.items.set(number, item);\n      results.items.set(keyword, item);\n      const name = item.name;\n      results.names.set(number, name);\n      results.names.set(keyword, name);\n      results.types[name] = type;\n      results.keywords[name] = keyword;\n    }\n  }\n  return results;\n}\nfunction emojiSequenceWithComponentsToString(sequence) {\n  return sequence.map(item => typeof item === \"number\" ? item.toString(16) : item).join(\"-\");\n}\nfunction findEmojiComponentsInSequence(sequence) {\n  const components = [];\n  for (let index = 0; index < sequence.length; index++) {\n    const code = sequence[index];\n    for (const key in emojiComponents) {\n      const type = key;\n      const range = emojiComponents[type];\n      if (code >= range[0] && code < range[1]) {\n        components.push({\n          index,\n          type\n        });\n        break;\n      }\n    }\n  }\n  return components;\n}\nfunction replaceEmojiComponentsInCombinedSequence(sequence, values) {\n  const indexes = {\n    \"hair-style\": 0,\n    \"skin-tone\": 0\n  };\n  return sequence.map(item => {\n    if (typeof item === \"number\") {\n      return item;\n    }\n    const index = indexes[item]++;\n    const list = values[item];\n    if (!list || !list.length) {\n      throw new Error(`Cannot replace ${item}: no valid values provided`);\n    }\n    return list[index >= list.length ? list.length - 1 : index];\n  });\n}\nexport { emojiSequenceWithComponentsToString, findEmojiComponentsInSequence, mapEmojiTestDataComponents, replaceEmojiComponentsInCombinedSequence };","map":{"version":3,"names":["emojiComponents","getEmojiSequenceKeyword","mapEmojiTestDataComponents","testSequences","results","converted","Map","items","names","types","keywords","key","type","range","number","keyword","item","Error","set","name","emojiSequenceWithComponentsToString","sequence","map","toString","join","findEmojiComponentsInSequence","components","index","length","code","push","replaceEmojiComponentsInCombinedSequence","values","indexes","list"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/@iconify/utils/lib/emoji/test/components.mjs"],"sourcesContent":["import { emojiComponents } from '../data.mjs';\nimport { getEmojiSequenceKeyword } from '../format.mjs';\nimport '../convert.mjs';\n\nfunction mapEmojiTestDataComponents(testSequences) {\n  const results = {\n    converted: /* @__PURE__ */ new Map(),\n    items: /* @__PURE__ */ new Map(),\n    names: /* @__PURE__ */ new Map(),\n    types: {},\n    keywords: {}\n  };\n  for (const key in emojiComponents) {\n    const type = key;\n    const range = emojiComponents[type];\n    for (let number = range[0]; number < range[1]; number++) {\n      const keyword = getEmojiSequenceKeyword([number]);\n      const item = testSequences[keyword];\n      if (!item) {\n        throw new Error(\n          `Missing emoji component in test sequence: \"${keyword}\"`\n        );\n      }\n      results.converted.set(number, keyword);\n      results.items.set(number, item);\n      results.items.set(keyword, item);\n      const name = item.name;\n      results.names.set(number, name);\n      results.names.set(keyword, name);\n      results.types[name] = type;\n      results.keywords[name] = keyword;\n    }\n  }\n  return results;\n}\nfunction emojiSequenceWithComponentsToString(sequence) {\n  return sequence.map((item) => typeof item === \"number\" ? item.toString(16) : item).join(\"-\");\n}\nfunction findEmojiComponentsInSequence(sequence) {\n  const components = [];\n  for (let index = 0; index < sequence.length; index++) {\n    const code = sequence[index];\n    for (const key in emojiComponents) {\n      const type = key;\n      const range = emojiComponents[type];\n      if (code >= range[0] && code < range[1]) {\n        components.push({\n          index,\n          type\n        });\n        break;\n      }\n    }\n  }\n  return components;\n}\nfunction replaceEmojiComponentsInCombinedSequence(sequence, values) {\n  const indexes = {\n    \"hair-style\": 0,\n    \"skin-tone\": 0\n  };\n  return sequence.map((item) => {\n    if (typeof item === \"number\") {\n      return item;\n    }\n    const index = indexes[item]++;\n    const list = values[item];\n    if (!list || !list.length) {\n      throw new Error(`Cannot replace ${item}: no valid values provided`);\n    }\n    return list[index >= list.length ? list.length - 1 : index];\n  });\n}\n\nexport { emojiSequenceWithComponentsToString, findEmojiComponentsInSequence, mapEmojiTestDataComponents, replaceEmojiComponentsInCombinedSequence };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}