{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.iterator.constructor.js\");\nrequire(\"core-js/modules/es.iterator.filter.js\");\nrequire(\"core-js/modules/es.iterator.for-each.js\");\nrequire(\"core-js/modules/es.set.difference.v2.js\");\nrequire(\"core-js/modules/es.set.intersection.v2.js\");\nrequire(\"core-js/modules/es.set.is-disjoint-from.v2.js\");\nrequire(\"core-js/modules/es.set.is-subset-of.v2.js\");\nrequire(\"core-js/modules/es.set.is-superset-of.v2.js\");\nrequire(\"core-js/modules/es.set.symmetric-difference.v2.js\");\nrequire(\"core-js/modules/es.set.union.v2.js\");\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"layout-base\"));else if (typeof define === 'function' && define.amd) define([\"layout-base\"], factory);else if (typeof exports === 'object') exports[\"coseBase\"] = factory(require(\"layout-base\"));else root[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE__551__) {\n  return /******/(() => {\n    // webpackBootstrap\n    /******/\n    \"use strict\";\n\n    /******/\n    var __webpack_modules__ = {\n      /***/45: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var coseBase = {};\n        coseBase.layoutBase = __webpack_require__(551);\n        coseBase.CoSEConstants = __webpack_require__(806);\n        coseBase.CoSEEdge = __webpack_require__(767);\n        coseBase.CoSEGraph = __webpack_require__(880);\n        coseBase.CoSEGraphManager = __webpack_require__(578);\n        coseBase.CoSELayout = __webpack_require__(765);\n        coseBase.CoSENode = __webpack_require__(991);\n        coseBase.ConstraintHandler = __webpack_require__(902);\n        module.exports = coseBase;\n\n        /***/\n      }),\n      /***/806: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var FDLayoutConstants = __webpack_require__(551).FDLayoutConstants;\n        function CoSEConstants() {}\n\n        //CoSEConstants inherits static props in FDLayoutConstants\n        for (var prop in FDLayoutConstants) {\n          CoSEConstants[prop] = FDLayoutConstants[prop];\n        }\n        CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n        CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n        CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n        CoSEConstants.TILE = true;\n        CoSEConstants.TILING_PADDING_VERTICAL = 10;\n        CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n        CoSEConstants.ENFORCE_CONSTRAINTS = true;\n        CoSEConstants.APPLY_LAYOUT = true;\n        CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\n        CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n        // This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n        // an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\n        CoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n        module.exports = CoSEConstants;\n\n        /***/\n      }),\n      /***/767: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var FDLayoutEdge = __webpack_require__(551).FDLayoutEdge;\n        function CoSEEdge(source, target, vEdge) {\n          FDLayoutEdge.call(this, source, target, vEdge);\n        }\n        CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n        for (var prop in FDLayoutEdge) {\n          CoSEEdge[prop] = FDLayoutEdge[prop];\n        }\n        module.exports = CoSEEdge;\n\n        /***/\n      }),\n      /***/880: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var LGraph = __webpack_require__(551).LGraph;\n        function CoSEGraph(parent, graphMgr, vGraph) {\n          LGraph.call(this, parent, graphMgr, vGraph);\n        }\n        CoSEGraph.prototype = Object.create(LGraph.prototype);\n        for (var prop in LGraph) {\n          CoSEGraph[prop] = LGraph[prop];\n        }\n        module.exports = CoSEGraph;\n\n        /***/\n      }),\n      /***/578: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var LGraphManager = __webpack_require__(551).LGraphManager;\n        function CoSEGraphManager(layout) {\n          LGraphManager.call(this, layout);\n        }\n        CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n        for (var prop in LGraphManager) {\n          CoSEGraphManager[prop] = LGraphManager[prop];\n        }\n        module.exports = CoSEGraphManager;\n\n        /***/\n      }),\n      /***/765: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var FDLayout = __webpack_require__(551).FDLayout;\n        var CoSEGraphManager = __webpack_require__(578);\n        var CoSEGraph = __webpack_require__(880);\n        var CoSENode = __webpack_require__(991);\n        var CoSEEdge = __webpack_require__(767);\n        var CoSEConstants = __webpack_require__(806);\n        var ConstraintHandler = __webpack_require__(902);\n        var FDLayoutConstants = __webpack_require__(551).FDLayoutConstants;\n        var LayoutConstants = __webpack_require__(551).LayoutConstants;\n        var Point = __webpack_require__(551).Point;\n        var PointD = __webpack_require__(551).PointD;\n        var DimensionD = __webpack_require__(551).DimensionD;\n        var Layout = __webpack_require__(551).Layout;\n        var Integer = __webpack_require__(551).Integer;\n        var IGeometry = __webpack_require__(551).IGeometry;\n        var LGraph = __webpack_require__(551).LGraph;\n        var Transform = __webpack_require__(551).Transform;\n        var LinkedList = __webpack_require__(551).LinkedList;\n        function CoSELayout() {\n          FDLayout.call(this);\n          this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n          this.constraints = {}; // keep layout constraints\n        }\n        CoSELayout.prototype = Object.create(FDLayout.prototype);\n        for (var prop in FDLayout) {\n          CoSELayout[prop] = FDLayout[prop];\n        }\n        CoSELayout.prototype.newGraphManager = function () {\n          var gm = new CoSEGraphManager(this);\n          this.graphManager = gm;\n          return gm;\n        };\n        CoSELayout.prototype.newGraph = function (vGraph) {\n          return new CoSEGraph(null, this.graphManager, vGraph);\n        };\n        CoSELayout.prototype.newNode = function (vNode) {\n          return new CoSENode(this.graphManager, vNode);\n        };\n        CoSELayout.prototype.newEdge = function (vEdge) {\n          return new CoSEEdge(null, null, vEdge);\n        };\n        CoSELayout.prototype.initParameters = function () {\n          FDLayout.prototype.initParameters.call(this, arguments);\n          if (!this.isSubLayout) {\n            if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n              this.idealEdgeLength = 10;\n            } else {\n              this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n            }\n            this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n            this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n            this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n            this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n            this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n            // variables for tree reduction support\n            this.prunedNodesAll = [];\n            this.growTreeIterations = 0;\n            this.afterGrowthIterations = 0;\n            this.isTreeGrowing = false;\n            this.isGrowthFinished = false;\n          }\n        };\n\n        // This method is used to set CoSE related parameters used by spring embedder.\n        CoSELayout.prototype.initSpringEmbedder = function () {\n          FDLayout.prototype.initSpringEmbedder.call(this);\n\n          // variables for cooling\n          this.coolingCycle = 0;\n          this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n          this.finalTemperature = 0.04;\n          this.coolingAdjuster = 1;\n        };\n        CoSELayout.prototype.layout = function () {\n          var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n          if (createBendsAsNeeded) {\n            this.createBendpoints();\n            this.graphManager.resetAllEdges();\n          }\n          this.level = 0;\n          return this.classicLayout();\n        };\n        CoSELayout.prototype.classicLayout = function () {\n          this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n          this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n          this.calcNoOfChildrenForAllNodes();\n          this.graphManager.calcLowestCommonAncestors();\n          this.graphManager.calcInclusionTreeDepths();\n          this.graphManager.getRoot().calcEstimatedSize();\n          this.calcIdealEdgeLengths();\n          if (!this.incremental) {\n            var forest = this.getFlatForest();\n\n            // The graph associated with this layout is flat and a forest\n            if (forest.length > 0) {\n              this.positionNodesRadially(forest);\n            }\n            // The graph associated with this layout is not flat or a forest\n            else {\n              // Reduce the trees when incremental mode is not enabled and graph is not a forest \n              this.reduceTrees();\n              // Update nodes that gravity will be applied\n              this.graphManager.resetAllNodesToApplyGravitation();\n              var allNodes = new Set(this.getAllNodes());\n              var intersection = this.nodesWithGravity.filter(function (x) {\n                return allNodes.has(x);\n              });\n              this.graphManager.setAllNodesToApplyGravitation(intersection);\n              this.positionNodesRandomly();\n            }\n          } else {\n            if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n              // Reduce the trees in incremental mode if only this constant is set to true \n              this.reduceTrees();\n              // Update nodes that gravity will be applied\n              this.graphManager.resetAllNodesToApplyGravitation();\n              var allNodes = new Set(this.getAllNodes());\n              var intersection = this.nodesWithGravity.filter(function (x) {\n                return allNodes.has(x);\n              });\n              this.graphManager.setAllNodesToApplyGravitation(intersection);\n            }\n          }\n          if (Object.keys(this.constraints).length > 0) {\n            ConstraintHandler.handleConstraints(this);\n            this.initConstraintVariables();\n          }\n          this.initSpringEmbedder();\n          if (CoSEConstants.APPLY_LAYOUT) {\n            this.runSpringEmbedder();\n          }\n          return true;\n        };\n        CoSELayout.prototype.tick = function () {\n          this.totalIterations++;\n          if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n            if (this.prunedNodesAll.length > 0) {\n              this.isTreeGrowing = true;\n            } else {\n              return true;\n            }\n          }\n          if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n            if (this.isConverged()) {\n              if (this.prunedNodesAll.length > 0) {\n                this.isTreeGrowing = true;\n              } else {\n                return true;\n              }\n            }\n            this.coolingCycle++;\n            if (this.layoutQuality == 0) {\n              // quality - \"draft\"\n              this.coolingAdjuster = this.coolingCycle;\n            } else if (this.layoutQuality == 1) {\n              // quality - \"default\"\n              this.coolingAdjuster = this.coolingCycle / 3;\n            }\n\n            // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n            this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n            this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n          }\n          // Operations while tree is growing again \n          if (this.isTreeGrowing) {\n            if (this.growTreeIterations % 10 == 0) {\n              if (this.prunedNodesAll.length > 0) {\n                this.graphManager.updateBounds();\n                this.updateGrid();\n                this.growTree(this.prunedNodesAll);\n                // Update nodes that gravity will be applied\n                this.graphManager.resetAllNodesToApplyGravitation();\n                var allNodes = new Set(this.getAllNodes());\n                var intersection = this.nodesWithGravity.filter(function (x) {\n                  return allNodes.has(x);\n                });\n                this.graphManager.setAllNodesToApplyGravitation(intersection);\n                this.graphManager.updateBounds();\n                this.updateGrid();\n                if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n              } else {\n                this.isTreeGrowing = false;\n                this.isGrowthFinished = true;\n              }\n            }\n            this.growTreeIterations++;\n          }\n          // Operations after growth is finished\n          if (this.isGrowthFinished) {\n            if (this.isConverged()) {\n              return true;\n            }\n            if (this.afterGrowthIterations % 10 == 0) {\n              this.graphManager.updateBounds();\n              this.updateGrid();\n            }\n            if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n            this.afterGrowthIterations++;\n          }\n          var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n          var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n          this.totalDisplacement = 0;\n          this.graphManager.updateBounds();\n          this.calcSpringForces();\n          this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n          this.calcGravitationalForces();\n          this.moveNodes();\n          this.animate();\n          return false; // Layout is not ended yet return false\n        };\n        CoSELayout.prototype.getPositionsData = function () {\n          var allNodes = this.graphManager.getAllNodes();\n          var pData = {};\n          for (var i = 0; i < allNodes.length; i++) {\n            var rect = allNodes[i].rect;\n            var id = allNodes[i].id;\n            pData[id] = {\n              id: id,\n              x: rect.getCenterX(),\n              y: rect.getCenterY(),\n              w: rect.width,\n              h: rect.height\n            };\n          }\n          return pData;\n        };\n        CoSELayout.prototype.runSpringEmbedder = function () {\n          this.initialAnimationPeriod = 25;\n          this.animationPeriod = this.initialAnimationPeriod;\n          var layoutEnded = false;\n\n          // If aminate option is 'during' signal that layout is supposed to start iterating\n          if (FDLayoutConstants.ANIMATE === 'during') {\n            this.emit('layoutstarted');\n          } else {\n            // If aminate option is 'during' tick() function will be called on index.js\n            while (!layoutEnded) {\n              layoutEnded = this.tick();\n            }\n            this.graphManager.updateBounds();\n          }\n        };\n\n        // overrides moveNodes method in FDLayout\n        CoSELayout.prototype.moveNodes = function () {\n          var lNodes = this.getAllNodes();\n          var node;\n\n          // calculate displacement for each node \n          for (var i = 0; i < lNodes.length; i++) {\n            node = lNodes[i];\n            node.calculateDisplacement();\n          }\n          if (Object.keys(this.constraints).length > 0) {\n            this.updateDisplacements();\n          }\n\n          // move each node\n          for (var i = 0; i < lNodes.length; i++) {\n            node = lNodes[i];\n            node.move();\n          }\n        };\n\n        // constraint related methods: initConstraintVariables and updateDisplacements\n\n        // initialize constraint related variables\n        CoSELayout.prototype.initConstraintVariables = function () {\n          var self = this;\n          this.idToNodeMap = new Map();\n          this.fixedNodeSet = new Set();\n          var allNodes = this.graphManager.getAllNodes();\n\n          // fill idToNodeMap\n          for (var i = 0; i < allNodes.length; i++) {\n            var node = allNodes[i];\n            this.idToNodeMap.set(node.id, node);\n          }\n\n          // calculate fixed node weight for given compound node\n          var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n            var nodes = compoundNode.getChild().getNodes();\n            var node;\n            var fixedNodeWeight = 0;\n            for (var i = 0; i < nodes.length; i++) {\n              node = nodes[i];\n              if (node.getChild() == null) {\n                if (self.fixedNodeSet.has(node.id)) {\n                  fixedNodeWeight += 100;\n                }\n              } else {\n                fixedNodeWeight += calculateCompoundWeight(node);\n              }\n            }\n            return fixedNodeWeight;\n          };\n          if (this.constraints.fixedNodeConstraint) {\n            // fill fixedNodeSet\n            this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n              self.fixedNodeSet.add(nodeData.nodeId);\n            });\n\n            // assign fixed node weights to compounds if they contain fixed nodes\n            var allNodes = this.graphManager.getAllNodes();\n            var node;\n            for (var i = 0; i < allNodes.length; i++) {\n              node = allNodes[i];\n              if (node.getChild() != null) {\n                var fixedNodeWeight = calculateCompoundWeight(node);\n                if (fixedNodeWeight > 0) {\n                  node.fixedNodeWeight = fixedNodeWeight;\n                }\n              }\n            }\n          }\n          if (this.constraints.relativePlacementConstraint) {\n            var nodeToDummyForVerticalAlignment = new Map();\n            var nodeToDummyForHorizontalAlignment = new Map();\n            this.dummyToNodeForVerticalAlignment = new Map();\n            this.dummyToNodeForHorizontalAlignment = new Map();\n            this.fixedNodesOnHorizontal = new Set();\n            this.fixedNodesOnVertical = new Set();\n\n            // fill maps and sets\n            this.fixedNodeSet.forEach(function (nodeId) {\n              self.fixedNodesOnHorizontal.add(nodeId);\n              self.fixedNodesOnVertical.add(nodeId);\n            });\n            if (this.constraints.alignmentConstraint) {\n              if (this.constraints.alignmentConstraint.vertical) {\n                var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n                for (var i = 0; i < verticalAlignment.length; i++) {\n                  this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n                  verticalAlignment[i].forEach(function (nodeId) {\n                    nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n                    self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n                    if (self.fixedNodeSet.has(nodeId)) {\n                      self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n                    }\n                  });\n                }\n              }\n              if (this.constraints.alignmentConstraint.horizontal) {\n                var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n                for (var i = 0; i < horizontalAlignment.length; i++) {\n                  this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n                  horizontalAlignment[i].forEach(function (nodeId) {\n                    nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n                    self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n                    if (self.fixedNodeSet.has(nodeId)) {\n                      self.fixedNodesOnVertical.add(\"dummy\" + i);\n                    }\n                  });\n                }\n              }\n            }\n            if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n              this.shuffle = function (array) {\n                var j, x, i;\n                for (i = array.length - 1; i >= 2 * array.length / 3; i--) {\n                  j = Math.floor(Math.random() * (i + 1));\n                  x = array[i];\n                  array[i] = array[j];\n                  array[j] = x;\n                }\n                return array;\n              };\n              this.nodesInRelativeHorizontal = [];\n              this.nodesInRelativeVertical = [];\n              this.nodeToRelativeConstraintMapHorizontal = new Map();\n              this.nodeToRelativeConstraintMapVertical = new Map();\n              this.nodeToTempPositionMapHorizontal = new Map();\n              this.nodeToTempPositionMapVertical = new Map();\n\n              // fill arrays and maps\n              this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n                if (constraint.left) {\n                  var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n                  var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n                  if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n                    self.nodesInRelativeHorizontal.push(nodeIdLeft);\n                    self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n                    if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n                      self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n                    } else {\n                      self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n                    }\n                  }\n                  if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n                    self.nodesInRelativeHorizontal.push(nodeIdRight);\n                    self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n                    if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n                      self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n                    } else {\n                      self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n                    }\n                  }\n                  self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({\n                    right: nodeIdRight,\n                    gap: constraint.gap\n                  });\n                  self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({\n                    left: nodeIdLeft,\n                    gap: constraint.gap\n                  });\n                } else {\n                  var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n                  var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n                  if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n                    self.nodesInRelativeVertical.push(nodeIdTop);\n                    self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n                    if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n                      self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n                    } else {\n                      self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n                    }\n                  }\n                  if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n                    self.nodesInRelativeVertical.push(nodeIdBottom);\n                    self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n                    if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n                      self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n                    } else {\n                      self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n                    }\n                  }\n                  self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({\n                    bottom: nodeIdBottom,\n                    gap: constraint.gap\n                  });\n                  self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({\n                    top: nodeIdTop,\n                    gap: constraint.gap\n                  });\n                }\n              });\n            } else {\n              var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n              var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n\n              // construct subgraphs from relative placement constraints \n              this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n                if (constraint.left) {\n                  var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n                  var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n                  if (subGraphOnHorizontal.has(left)) {\n                    subGraphOnHorizontal.get(left).push(right);\n                  } else {\n                    subGraphOnHorizontal.set(left, [right]);\n                  }\n                  if (subGraphOnHorizontal.has(right)) {\n                    subGraphOnHorizontal.get(right).push(left);\n                  } else {\n                    subGraphOnHorizontal.set(right, [left]);\n                  }\n                } else {\n                  var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n                  var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n                  if (subGraphOnVertical.has(top)) {\n                    subGraphOnVertical.get(top).push(bottom);\n                  } else {\n                    subGraphOnVertical.set(top, [bottom]);\n                  }\n                  if (subGraphOnVertical.has(bottom)) {\n                    subGraphOnVertical.get(bottom).push(top);\n                  } else {\n                    subGraphOnVertical.set(bottom, [top]);\n                  }\n                }\n              });\n\n              // function to construct components from a given graph \n              // also returns an array that keeps whether each component contains fixed node\n              var constructComponents = function constructComponents(graph, fixedNodes) {\n                var components = [];\n                var isFixed = [];\n                var queue = new LinkedList();\n                var visited = new Set();\n                var count = 0;\n                graph.forEach(function (value, key) {\n                  if (!visited.has(key)) {\n                    components[count] = [];\n                    isFixed[count] = false;\n                    var currentNode = key;\n                    queue.push(currentNode);\n                    visited.add(currentNode);\n                    components[count].push(currentNode);\n                    while (queue.length != 0) {\n                      currentNode = queue.shift();\n                      if (fixedNodes.has(currentNode)) {\n                        isFixed[count] = true;\n                      }\n                      var neighbors = graph.get(currentNode);\n                      neighbors.forEach(function (neighbor) {\n                        if (!visited.has(neighbor)) {\n                          queue.push(neighbor);\n                          visited.add(neighbor);\n                          components[count].push(neighbor);\n                        }\n                      });\n                    }\n                    count++;\n                  }\n                });\n                return {\n                  components: components,\n                  isFixed: isFixed\n                };\n              };\n              var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n              this.componentsOnHorizontal = resultOnHorizontal.components;\n              this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n              var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n              this.componentsOnVertical = resultOnVertical.components;\n              this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n            }\n          }\n        };\n\n        // updates node displacements based on constraints\n        CoSELayout.prototype.updateDisplacements = function () {\n          var self = this;\n          if (this.constraints.fixedNodeConstraint) {\n            this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n              var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n              fixedNode.displacementX = 0;\n              fixedNode.displacementY = 0;\n            });\n          }\n          if (this.constraints.alignmentConstraint) {\n            if (this.constraints.alignmentConstraint.vertical) {\n              var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n              for (var i = 0; i < allVerticalAlignments.length; i++) {\n                var totalDisplacementX = 0;\n                for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n                  if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n                    totalDisplacementX = 0;\n                    break;\n                  }\n                  totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n                }\n                var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n                for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n                  this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n                }\n              }\n            }\n            if (this.constraints.alignmentConstraint.horizontal) {\n              var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n              for (var i = 0; i < allHorizontalAlignments.length; i++) {\n                var totalDisplacementY = 0;\n                for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n                  if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n                    totalDisplacementY = 0;\n                    break;\n                  }\n                  totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n                }\n                var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n                for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n                  this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n                }\n              }\n            }\n          }\n          if (this.constraints.relativePlacementConstraint) {\n            if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n              // shuffle array to randomize node processing order\n              if (this.totalIterations % 10 == 0) {\n                this.shuffle(this.nodesInRelativeHorizontal);\n                this.shuffle(this.nodesInRelativeVertical);\n              }\n              this.nodesInRelativeHorizontal.forEach(function (nodeId) {\n                if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n                  var displacement = 0;\n                  if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                    displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n                  } else {\n                    displacement = self.idToNodeMap.get(nodeId).displacementX;\n                  }\n                  self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function (constraint) {\n                    if (constraint.right) {\n                      var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n                      if (diff < constraint.gap) {\n                        displacement -= constraint.gap - diff;\n                      }\n                    } else {\n                      var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n                      if (diff < constraint.gap) {\n                        displacement += constraint.gap - diff;\n                      }\n                    }\n                  });\n                  self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n                  if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                    self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function (nodeId) {\n                      self.idToNodeMap.get(nodeId).displacementX = displacement;\n                    });\n                  } else {\n                    self.idToNodeMap.get(nodeId).displacementX = displacement;\n                  }\n                }\n              });\n              this.nodesInRelativeVertical.forEach(function (nodeId) {\n                if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n                  var displacement = 0;\n                  if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                    displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n                  } else {\n                    displacement = self.idToNodeMap.get(nodeId).displacementY;\n                  }\n                  self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function (constraint) {\n                    if (constraint.bottom) {\n                      var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n                      if (diff < constraint.gap) {\n                        displacement -= constraint.gap - diff;\n                      }\n                    } else {\n                      var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n                      if (diff < constraint.gap) {\n                        displacement += constraint.gap - diff;\n                      }\n                    }\n                  });\n                  self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n                  if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                    self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function (nodeId) {\n                      self.idToNodeMap.get(nodeId).displacementY = displacement;\n                    });\n                  } else {\n                    self.idToNodeMap.get(nodeId).displacementY = displacement;\n                  }\n                }\n              });\n            } else {\n              for (var i = 0; i < this.componentsOnHorizontal.length; i++) {\n                var component = this.componentsOnHorizontal[i];\n                if (this.fixedComponentsOnHorizontal[i]) {\n                  for (var j = 0; j < component.length; j++) {\n                    if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                      this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                        self.idToNodeMap.get(nodeId).displacementX = 0;\n                      });\n                    } else {\n                      this.idToNodeMap.get(component[j]).displacementX = 0;\n                    }\n                  }\n                } else {\n                  var sum = 0;\n                  var count = 0;\n                  for (var j = 0; j < component.length; j++) {\n                    if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                      var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n                      sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n                      count += actualNodes.length;\n                    } else {\n                      sum += this.idToNodeMap.get(component[j]).displacementX;\n                      count++;\n                    }\n                  }\n                  var averageDisplacement = sum / count;\n                  for (var j = 0; j < component.length; j++) {\n                    if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                      this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                        self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n                      });\n                    } else {\n                      this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n                    }\n                  }\n                }\n              }\n              for (var i = 0; i < this.componentsOnVertical.length; i++) {\n                var component = this.componentsOnVertical[i];\n                if (this.fixedComponentsOnVertical[i]) {\n                  for (var j = 0; j < component.length; j++) {\n                    if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                      this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                        self.idToNodeMap.get(nodeId).displacementY = 0;\n                      });\n                    } else {\n                      this.idToNodeMap.get(component[j]).displacementY = 0;\n                    }\n                  }\n                } else {\n                  var sum = 0;\n                  var count = 0;\n                  for (var j = 0; j < component.length; j++) {\n                    if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                      var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n                      sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n                      count += actualNodes.length;\n                    } else {\n                      sum += this.idToNodeMap.get(component[j]).displacementY;\n                      count++;\n                    }\n                  }\n                  var averageDisplacement = sum / count;\n                  for (var j = 0; j < component.length; j++) {\n                    if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                      this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                        self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n                      });\n                    } else {\n                      this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        };\n        CoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n          var nodeList = [];\n          var graph;\n          var graphs = this.graphManager.getGraphs();\n          var size = graphs.length;\n          var i;\n          for (i = 0; i < size; i++) {\n            graph = graphs[i];\n            graph.updateConnected();\n            if (!graph.isConnected) {\n              nodeList = nodeList.concat(graph.getNodes());\n            }\n          }\n          return nodeList;\n        };\n        CoSELayout.prototype.createBendpoints = function () {\n          var edges = [];\n          edges = edges.concat(this.graphManager.getAllEdges());\n          var visited = new Set();\n          var i;\n          for (i = 0; i < edges.length; i++) {\n            var edge = edges[i];\n            if (!visited.has(edge)) {\n              var source = edge.getSource();\n              var target = edge.getTarget();\n              if (source == target) {\n                edge.getBendpoints().push(new PointD());\n                edge.getBendpoints().push(new PointD());\n                this.createDummyNodesForBendpoints(edge);\n                visited.add(edge);\n              } else {\n                var edgeList = [];\n                edgeList = edgeList.concat(source.getEdgeListToNode(target));\n                edgeList = edgeList.concat(target.getEdgeListToNode(source));\n                if (!visited.has(edgeList[0])) {\n                  if (edgeList.length > 1) {\n                    var k;\n                    for (k = 0; k < edgeList.length; k++) {\n                      var multiEdge = edgeList[k];\n                      multiEdge.getBendpoints().push(new PointD());\n                      this.createDummyNodesForBendpoints(multiEdge);\n                    }\n                  }\n                  edgeList.forEach(function (edge) {\n                    visited.add(edge);\n                  });\n                }\n              }\n            }\n            if (visited.size == edges.length) {\n              break;\n            }\n          }\n        };\n        CoSELayout.prototype.positionNodesRadially = function (forest) {\n          // We tile the trees to a grid row by row; first tree starts at (0,0)\n          var currentStartingPoint = new Point(0, 0);\n          var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n          var height = 0;\n          var currentY = 0;\n          var currentX = 0;\n          var point = new PointD(0, 0);\n          for (var i = 0; i < forest.length; i++) {\n            if (i % numberOfColumns == 0) {\n              // Start of a new row, make the x coordinate 0, increment the\n              // y coordinate with the max height of the previous row\n              currentX = 0;\n              currentY = height;\n              if (i != 0) {\n                currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n              }\n              height = 0;\n            }\n            var tree = forest[i];\n\n            // Find the center of the tree\n            var centerNode = Layout.findCenterOfTree(tree);\n\n            // Set the staring point of the next tree\n            currentStartingPoint.x = currentX;\n            currentStartingPoint.y = currentY;\n\n            // Do a radial layout starting with the center\n            point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n            if (point.y > height) {\n              height = Math.floor(point.y);\n            }\n            currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n          }\n          this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n        };\n        CoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n          var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n          CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n          var bounds = LGraph.calculateBounds(tree);\n          var transform = new Transform();\n          transform.setDeviceOrgX(bounds.getMinX());\n          transform.setDeviceOrgY(bounds.getMinY());\n          transform.setWorldOrgX(startingPoint.x);\n          transform.setWorldOrgY(startingPoint.y);\n          for (var i = 0; i < tree.length; i++) {\n            var node = tree[i];\n            node.transform(transform);\n          }\n          var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n          return transform.inverseTransformPoint(bottomRight);\n        };\n        CoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n          // First, position this node by finding its angle.\n          var halfInterval = (endAngle - startAngle + 1) / 2;\n          if (halfInterval < 0) {\n            halfInterval += 180;\n          }\n          var nodeAngle = (halfInterval + startAngle) % 360;\n          var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n          // Make polar to java cordinate conversion.\n          var cos_teta = Math.cos(teta);\n          var x_ = distance * Math.cos(teta);\n          var y_ = distance * Math.sin(teta);\n          node.setCenter(x_, y_);\n\n          // Traverse all neighbors of this node and recursively call this\n          // function.\n          var neighborEdges = [];\n          neighborEdges = neighborEdges.concat(node.getEdges());\n          var childCount = neighborEdges.length;\n          if (parentOfNode != null) {\n            childCount--;\n          }\n          var branchCount = 0;\n          var incEdgesCount = neighborEdges.length;\n          var startIndex;\n          var edges = node.getEdgesBetween(parentOfNode);\n\n          // If there are multiple edges, prune them until there remains only one\n          // edge.\n          while (edges.length > 1) {\n            //neighborEdges.remove(edges.remove(0));\n            var temp = edges[0];\n            edges.splice(0, 1);\n            var index = neighborEdges.indexOf(temp);\n            if (index >= 0) {\n              neighborEdges.splice(index, 1);\n            }\n            incEdgesCount--;\n            childCount--;\n          }\n          if (parentOfNode != null) {\n            //assert edges.length == 1;\n            startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n          } else {\n            startIndex = 0;\n          }\n          var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n          for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n            var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n            // Don't back traverse to root node in current tree.\n            if (currentNeighbor == parentOfNode) {\n              continue;\n            }\n            var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n            var childEndAngle = (childStartAngle + stepAngle) % 360;\n            CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n            branchCount++;\n          }\n        };\n        CoSELayout.maxDiagonalInTree = function (tree) {\n          var maxDiagonal = Integer.MIN_VALUE;\n          for (var i = 0; i < tree.length; i++) {\n            var node = tree[i];\n            var diagonal = node.getDiagonal();\n            if (diagonal > maxDiagonal) {\n              maxDiagonal = diagonal;\n            }\n          }\n          return maxDiagonal;\n        };\n        CoSELayout.prototype.calcRepulsionRange = function () {\n          // formula is 2 x (level + 1) x idealEdgeLength\n          return 2 * (this.level + 1) * this.idealEdgeLength;\n        };\n\n        // Tiling methods\n\n        // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\n        CoSELayout.prototype.groupZeroDegreeMembers = function () {\n          var self = this;\n          // array of [parent_id x oneDegreeNode_id]\n          var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n          this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n          this.idToDummyNode = {}; // A map of id to dummy node \n\n          var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n          var allNodes = this.graphManager.getAllNodes();\n\n          // Fill zero degree list\n          for (var i = 0; i < allNodes.length; i++) {\n            var node = allNodes[i];\n            var parent = node.getParent();\n            // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n            if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n              zeroDegree.push(node);\n            }\n          }\n\n          // Create a map of parent node and its zero degree members\n          for (var i = 0; i < zeroDegree.length; i++) {\n            var node = zeroDegree[i]; // Zero degree node itself\n            var p_id = node.getParent().id; // Parent id\n\n            if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n            tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n          }\n\n          // If there are at least two nodes at a level, create a dummy compound for them\n          Object.keys(tempMemberGroups).forEach(function (p_id) {\n            if (tempMemberGroups[p_id].length > 1) {\n              var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n              self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n              var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n              // Create a dummy compound with calculated id\n              var dummyCompound = new CoSENode(self.graphManager);\n              dummyCompound.id = dummyCompoundId;\n              dummyCompound.paddingLeft = parent.paddingLeft || 0;\n              dummyCompound.paddingRight = parent.paddingRight || 0;\n              dummyCompound.paddingBottom = parent.paddingBottom || 0;\n              dummyCompound.paddingTop = parent.paddingTop || 0;\n              self.idToDummyNode[dummyCompoundId] = dummyCompound;\n              var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n              var parentGraph = parent.getChild();\n\n              // Add dummy compound to parent the graph\n              parentGraph.add(dummyCompound);\n\n              // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n              for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n                var node = tempMemberGroups[p_id][i];\n                parentGraph.remove(node);\n                dummyParentGraph.add(node);\n              }\n            }\n          });\n        };\n        CoSELayout.prototype.clearCompounds = function () {\n          var childGraphMap = {};\n          var idToNode = {};\n\n          // Get compound ordering by finding the inner one first\n          this.performDFSOnCompounds();\n          for (var i = 0; i < this.compoundOrder.length; i++) {\n            idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n            childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n            // Remove children of compounds\n            this.graphManager.remove(this.compoundOrder[i].getChild());\n            this.compoundOrder[i].child = null;\n          }\n          this.graphManager.resetAllNodes();\n\n          // Tile the removed children\n          this.tileCompoundMembers(childGraphMap, idToNode);\n        };\n        CoSELayout.prototype.clearZeroDegreeMembers = function () {\n          var self = this;\n          var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n          Object.keys(this.memberGroups).forEach(function (id) {\n            var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n            tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n            // Set the width and height of the dummy compound as calculated\n            compoundNode.rect.width = tiledZeroDegreePack[id].width;\n            compoundNode.rect.height = tiledZeroDegreePack[id].height;\n            compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n\n            // compound left and top margings for labels\n            // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n            // otherwise they stay as zero\n            compoundNode.labelMarginLeft = 0;\n            compoundNode.labelMarginTop = 0;\n\n            // Update compound bounds considering its label properties and set label margins for left and top\n            if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n              var width = compoundNode.rect.width;\n              var height = compoundNode.rect.height;\n              if (compoundNode.labelWidth) {\n                if (compoundNode.labelPosHorizontal == \"left\") {\n                  compoundNode.rect.x -= compoundNode.labelWidth;\n                  compoundNode.setWidth(width + compoundNode.labelWidth);\n                  compoundNode.labelMarginLeft = compoundNode.labelWidth;\n                } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n                  compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n                  compoundNode.setWidth(compoundNode.labelWidth);\n                  compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n                } else if (compoundNode.labelPosHorizontal == \"right\") {\n                  compoundNode.setWidth(width + compoundNode.labelWidth);\n                }\n              }\n              if (compoundNode.labelHeight) {\n                if (compoundNode.labelPosVertical == \"top\") {\n                  compoundNode.rect.y -= compoundNode.labelHeight;\n                  compoundNode.setHeight(height + compoundNode.labelHeight);\n                  compoundNode.labelMarginTop = compoundNode.labelHeight;\n                } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n                  compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n                  compoundNode.setHeight(compoundNode.labelHeight);\n                  compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n                } else if (compoundNode.labelPosVertical == \"bottom\") {\n                  compoundNode.setHeight(height + compoundNode.labelHeight);\n                }\n              }\n            }\n          });\n        };\n        CoSELayout.prototype.repopulateCompounds = function () {\n          for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n            var lCompoundNode = this.compoundOrder[i];\n            var id = lCompoundNode.id;\n            var horizontalMargin = lCompoundNode.paddingLeft;\n            var verticalMargin = lCompoundNode.paddingTop;\n            var labelMarginLeft = lCompoundNode.labelMarginLeft;\n            var labelMarginTop = lCompoundNode.labelMarginTop;\n            this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n          }\n        };\n        CoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n          var self = this;\n          var tiledPack = this.tiledZeroDegreePack;\n          Object.keys(tiledPack).forEach(function (id) {\n            var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n            var horizontalMargin = compoundNode.paddingLeft;\n            var verticalMargin = compoundNode.paddingTop;\n            var labelMarginLeft = compoundNode.labelMarginLeft;\n            var labelMarginTop = compoundNode.labelMarginTop;\n\n            // Adjust the positions of nodes wrt its compound\n            self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n          });\n        };\n        CoSELayout.prototype.getToBeTiled = function (node) {\n          var id = node.id;\n          //firstly check the previous results\n          if (this.toBeTiled[id] != null) {\n            return this.toBeTiled[id];\n          }\n\n          //only compound nodes are to be tiled\n          var childGraph = node.getChild();\n          if (childGraph == null) {\n            this.toBeTiled[id] = false;\n            return false;\n          }\n          var children = childGraph.getNodes(); // Get the children nodes\n\n          //a compound node is not to be tiled if all of its compound children are not to be tiled\n          for (var i = 0; i < children.length; i++) {\n            var theChild = children[i];\n            if (this.getNodeDegree(theChild) > 0) {\n              this.toBeTiled[id] = false;\n              return false;\n            }\n\n            //pass the children not having the compound structure\n            if (theChild.getChild() == null) {\n              this.toBeTiled[theChild.id] = false;\n              continue;\n            }\n            if (!this.getToBeTiled(theChild)) {\n              this.toBeTiled[id] = false;\n              return false;\n            }\n          }\n          this.toBeTiled[id] = true;\n          return true;\n        };\n\n        // Get degree of a node depending of its edges and independent of its children\n        CoSELayout.prototype.getNodeDegree = function (node) {\n          var id = node.id;\n          var edges = node.getEdges();\n          var degree = 0;\n\n          // For the edges connected\n          for (var i = 0; i < edges.length; i++) {\n            var edge = edges[i];\n            if (edge.getSource().id !== edge.getTarget().id) {\n              degree = degree + 1;\n            }\n          }\n          return degree;\n        };\n\n        // Get degree of a node with its children\n        CoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n          var degree = this.getNodeDegree(node);\n          if (node.getChild() == null) {\n            return degree;\n          }\n          var children = node.getChild().getNodes();\n          for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            degree += this.getNodeDegreeWithChildren(child);\n          }\n          return degree;\n        };\n        CoSELayout.prototype.performDFSOnCompounds = function () {\n          this.compoundOrder = [];\n          this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n        };\n        CoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n          for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            if (child.getChild() != null) {\n              this.fillCompexOrderByDFS(child.getChild().getNodes());\n            }\n            if (this.getToBeTiled(child)) {\n              this.compoundOrder.push(child);\n            }\n          }\n        };\n\n        /**\n        * This method places each zero degree member wrt given (x,y) coordinates (top left).\n        */\n        CoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n          x += compoundHorizontalMargin + compoundLabelMarginLeft;\n          y += compoundVerticalMargin + compoundLabelMarginTop;\n          var left = x;\n          for (var i = 0; i < organization.rows.length; i++) {\n            var row = organization.rows[i];\n            x = left;\n            var maxHeight = 0;\n            for (var j = 0; j < row.length; j++) {\n              var lnode = row[j];\n              lnode.rect.x = x; // + lnode.rect.width / 2;\n              lnode.rect.y = y; // + lnode.rect.height / 2;\n\n              x += lnode.rect.width + organization.horizontalPadding;\n              if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n            }\n            y += maxHeight + organization.verticalPadding;\n          }\n        };\n        CoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n          var self = this;\n          this.tiledMemberPack = [];\n          Object.keys(childGraphMap).forEach(function (id) {\n            // Get the compound node\n            var compoundNode = idToNode[id];\n            self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n            compoundNode.rect.width = self.tiledMemberPack[id].width;\n            compoundNode.rect.height = self.tiledMemberPack[id].height;\n            compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n\n            // compound left and top margings for labels\n            // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n            // otherwise they stay as zero\n            compoundNode.labelMarginLeft = 0;\n            compoundNode.labelMarginTop = 0;\n\n            // Update compound bounds considering its label properties and set label margins for left and top\n            if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n              var width = compoundNode.rect.width;\n              var height = compoundNode.rect.height;\n              if (compoundNode.labelWidth) {\n                if (compoundNode.labelPosHorizontal == \"left\") {\n                  compoundNode.rect.x -= compoundNode.labelWidth;\n                  compoundNode.setWidth(width + compoundNode.labelWidth);\n                  compoundNode.labelMarginLeft = compoundNode.labelWidth;\n                } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n                  compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n                  compoundNode.setWidth(compoundNode.labelWidth);\n                  compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n                } else if (compoundNode.labelPosHorizontal == \"right\") {\n                  compoundNode.setWidth(width + compoundNode.labelWidth);\n                }\n              }\n              if (compoundNode.labelHeight) {\n                if (compoundNode.labelPosVertical == \"top\") {\n                  compoundNode.rect.y -= compoundNode.labelHeight;\n                  compoundNode.setHeight(height + compoundNode.labelHeight);\n                  compoundNode.labelMarginTop = compoundNode.labelHeight;\n                } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n                  compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n                  compoundNode.setHeight(compoundNode.labelHeight);\n                  compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n                } else if (compoundNode.labelPosVertical == \"bottom\") {\n                  compoundNode.setHeight(height + compoundNode.labelHeight);\n                }\n              }\n            }\n          });\n        };\n        CoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n          var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);\n          var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);\n          var horizontalRatio = this.getOrgRatio(horizontalOrg);\n          var verticalRatio = this.getOrgRatio(verticalOrg);\n          var bestOrg;\n\n          // the best ratio is the one that is closer to 1 since the ratios are already normalized\n          // and the best organization is the one that has the best ratio\n          if (verticalRatio < horizontalRatio) {\n            bestOrg = verticalOrg;\n          } else {\n            bestOrg = horizontalOrg;\n          }\n          return bestOrg;\n        };\n\n        // get the width/height ratio of the organization that is normalized so that it will not be less than 1\n        CoSELayout.prototype.getOrgRatio = function (organization) {\n          // get dimensions and calculate the initial ratio\n          var width = organization.width;\n          var height = organization.height;\n          var ratio = width / height;\n\n          // if the initial ratio is less then 1 then inverse it\n          if (ratio < 1) {\n            ratio = 1 / ratio;\n          }\n\n          // return the normalized ratio\n          return ratio;\n        };\n\n        /*\n         * Calculates the ideal width for the rows. This method assumes that\n         * each node has the same sizes and calculates the ideal row width that\n         * approximates a square shaped complex accordingly. However, since nodes would\n         * have different sizes some rows would have different sizes and the resulting\n         * shape would not be an exact square.\n         */\n        CoSELayout.prototype.calcIdealRowWidth = function (members, favorHorizontalDim) {\n          // To approximate a square shaped complex we need to make complex width equal to complex height.\n          // To achieve this we need to solve the following equation system for hc:\n          // (x + bx) * hc - bx = (y + by) * vc - by, hc * vc = n\n          // where x is the avarage width of the nodes, y is the avarage height of nodes\n          // bx and by are the buffer sizes in horizontal and vertical dimensions accordingly,\n          // hc and vc are the number of rows in horizontal and vertical dimensions\n          // n is number of members.\n\n          var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n          var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n\n          // number of members\n          var membersSize = members.length;\n\n          // sum of the width of all members\n          var totalWidth = 0;\n\n          // sum of the height of all members\n          var totalHeight = 0;\n          var maxWidth = 0;\n\n          // traverse all members to calculate total width and total height and get the maximum members width\n          members.forEach(function (node) {\n            totalWidth += node.getWidth();\n            totalHeight += node.getHeight();\n            if (node.getWidth() > maxWidth) {\n              maxWidth = node.getWidth();\n            }\n          });\n\n          // average width of the members\n          var averageWidth = totalWidth / membersSize;\n\n          // average height of the members\n          var averageHeight = totalHeight / membersSize;\n\n          // solving the initial equation system for the hc yields the following second degree equation:\n          // hc^2 * (x+bx) + hc * (by - bx) - n * (y + by) = 0\n\n          // the delta value to solve the equation above for hc\n          var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;\n\n          // solve the equation using delta value to calculate the horizontal count\n          // that represents the number of nodes in an ideal row\n          var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));\n          // round the calculated horizontal count up or down according to the favored dimension\n          var horizontalCount;\n          if (favorHorizontalDim) {\n            horizontalCount = Math.ceil(horizontalCountDouble);\n            // if horizontalCount count is not a float value then both of rounding to floor and ceil\n            // will yield the same values. Instead of repeating the same calculation try going up\n            // while favoring horizontal dimension in such cases\n            if (horizontalCount == horizontalCountDouble) {\n              horizontalCount++;\n            }\n          } else {\n            horizontalCount = Math.floor(horizontalCountDouble);\n          }\n\n          // ideal width to be calculated\n          var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;\n\n          // if max width is bigger than calculated ideal width reset ideal width to it\n          if (maxWidth > idealWidth) {\n            idealWidth = maxWidth;\n          }\n\n          // add the left-right margins to the ideal row width\n          idealWidth += horizontalPadding * 2;\n\n          // return the ideal row width1\n          return idealWidth;\n        };\n        CoSELayout.prototype.tileNodesByFavoringDim = function (nodes, minWidth, favorHorizontalDim) {\n          var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n          var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n          var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;\n          var organization = {\n            rows: [],\n            rowWidth: [],\n            rowHeight: [],\n            width: 0,\n            height: minWidth,\n            // assume minHeight equals to minWidth\n            verticalPadding: verticalPadding,\n            horizontalPadding: horizontalPadding,\n            centerX: 0,\n            centerY: 0\n          };\n          if (tilingCompareBy) {\n            organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);\n          }\n          var getNodeArea = function getNodeArea(n) {\n            return n.rect.width * n.rect.height;\n          };\n          var areaCompareFcn = function areaCompareFcn(n1, n2) {\n            return getNodeArea(n2) - getNodeArea(n1);\n          };\n\n          // Sort the nodes in descending order of their areas\n          nodes.sort(function (n1, n2) {\n            var cmpBy = areaCompareFcn;\n            if (organization.idealRowWidth) {\n              cmpBy = tilingCompareBy;\n              return cmpBy(n1.id, n2.id);\n            }\n            return cmpBy(n1, n2);\n          });\n\n          // Create the organization -> calculate compound center\n          var sumCenterX = 0;\n          var sumCenterY = 0;\n          for (var i = 0; i < nodes.length; i++) {\n            var lNode = nodes[i];\n            sumCenterX += lNode.getCenterX();\n            sumCenterY += lNode.getCenterY();\n          }\n          organization.centerX = sumCenterX / nodes.length;\n          organization.centerY = sumCenterY / nodes.length;\n\n          // Create the organization -> tile members\n          for (var i = 0; i < nodes.length; i++) {\n            var lNode = nodes[i];\n            if (organization.rows.length == 0) {\n              this.insertNodeToRow(organization, lNode, 0, minWidth);\n            } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n              var rowIndex = organization.rows.length - 1;\n              if (!organization.idealRowWidth) {\n                rowIndex = this.getShortestRowIndex(organization);\n              }\n              this.insertNodeToRow(organization, lNode, rowIndex, minWidth);\n            } else {\n              this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n            }\n            this.shiftToLastRow(organization);\n          }\n          return organization;\n        };\n        CoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n          var minCompoundSize = minWidth;\n\n          // Add new row if needed\n          if (rowIndex == organization.rows.length) {\n            var secondDimension = [];\n            organization.rows.push(secondDimension);\n            organization.rowWidth.push(minCompoundSize);\n            organization.rowHeight.push(0);\n          }\n\n          // Update row width\n          var w = organization.rowWidth[rowIndex] + node.rect.width;\n          if (organization.rows[rowIndex].length > 0) {\n            w += organization.horizontalPadding;\n          }\n          organization.rowWidth[rowIndex] = w;\n          // Update compound width\n          if (organization.width < w) {\n            organization.width = w;\n          }\n\n          // Update height\n          var h = node.rect.height;\n          if (rowIndex > 0) h += organization.verticalPadding;\n          var extraHeight = 0;\n          if (h > organization.rowHeight[rowIndex]) {\n            extraHeight = organization.rowHeight[rowIndex];\n            organization.rowHeight[rowIndex] = h;\n            extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n          }\n          organization.height += extraHeight;\n\n          // Insert node\n          organization.rows[rowIndex].push(node);\n        };\n\n        //Scans the rows of an organization and returns the one with the min width\n        CoSELayout.prototype.getShortestRowIndex = function (organization) {\n          var r = -1;\n          var min = Number.MAX_VALUE;\n          for (var i = 0; i < organization.rows.length; i++) {\n            if (organization.rowWidth[i] < min) {\n              r = i;\n              min = organization.rowWidth[i];\n            }\n          }\n          return r;\n        };\n\n        //Scans the rows of an organization and returns the one with the max width\n        CoSELayout.prototype.getLongestRowIndex = function (organization) {\n          var r = -1;\n          var max = Number.MIN_VALUE;\n          for (var i = 0; i < organization.rows.length; i++) {\n            if (organization.rowWidth[i] > max) {\n              r = i;\n              max = organization.rowWidth[i];\n            }\n          }\n          return r;\n        };\n\n        /**\n        * This method checks whether adding extra width to the organization violates\n        * the aspect ratio(1) or not.\n        */\n        CoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n          // if there is an ideal row width specified use it instead of checking the aspect ratio\n          if (organization.idealRowWidth) {\n            var lastRowIndex = organization.rows.length - 1;\n            var lastRowWidth = organization.rowWidth[lastRowIndex];\n\n            // check and return if ideal row width will be exceed if the node is added to the row\n            return lastRowWidth + extraWidth + organization.horizontalPadding <= organization.idealRowWidth;\n          }\n          var sri = this.getShortestRowIndex(organization);\n          if (sri < 0) {\n            return true;\n          }\n          var min = organization.rowWidth[sri];\n          if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n          var hDiff = 0;\n\n          // Adding to an existing row\n          if (organization.rowHeight[sri] < extraHeight) {\n            if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n          }\n          var add_to_row_ratio;\n          if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n            add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n          } else {\n            add_to_row_ratio = (organization.height + hDiff) / organization.width;\n          }\n\n          // Adding a new row for this node\n          hDiff = extraHeight + organization.verticalPadding;\n          var add_new_row_ratio;\n          if (organization.width < extraWidth) {\n            add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n          } else {\n            add_new_row_ratio = (organization.height + hDiff) / organization.width;\n          }\n          if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n          if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n          return add_to_row_ratio < add_new_row_ratio;\n        };\n\n        //If moving the last node from the longest row and adding it to the last\n        //row makes the bounding box smaller, do it.\n        CoSELayout.prototype.shiftToLastRow = function (organization) {\n          var longest = this.getLongestRowIndex(organization);\n          var last = organization.rowWidth.length - 1;\n          var row = organization.rows[longest];\n          var node = row[row.length - 1];\n          var diff = node.width + organization.horizontalPadding;\n\n          // Check if there is enough space on the last row\n          if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n            // Remove the last element of the longest row\n            row.splice(-1, 1);\n\n            // Push it to the last row\n            organization.rows[last].push(node);\n            organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n            organization.rowWidth[last] = organization.rowWidth[last] + diff;\n            organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n            // Update heights of the organization\n            var maxHeight = Number.MIN_VALUE;\n            for (var i = 0; i < row.length; i++) {\n              if (row[i].height > maxHeight) maxHeight = row[i].height;\n            }\n            if (longest > 0) maxHeight += organization.verticalPadding;\n            var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n            organization.rowHeight[longest] = maxHeight;\n            if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n            var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n            organization.height += finalTotal - prevTotal;\n            this.shiftToLastRow(organization);\n          }\n        };\n        CoSELayout.prototype.tilingPreLayout = function () {\n          if (CoSEConstants.TILE) {\n            // Find zero degree nodes and create a compound for each level\n            this.groupZeroDegreeMembers();\n            // Tile and clear children of each compound\n            this.clearCompounds();\n            // Separately tile and clear zero degree nodes for each level\n            this.clearZeroDegreeMembers();\n          }\n        };\n        CoSELayout.prototype.tilingPostLayout = function () {\n          if (CoSEConstants.TILE) {\n            this.repopulateZeroDegreeMembers();\n            this.repopulateCompounds();\n          }\n        };\n\n        // -----------------------------------------------------------------------------\n        // Section: Tree Reduction methods\n        // -----------------------------------------------------------------------------\n        // Reduce trees \n        CoSELayout.prototype.reduceTrees = function () {\n          var prunedNodesAll = [];\n          var containsLeaf = true;\n          var node;\n          while (containsLeaf) {\n            var allNodes = this.graphManager.getAllNodes();\n            var prunedNodesInStepTemp = [];\n            containsLeaf = false;\n            for (var i = 0; i < allNodes.length; i++) {\n              node = allNodes[i];\n              if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n                if (CoSEConstants.PURE_INCREMENTAL) {\n                  var otherEnd = node.getEdges()[0].getOtherEnd(node);\n                  var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n                  prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);\n                } else {\n                  prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n                }\n                containsLeaf = true;\n              }\n            }\n            if (containsLeaf == true) {\n              var prunedNodesInStep = [];\n              for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n                if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n                  prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n                  prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n                }\n              }\n              prunedNodesAll.push(prunedNodesInStep);\n              this.graphManager.resetAllNodes();\n              this.graphManager.resetAllEdges();\n            }\n          }\n          this.prunedNodesAll = prunedNodesAll;\n        };\n\n        // Grow tree one step \n        CoSELayout.prototype.growTree = function (prunedNodesAll) {\n          var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n          var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n          var nodeData;\n          for (var i = 0; i < prunedNodesInStep.length; i++) {\n            nodeData = prunedNodesInStep[i];\n            this.findPlaceforPrunedNode(nodeData);\n            nodeData[2].add(nodeData[0]);\n            nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n          }\n          prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n          this.graphManager.resetAllNodes();\n          this.graphManager.resetAllEdges();\n        };\n\n        // Find an appropriate position to replace pruned node, this method can be improved\n        CoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n          var gridForPrunedNode;\n          var nodeToConnect;\n          var prunedNode = nodeData[0];\n          if (prunedNode == nodeData[1].source) {\n            nodeToConnect = nodeData[1].target;\n          } else {\n            nodeToConnect = nodeData[1].source;\n          }\n          if (CoSEConstants.PURE_INCREMENTAL) {\n            prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n          } else {\n            var startGridX = nodeToConnect.startX;\n            var finishGridX = nodeToConnect.finishX;\n            var startGridY = nodeToConnect.startY;\n            var finishGridY = nodeToConnect.finishY;\n            var upNodeCount = 0;\n            var downNodeCount = 0;\n            var rightNodeCount = 0;\n            var leftNodeCount = 0;\n            var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n            if (startGridY > 0) {\n              for (var i = startGridX; i <= finishGridX; i++) {\n                controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n              }\n            }\n            if (finishGridX < this.grid.length - 1) {\n              for (var i = startGridY; i <= finishGridY; i++) {\n                controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n              }\n            }\n            if (finishGridY < this.grid[0].length - 1) {\n              for (var i = startGridX; i <= finishGridX; i++) {\n                controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n              }\n            }\n            if (startGridX > 0) {\n              for (var i = startGridY; i <= finishGridY; i++) {\n                controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n              }\n            }\n            var min = Integer.MAX_VALUE;\n            var minCount;\n            var minIndex;\n            for (var j = 0; j < controlRegions.length; j++) {\n              if (controlRegions[j] < min) {\n                min = controlRegions[j];\n                minCount = 1;\n                minIndex = j;\n              } else if (controlRegions[j] == min) {\n                minCount++;\n              }\n            }\n            if (minCount == 3 && min == 0) {\n              if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n                gridForPrunedNode = 1;\n              } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n                gridForPrunedNode = 0;\n              } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                gridForPrunedNode = 3;\n              } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                gridForPrunedNode = 2;\n              }\n            } else if (minCount == 2 && min == 0) {\n              var random = Math.floor(Math.random() * 2);\n              if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n                ;\n                if (random == 0) {\n                  gridForPrunedNode = 0;\n                } else {\n                  gridForPrunedNode = 1;\n                }\n              } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n                if (random == 0) {\n                  gridForPrunedNode = 0;\n                } else {\n                  gridForPrunedNode = 2;\n                }\n              } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n                if (random == 0) {\n                  gridForPrunedNode = 0;\n                } else {\n                  gridForPrunedNode = 3;\n                }\n              } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n                if (random == 0) {\n                  gridForPrunedNode = 1;\n                } else {\n                  gridForPrunedNode = 2;\n                }\n              } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n                if (random == 0) {\n                  gridForPrunedNode = 1;\n                } else {\n                  gridForPrunedNode = 3;\n                }\n              } else {\n                if (random == 0) {\n                  gridForPrunedNode = 2;\n                } else {\n                  gridForPrunedNode = 3;\n                }\n              }\n            } else if (minCount == 4 && min == 0) {\n              var random = Math.floor(Math.random() * 4);\n              gridForPrunedNode = random;\n            } else {\n              gridForPrunedNode = minIndex;\n            }\n            if (gridForPrunedNode == 0) {\n              prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n            } else if (gridForPrunedNode == 1) {\n              prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n            } else if (gridForPrunedNode == 2) {\n              prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n            } else {\n              prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n            }\n          }\n        };\n        module.exports = CoSELayout;\n\n        /***/\n      }),\n      /***/991: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var FDLayoutNode = __webpack_require__(551).FDLayoutNode;\n        var IMath = __webpack_require__(551).IMath;\n        function CoSENode(gm, loc, size, vNode) {\n          FDLayoutNode.call(this, gm, loc, size, vNode);\n        }\n        CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n        for (var prop in FDLayoutNode) {\n          CoSENode[prop] = FDLayoutNode[prop];\n        }\n        CoSENode.prototype.calculateDisplacement = function () {\n          var layout = this.graphManager.getLayout();\n          // this check is for compound nodes that contain fixed nodes\n          if (this.getChild() != null && this.fixedNodeWeight) {\n            this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n            this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n          } else {\n            this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n            this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n          }\n          if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n            this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n          }\n          if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n            this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n          }\n\n          // non-empty compound node, propogate movement to children as well\n          if (this.child && this.child.getNodes().length > 0) {\n            this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n          }\n        };\n        CoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n          var nodes = this.getChild().getNodes();\n          var node;\n          for (var i = 0; i < nodes.length; i++) {\n            node = nodes[i];\n            if (node.getChild() == null) {\n              node.displacementX += dX;\n              node.displacementY += dY;\n            } else {\n              node.propogateDisplacementToChildren(dX, dY);\n            }\n          }\n        };\n        CoSENode.prototype.move = function () {\n          var layout = this.graphManager.getLayout();\n\n          // a simple node or an empty compound node, move it\n          if (this.child == null || this.child.getNodes().length == 0) {\n            this.moveBy(this.displacementX, this.displacementY);\n            layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n          }\n          this.springForceX = 0;\n          this.springForceY = 0;\n          this.repulsionForceX = 0;\n          this.repulsionForceY = 0;\n          this.gravitationForceX = 0;\n          this.gravitationForceY = 0;\n          this.displacementX = 0;\n          this.displacementY = 0;\n        };\n        CoSENode.prototype.setPred1 = function (pred1) {\n          this.pred1 = pred1;\n        };\n        CoSENode.prototype.getPred1 = function () {\n          return pred1;\n        };\n        CoSENode.prototype.getPred2 = function () {\n          return pred2;\n        };\n        CoSENode.prototype.setNext = function (next) {\n          this.next = next;\n        };\n        CoSENode.prototype.getNext = function () {\n          return next;\n        };\n        CoSENode.prototype.setProcessed = function (processed) {\n          this.processed = processed;\n        };\n        CoSENode.prototype.isProcessed = function () {\n          return processed;\n        };\n        module.exports = CoSENode;\n\n        /***/\n      }),\n      /***/902: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        function _toConsumableArray(arr) {\n          if (Array.isArray(arr)) {\n            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n              arr2[i] = arr[i];\n            }\n            return arr2;\n          } else {\n            return Array.from(arr);\n          }\n        }\n        var CoSEConstants = __webpack_require__(806);\n        var LinkedList = __webpack_require__(551).LinkedList;\n        var Matrix = __webpack_require__(551).Matrix;\n        var SVD = __webpack_require__(551).SVD;\n        function ConstraintHandler() {}\n        ConstraintHandler.handleConstraints = function (layout) {\n          //  let layout = this.graphManager.getLayout();\n\n          // get constraints from layout\n          var constraints = {};\n          constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n          constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n          constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n          var idToNodeMap = new Map();\n          var nodeIndexes = new Map();\n          var xCoords = [];\n          var yCoords = [];\n          var allNodes = layout.getAllNodes();\n          var index = 0;\n          // fill index map and coordinates\n          for (var i = 0; i < allNodes.length; i++) {\n            var node = allNodes[i];\n            if (node.getChild() == null) {\n              nodeIndexes.set(node.id, index++);\n              xCoords.push(node.getCenterX());\n              yCoords.push(node.getCenterY());\n              idToNodeMap.set(node.id, node);\n            }\n          }\n\n          // if there exists relative placement constraint without gap value, set it to default \n          if (constraints.relativePlacementConstraint) {\n            constraints.relativePlacementConstraint.forEach(function (constraint) {\n              if (!constraint.gap && constraint.gap != 0) {\n                if (constraint.left) {\n                  constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n                } else {\n                  constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n                }\n              }\n            });\n          }\n\n          /* auxiliary functions */\n\n          // calculate difference between two position objects\n          var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n            return {\n              x: pos1.x - pos2.x,\n              y: pos1.y - pos2.y\n            };\n          };\n\n          // calculate average position of the nodes\n          var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n            var xPosSum = 0;\n            var yPosSum = 0;\n            nodeIdSet.forEach(function (nodeId) {\n              xPosSum += xCoords[nodeIndexes.get(nodeId)];\n              yPosSum += yCoords[nodeIndexes.get(nodeId)];\n            });\n            return {\n              x: xPosSum / nodeIdSet.size,\n              y: yPosSum / nodeIdSet.size\n            };\n          };\n\n          // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n          // this function also takes the fixed nodes and alignment constraints into account\n          // graph: dag to be evaluated, direction: \"horizontal\" or \"vertical\", \n          // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n          var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n            // find union of two sets\n            function setUnion(setA, setB) {\n              var union = new Set(setA);\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n              try {\n                for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var elem = _step.value;\n                  union.add(elem);\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n              return union;\n            }\n\n            // find indegree count for each node\n            var inDegrees = new Map();\n            graph.forEach(function (value, key) {\n              inDegrees.set(key, 0);\n            });\n            graph.forEach(function (value, key) {\n              value.forEach(function (adjacent) {\n                inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n              });\n            });\n            var positionMap = new Map(); // keeps the position for each node\n            var pastMap = new Map(); // keeps the predecessors(past) of a node\n            var queue = new LinkedList();\n            inDegrees.forEach(function (value, key) {\n              if (value == 0) {\n                queue.push(key);\n                if (!fixedNodes) {\n                  if (direction == \"horizontal\") {\n                    positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n                  } else {\n                    positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n                  }\n                }\n              } else {\n                positionMap.set(key, Number.NEGATIVE_INFINITY);\n              }\n              if (fixedNodes) {\n                pastMap.set(key, new Set([key]));\n              }\n            });\n\n            // align sources of each component in enforcement phase\n            if (fixedNodes) {\n              componentSources.forEach(function (component) {\n                var fixedIds = [];\n                component.forEach(function (nodeId) {\n                  if (fixedNodes.has(nodeId)) {\n                    fixedIds.push(nodeId);\n                  }\n                });\n                if (fixedIds.length > 0) {\n                  var position = 0;\n                  fixedIds.forEach(function (fixedId) {\n                    if (direction == \"horizontal\") {\n                      positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                      position += positionMap.get(fixedId);\n                    } else {\n                      positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                      position += positionMap.get(fixedId);\n                    }\n                  });\n                  position = position / fixedIds.length;\n                  component.forEach(function (nodeId) {\n                    if (!fixedNodes.has(nodeId)) {\n                      positionMap.set(nodeId, position);\n                    }\n                  });\n                } else {\n                  var _position = 0;\n                  component.forEach(function (nodeId) {\n                    if (direction == \"horizontal\") {\n                      _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                    } else {\n                      _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                    }\n                  });\n                  _position = _position / component.length;\n                  component.forEach(function (nodeId) {\n                    positionMap.set(nodeId, _position);\n                  });\n                }\n              });\n            }\n\n            // calculate positions of the nodes\n\n            var _loop = function _loop() {\n              var currentNode = queue.shift();\n              var neighbors = graph.get(currentNode);\n              neighbors.forEach(function (neighbor) {\n                if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n                  if (fixedNodes && fixedNodes.has(neighbor.id)) {\n                    var fixedPosition = void 0;\n                    if (direction == \"horizontal\") {\n                      fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                    } else {\n                      fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                    }\n                    positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n                    if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n                      var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n                      pastMap.get(currentNode).forEach(function (nodeId) {\n                        positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n                      });\n                    }\n                  } else {\n                    positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n                  }\n                }\n                inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n                if (inDegrees.get(neighbor.id) == 0) {\n                  queue.push(neighbor.id);\n                }\n                if (fixedNodes) {\n                  pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n                }\n              });\n            };\n            while (queue.length != 0) {\n              _loop();\n            }\n\n            // readjust position of the nodes after enforcement\n            if (fixedNodes) {\n              // find indegree count for each node\n              var sinkNodes = new Set();\n              graph.forEach(function (value, key) {\n                if (value.length == 0) {\n                  sinkNodes.add(key);\n                }\n              });\n              var _components = [];\n              pastMap.forEach(function (value, key) {\n                if (sinkNodes.has(key)) {\n                  var isFixedComponent = false;\n                  var _iteratorNormalCompletion2 = true;\n                  var _didIteratorError2 = false;\n                  var _iteratorError2 = undefined;\n                  try {\n                    for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                      var nodeId = _step2.value;\n                      if (fixedNodes.has(nodeId)) {\n                        isFixedComponent = true;\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                      }\n                    } finally {\n                      if (_didIteratorError2) {\n                        throw _iteratorError2;\n                      }\n                    }\n                  }\n                  if (!isFixedComponent) {\n                    var isExist = false;\n                    var existAt = void 0;\n                    _components.forEach(function (component, index) {\n                      if (component.has([].concat(_toConsumableArray(value))[0])) {\n                        isExist = true;\n                        existAt = index;\n                      }\n                    });\n                    if (!isExist) {\n                      _components.push(new Set(value));\n                    } else {\n                      value.forEach(function (ele) {\n                        _components[existAt].add(ele);\n                      });\n                    }\n                  }\n                }\n              });\n              _components.forEach(function (component, index) {\n                var minBefore = Number.POSITIVE_INFINITY;\n                var minAfter = Number.POSITIVE_INFINITY;\n                var maxBefore = Number.NEGATIVE_INFINITY;\n                var maxAfter = Number.NEGATIVE_INFINITY;\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n                try {\n                  for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var nodeId = _step3.value;\n                    var posBefore = void 0;\n                    if (direction == \"horizontal\") {\n                      posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                    } else {\n                      posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                    }\n                    var posAfter = positionMap.get(nodeId);\n                    if (posBefore < minBefore) {\n                      minBefore = posBefore;\n                    }\n                    if (posBefore > maxBefore) {\n                      maxBefore = posBefore;\n                    }\n                    if (posAfter < minAfter) {\n                      minAfter = posAfter;\n                    }\n                    if (posAfter > maxAfter) {\n                      maxAfter = posAfter;\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError3 = true;\n                  _iteratorError3 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                      _iterator3.return();\n                    }\n                  } finally {\n                    if (_didIteratorError3) {\n                      throw _iteratorError3;\n                    }\n                  }\n                }\n                var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n                var _iteratorNormalCompletion4 = true;\n                var _didIteratorError4 = false;\n                var _iteratorError4 = undefined;\n                try {\n                  for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var _nodeId = _step4.value;\n                    positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n                  }\n                } catch (err) {\n                  _didIteratorError4 = true;\n                  _iteratorError4 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                      _iterator4.return();\n                    }\n                  } finally {\n                    if (_didIteratorError4) {\n                      throw _iteratorError4;\n                    }\n                  }\n                }\n              });\n            }\n            return positionMap;\n          };\n\n          // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n          // or if there are only rel. placement contraints where the largest component isn't sufficiently large\n          var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n            // variables to count votes\n            var reflectOnY = 0,\n              notReflectOnY = 0;\n            var reflectOnX = 0,\n              notReflectOnX = 0;\n            relativePlacementConstraints.forEach(function (constraint) {\n              if (constraint.left) {\n                xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n              } else {\n                yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n              }\n            });\n            if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n              for (var _i = 0; _i < nodeIndexes.size; _i++) {\n                xCoords[_i] = -1 * xCoords[_i];\n                yCoords[_i] = -1 * yCoords[_i];\n              }\n            } else if (reflectOnY > notReflectOnY) {\n              for (var _i2 = 0; _i2 < nodeIndexes.size; _i2++) {\n                xCoords[_i2] = -1 * xCoords[_i2];\n              }\n            } else if (reflectOnX > notReflectOnX) {\n              for (var _i3 = 0; _i3 < nodeIndexes.size; _i3++) {\n                yCoords[_i3] = -1 * yCoords[_i3];\n              }\n            }\n          };\n\n          // find weakly connected components in undirected graph\n          var findComponents = function findComponents(graph) {\n            // find weakly connected components in dag\n            var components = [];\n            var queue = new LinkedList();\n            var visited = new Set();\n            var count = 0;\n            graph.forEach(function (value, key) {\n              if (!visited.has(key)) {\n                components[count] = [];\n                var _currentNode = key;\n                queue.push(_currentNode);\n                visited.add(_currentNode);\n                components[count].push(_currentNode);\n                while (queue.length != 0) {\n                  _currentNode = queue.shift();\n                  var neighbors = graph.get(_currentNode);\n                  neighbors.forEach(function (neighbor) {\n                    if (!visited.has(neighbor.id)) {\n                      queue.push(neighbor.id);\n                      visited.add(neighbor.id);\n                      components[count].push(neighbor.id);\n                    }\n                  });\n                }\n                count++;\n              }\n            });\n            return components;\n          };\n\n          // return undirected version of given dag\n          var dagToUndirected = function dagToUndirected(dag) {\n            var undirected = new Map();\n            dag.forEach(function (value, key) {\n              undirected.set(key, []);\n            });\n            dag.forEach(function (value, key) {\n              value.forEach(function (adjacent) {\n                undirected.get(key).push(adjacent);\n                undirected.get(adjacent.id).push({\n                  id: key,\n                  gap: adjacent.gap,\n                  direction: adjacent.direction\n                });\n              });\n            });\n            return undirected;\n          };\n\n          // return reversed (directions inverted) version of given dag\n          var dagToReversed = function dagToReversed(dag) {\n            var reversed = new Map();\n            dag.forEach(function (value, key) {\n              reversed.set(key, []);\n            });\n            dag.forEach(function (value, key) {\n              value.forEach(function (adjacent) {\n                reversed.get(adjacent.id).push({\n                  id: key,\n                  gap: adjacent.gap,\n                  direction: adjacent.direction\n                });\n              });\n            });\n            return reversed;\n          };\n\n          /****  apply transformation to the initial draft layout to better align with constrained nodes ****/\n          // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n          // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n\n          /* construct source and target configurations */\n\n          var targetMatrix = []; // A - target configuration\n          var sourceMatrix = []; // B - source configuration \n          var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n          var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary\n          var fixedNodes = new Set();\n          var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n          var dagUndirected = new Map(); // undirected version of the dag\n          var components = []; // weakly connected components\n\n          // fill fixedNodes collection to use later\n          if (constraints.fixedNodeConstraint) {\n            constraints.fixedNodeConstraint.forEach(function (nodeData) {\n              fixedNodes.add(nodeData.nodeId);\n            });\n          }\n\n          // construct dag from relative placement constraints \n          if (constraints.relativePlacementConstraint) {\n            // construct both directed and undirected version of the dag\n            constraints.relativePlacementConstraint.forEach(function (constraint) {\n              if (constraint.left) {\n                if (dag.has(constraint.left)) {\n                  dag.get(constraint.left).push({\n                    id: constraint.right,\n                    gap: constraint.gap,\n                    direction: \"horizontal\"\n                  });\n                } else {\n                  dag.set(constraint.left, [{\n                    id: constraint.right,\n                    gap: constraint.gap,\n                    direction: \"horizontal\"\n                  }]);\n                }\n                if (!dag.has(constraint.right)) {\n                  dag.set(constraint.right, []);\n                }\n              } else {\n                if (dag.has(constraint.top)) {\n                  dag.get(constraint.top).push({\n                    id: constraint.bottom,\n                    gap: constraint.gap,\n                    direction: \"vertical\"\n                  });\n                } else {\n                  dag.set(constraint.top, [{\n                    id: constraint.bottom,\n                    gap: constraint.gap,\n                    direction: \"vertical\"\n                  }]);\n                }\n                if (!dag.has(constraint.bottom)) {\n                  dag.set(constraint.bottom, []);\n                }\n              }\n            });\n            dagUndirected = dagToUndirected(dag);\n            components = findComponents(dagUndirected);\n          }\n          if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n            // first check fixed node constraint\n            if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n              constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n                targetMatrix[i] = [nodeData.position.x, nodeData.position.y];\n                sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeData.nodeId)], yCoords[nodeIndexes.get(nodeData.nodeId)]];\n              });\n              standardTransformation = true;\n            } else if (constraints.alignmentConstraint) {\n              (function () {\n                // then check alignment constraint\n                var count = 0;\n                if (constraints.alignmentConstraint.vertical) {\n                  var verticalAlign = constraints.alignmentConstraint.vertical;\n                  var _loop2 = function _loop2(_i4) {\n                    var alignmentSet = new Set();\n                    verticalAlign[_i4].forEach(function (nodeId) {\n                      alignmentSet.add(nodeId);\n                    });\n                    var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                      return fixedNodes.has(x);\n                    }));\n                    var xPos = void 0;\n                    if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n                    verticalAlign[_i4].forEach(function (nodeId) {\n                      targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];\n                      sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n                      count++;\n                    });\n                  };\n                  for (var _i4 = 0; _i4 < verticalAlign.length; _i4++) {\n                    _loop2(_i4);\n                  }\n                  standardTransformation = true;\n                }\n                if (constraints.alignmentConstraint.horizontal) {\n                  var horizontalAlign = constraints.alignmentConstraint.horizontal;\n                  var _loop3 = function _loop3(_i5) {\n                    var alignmentSet = new Set();\n                    horizontalAlign[_i5].forEach(function (nodeId) {\n                      alignmentSet.add(nodeId);\n                    });\n                    var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                      return fixedNodes.has(x);\n                    }));\n                    var yPos = void 0;\n                    if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n                    horizontalAlign[_i5].forEach(function (nodeId) {\n                      targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];\n                      sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n                      count++;\n                    });\n                  };\n                  for (var _i5 = 0; _i5 < horizontalAlign.length; _i5++) {\n                    _loop3(_i5);\n                  }\n                  standardTransformation = true;\n                }\n                if (constraints.relativePlacementConstraint) {\n                  reflectionType = true;\n                }\n              })();\n            } else if (constraints.relativePlacementConstraint) {\n              // finally check relative placement constraint\n              // find largest component in dag\n              var largestComponentSize = 0;\n              var largestComponentIndex = 0;\n              for (var _i6 = 0; _i6 < components.length; _i6++) {\n                if (components[_i6].length > largestComponentSize) {\n                  largestComponentSize = components[_i6].length;\n                  largestComponentIndex = _i6;\n                }\n              }\n              // if largest component isn't dominant, then take the votes for reflection\n              if (largestComponentSize < dagUndirected.size / 2) {\n                applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n                standardTransformation = false;\n                reflectionType = false;\n              } else {\n                // use largest component for transformation\n                // construct horizontal and vertical subgraphs in the largest component\n                var subGraphOnHorizontal = new Map();\n                var subGraphOnVertical = new Map();\n                var constraintsInlargestComponent = [];\n                components[largestComponentIndex].forEach(function (nodeId) {\n                  dag.get(nodeId).forEach(function (adjacent) {\n                    if (adjacent.direction == \"horizontal\") {\n                      if (subGraphOnHorizontal.has(nodeId)) {\n                        subGraphOnHorizontal.get(nodeId).push(adjacent);\n                      } else {\n                        subGraphOnHorizontal.set(nodeId, [adjacent]);\n                      }\n                      if (!subGraphOnHorizontal.has(adjacent.id)) {\n                        subGraphOnHorizontal.set(adjacent.id, []);\n                      }\n                      constraintsInlargestComponent.push({\n                        left: nodeId,\n                        right: adjacent.id\n                      });\n                    } else {\n                      if (subGraphOnVertical.has(nodeId)) {\n                        subGraphOnVertical.get(nodeId).push(adjacent);\n                      } else {\n                        subGraphOnVertical.set(nodeId, [adjacent]);\n                      }\n                      if (!subGraphOnVertical.has(adjacent.id)) {\n                        subGraphOnVertical.set(adjacent.id, []);\n                      }\n                      constraintsInlargestComponent.push({\n                        top: nodeId,\n                        bottom: adjacent.id\n                      });\n                    }\n                  });\n                });\n                applyReflectionForRelativePlacement(constraintsInlargestComponent);\n                reflectionType = false;\n\n                // calculate appropriate positioning for subgraphs\n                var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n                var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n\n                // construct source and target configuration\n                components[largestComponentIndex].forEach(function (nodeId, i) {\n                  sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n                  targetMatrix[i] = [];\n                  if (positionMapHorizontal.has(nodeId)) {\n                    targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n                  } else {\n                    targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n                  }\n                  if (positionMapVertical.has(nodeId)) {\n                    targetMatrix[i][1] = positionMapVertical.get(nodeId);\n                  } else {\n                    targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n                  }\n                });\n                standardTransformation = true;\n              }\n            }\n\n            // if transformation is required, then calculate and apply transformation matrix\n            if (standardTransformation) {\n              /* calculate transformation matrix */\n              var transformationMatrix = void 0;\n              var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'\n              var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'\n\n              // centralize transpose matrices\n              for (var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++) {\n                targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n                sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n              }\n\n              // do actual calculation for transformation matrix\n              var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B\n              var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V \n              transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'\n\n              /* apply found transformation matrix to obtain final draft layout */\n              for (var _i8 = 0; _i8 < nodeIndexes.size; _i8++) {\n                var temp1 = [xCoords[_i8], yCoords[_i8]];\n                var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];\n                var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];\n                xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n                yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n              }\n\n              // applied only both alignment and rel. placement constraints exist\n              if (reflectionType) {\n                applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n              }\n            }\n          }\n          if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n            /****  enforce constraints on the transformed draft layout ****/\n\n            /* first enforce fixed node constraint */\n\n            if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n              var translationAmount = {\n                x: 0,\n                y: 0\n              };\n              constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n                var posInTheory = {\n                  x: xCoords[nodeIndexes.get(nodeData.nodeId)],\n                  y: yCoords[nodeIndexes.get(nodeData.nodeId)]\n                };\n                var posDesired = nodeData.position;\n                var posDiff = calculatePositionDiff(posDesired, posInTheory);\n                translationAmount.x += posDiff.x;\n                translationAmount.y += posDiff.y;\n              });\n              translationAmount.x /= constraints.fixedNodeConstraint.length;\n              translationAmount.y /= constraints.fixedNodeConstraint.length;\n              xCoords.forEach(function (value, i) {\n                xCoords[i] += translationAmount.x;\n              });\n              yCoords.forEach(function (value, i) {\n                yCoords[i] += translationAmount.y;\n              });\n              constraints.fixedNodeConstraint.forEach(function (nodeData) {\n                xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n                yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n              });\n            }\n\n            /* then enforce alignment constraint */\n\n            if (constraints.alignmentConstraint) {\n              if (constraints.alignmentConstraint.vertical) {\n                var xAlign = constraints.alignmentConstraint.vertical;\n                var _loop4 = function _loop4(_i9) {\n                  var alignmentSet = new Set();\n                  xAlign[_i9].forEach(function (nodeId) {\n                    alignmentSet.add(nodeId);\n                  });\n                  var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                    return fixedNodes.has(x);\n                  }));\n                  var xPos = void 0;\n                  if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n                  alignmentSet.forEach(function (nodeId) {\n                    if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n                  });\n                };\n                for (var _i9 = 0; _i9 < xAlign.length; _i9++) {\n                  _loop4(_i9);\n                }\n              }\n              if (constraints.alignmentConstraint.horizontal) {\n                var yAlign = constraints.alignmentConstraint.horizontal;\n                var _loop5 = function _loop5(_i10) {\n                  var alignmentSet = new Set();\n                  yAlign[_i10].forEach(function (nodeId) {\n                    alignmentSet.add(nodeId);\n                  });\n                  var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                    return fixedNodes.has(x);\n                  }));\n                  var yPos = void 0;\n                  if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n                  alignmentSet.forEach(function (nodeId) {\n                    if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n                  });\n                };\n                for (var _i10 = 0; _i10 < yAlign.length; _i10++) {\n                  _loop5(_i10);\n                }\n              }\n            }\n\n            /* finally enforce relative placement constraint */\n\n            if (constraints.relativePlacementConstraint) {\n              (function () {\n                var nodeToDummyForVerticalAlignment = new Map();\n                var nodeToDummyForHorizontalAlignment = new Map();\n                var dummyToNodeForVerticalAlignment = new Map();\n                var dummyToNodeForHorizontalAlignment = new Map();\n                var dummyPositionsForVerticalAlignment = new Map();\n                var dummyPositionsForHorizontalAlignment = new Map();\n                var fixedNodesOnHorizontal = new Set();\n                var fixedNodesOnVertical = new Set();\n\n                // fill maps and sets      \n                fixedNodes.forEach(function (nodeId) {\n                  fixedNodesOnHorizontal.add(nodeId);\n                  fixedNodesOnVertical.add(nodeId);\n                });\n                if (constraints.alignmentConstraint) {\n                  if (constraints.alignmentConstraint.vertical) {\n                    var verticalAlignment = constraints.alignmentConstraint.vertical;\n                    var _loop6 = function _loop6(_i11) {\n                      dummyToNodeForVerticalAlignment.set(\"dummy\" + _i11, []);\n                      verticalAlignment[_i11].forEach(function (nodeId) {\n                        nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + _i11);\n                        dummyToNodeForVerticalAlignment.get(\"dummy\" + _i11).push(nodeId);\n                        if (fixedNodes.has(nodeId)) {\n                          fixedNodesOnHorizontal.add(\"dummy\" + _i11);\n                        }\n                      });\n                      dummyPositionsForVerticalAlignment.set(\"dummy\" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n                    };\n                    for (var _i11 = 0; _i11 < verticalAlignment.length; _i11++) {\n                      _loop6(_i11);\n                    }\n                  }\n                  if (constraints.alignmentConstraint.horizontal) {\n                    var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n                    var _loop7 = function _loop7(_i12) {\n                      dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i12, []);\n                      horizontalAlignment[_i12].forEach(function (nodeId) {\n                        nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + _i12);\n                        dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i12).push(nodeId);\n                        if (fixedNodes.has(nodeId)) {\n                          fixedNodesOnVertical.add(\"dummy\" + _i12);\n                        }\n                      });\n                      dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n                    };\n                    for (var _i12 = 0; _i12 < horizontalAlignment.length; _i12++) {\n                      _loop7(_i12);\n                    }\n                  }\n                }\n\n                // construct horizontal and vertical dags (subgraphs) from overall dag\n                var dagOnHorizontal = new Map();\n                var dagOnVertical = new Map();\n                var _loop8 = function _loop8(nodeId) {\n                  dag.get(nodeId).forEach(function (adjacent) {\n                    var sourceId = void 0;\n                    var targetNode = void 0;\n                    if (adjacent[\"direction\"] == \"horizontal\") {\n                      sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n                      if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                        targetNode = {\n                          id: nodeToDummyForVerticalAlignment.get(adjacent.id),\n                          gap: adjacent.gap,\n                          direction: adjacent.direction\n                        };\n                      } else {\n                        targetNode = adjacent;\n                      }\n                      if (dagOnHorizontal.has(sourceId)) {\n                        dagOnHorizontal.get(sourceId).push(targetNode);\n                      } else {\n                        dagOnHorizontal.set(sourceId, [targetNode]);\n                      }\n                      if (!dagOnHorizontal.has(targetNode.id)) {\n                        dagOnHorizontal.set(targetNode.id, []);\n                      }\n                    } else {\n                      sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n                      if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                        targetNode = {\n                          id: nodeToDummyForHorizontalAlignment.get(adjacent.id),\n                          gap: adjacent.gap,\n                          direction: adjacent.direction\n                        };\n                      } else {\n                        targetNode = adjacent;\n                      }\n                      if (dagOnVertical.has(sourceId)) {\n                        dagOnVertical.get(sourceId).push(targetNode);\n                      } else {\n                        dagOnVertical.set(sourceId, [targetNode]);\n                      }\n                      if (!dagOnVertical.has(targetNode.id)) {\n                        dagOnVertical.set(targetNode.id, []);\n                      }\n                    }\n                  });\n                };\n                var _iteratorNormalCompletion5 = true;\n                var _didIteratorError5 = false;\n                var _iteratorError5 = undefined;\n                try {\n                  for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var nodeId = _step5.value;\n                    _loop8(nodeId);\n                  }\n\n                  // find source nodes of each component in horizontal and vertical dags\n                } catch (err) {\n                  _didIteratorError5 = true;\n                  _iteratorError5 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                      _iterator5.return();\n                    }\n                  } finally {\n                    if (_didIteratorError5) {\n                      throw _iteratorError5;\n                    }\n                  }\n                }\n                var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n                var undirectedOnVertical = dagToUndirected(dagOnVertical);\n                var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n                var componentsOnVertical = findComponents(undirectedOnVertical);\n                var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n                var reversedDagOnVertical = dagToReversed(dagOnVertical);\n                var componentSourcesOnHorizontal = [];\n                var componentSourcesOnVertical = [];\n                componentsOnHorizontal.forEach(function (component, index) {\n                  componentSourcesOnHorizontal[index] = [];\n                  component.forEach(function (nodeId) {\n                    if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n                      componentSourcesOnHorizontal[index].push(nodeId);\n                    }\n                  });\n                });\n                componentsOnVertical.forEach(function (component, index) {\n                  componentSourcesOnVertical[index] = [];\n                  component.forEach(function (nodeId) {\n                    if (reversedDagOnVertical.get(nodeId).length == 0) {\n                      componentSourcesOnVertical[index].push(nodeId);\n                    }\n                  });\n                });\n\n                // calculate appropriate positioning for subgraphs\n                var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n                var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n\n                // update positions of the nodes based on relative placement constraints\n\n                var _loop9 = function _loop9(key) {\n                  if (dummyToNodeForVerticalAlignment.get(key)) {\n                    dummyToNodeForVerticalAlignment.get(key).forEach(function (nodeId) {\n                      xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n                    });\n                  } else {\n                    xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n                  }\n                };\n                var _iteratorNormalCompletion6 = true;\n                var _didIteratorError6 = false;\n                var _iteratorError6 = undefined;\n                try {\n                  for (var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var key = _step6.value;\n                    _loop9(key);\n                  }\n                } catch (err) {\n                  _didIteratorError6 = true;\n                  _iteratorError6 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                      _iterator6.return();\n                    }\n                  } finally {\n                    if (_didIteratorError6) {\n                      throw _iteratorError6;\n                    }\n                  }\n                }\n                var _loop10 = function _loop10(key) {\n                  if (dummyToNodeForHorizontalAlignment.get(key)) {\n                    dummyToNodeForHorizontalAlignment.get(key).forEach(function (nodeId) {\n                      yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n                    });\n                  } else {\n                    yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n                  }\n                };\n                var _iteratorNormalCompletion7 = true;\n                var _didIteratorError7 = false;\n                var _iteratorError7 = undefined;\n                try {\n                  for (var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                    var key = _step7.value;\n                    _loop10(key);\n                  }\n                } catch (err) {\n                  _didIteratorError7 = true;\n                  _iteratorError7 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                      _iterator7.return();\n                    }\n                  } finally {\n                    if (_didIteratorError7) {\n                      throw _iteratorError7;\n                    }\n                  }\n                }\n              })();\n            }\n          }\n\n          // assign new coordinates to nodes after constraint handling\n          for (var _i13 = 0; _i13 < allNodes.length; _i13++) {\n            var _node = allNodes[_i13];\n            if (_node.getChild() == null) {\n              _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n            }\n          }\n        };\n        module.exports = ConstraintHandler;\n\n        /***/\n      }),\n      /***/551: (/***/module => {\n        module.exports = __WEBPACK_EXTERNAL_MODULE__551__;\n\n        /***/\n      })\n\n      /******/\n    };\n    /************************************************************************/\n    /******/ // The module cache\n    /******/\n    var __webpack_module_cache__ = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId) {\n      /******/ // Check if module is in cache\n      /******/var cachedModule = __webpack_module_cache__[moduleId];\n      /******/\n      if (cachedModule !== undefined) {\n        /******/return cachedModule.exports;\n        /******/\n      }\n      /******/ // Create a new module (and put it into the cache)\n      /******/\n      var module = __webpack_module_cache__[moduleId] = {\n        /******/ // no module.id needed\n        /******/ // no module.loaded needed\n        /******/exports: {}\n        /******/\n      };\n      /******/\n      /******/ // Execute the module function\n      /******/\n      __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n      /******/\n      /******/ // Return the exports of the module\n      /******/\n      return module.exports;\n      /******/\n    }\n    /******/\n    /************************************************************************/\n    /******/\n    /******/ // startup\n    /******/ // Load entry module and return exports\n    /******/ // This entry module is referenced by other modules so it can't be inlined\n    /******/\n    var __webpack_exports__ = __webpack_require__(45);\n    /******/\n    /******/\n    return __webpack_exports__;\n    /******/\n  })();\n});","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","__WEBPACK_EXTERNAL_MODULE__551__","__webpack_modules__","__unused_webpack_exports","__webpack_require__","coseBase","layoutBase","CoSEConstants","CoSEEdge","CoSEGraph","CoSEGraphManager","CoSELayout","CoSENode","ConstraintHandler","FDLayoutConstants","prop","DEFAULT_USE_MULTI_LEVEL_SCALING","DEFAULT_RADIAL_SEPARATION","DEFAULT_EDGE_LENGTH","DEFAULT_COMPONENT_SEPERATION","TILE","TILING_PADDING_VERTICAL","TILING_PADDING_HORIZONTAL","TRANSFORM_ON_CONSTRAINT_HANDLING","ENFORCE_CONSTRAINTS","APPLY_LAYOUT","RELAX_MOVEMENT_ON_CONSTRAINTS","TREE_REDUCTION_ON_INCREMENTAL","PURE_INCREMENTAL","DEFAULT_INCREMENTAL","FDLayoutEdge","source","target","vEdge","call","prototype","Object","create","LGraph","parent","graphMgr","vGraph","LGraphManager","layout","FDLayout","LayoutConstants","Point","PointD","DimensionD","Layout","Integer","IGeometry","Transform","LinkedList","toBeTiled","constraints","newGraphManager","gm","graphManager","newGraph","newNode","vNode","newEdge","initParameters","arguments","isSubLayout","idealEdgeLength","useSmartIdealEdgeLengthCalculation","DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION","gravityConstant","DEFAULT_GRAVITY_STRENGTH","compoundGravityConstant","DEFAULT_COMPOUND_GRAVITY_STRENGTH","gravityRangeFactor","DEFAULT_GRAVITY_RANGE_FACTOR","compoundGravityRangeFactor","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","prunedNodesAll","growTreeIterations","afterGrowthIterations","isTreeGrowing","isGrowthFinished","initSpringEmbedder","coolingCycle","maxCoolingCycle","maxIterations","CONVERGENCE_CHECK_PERIOD","finalTemperature","coolingAdjuster","createBendsAsNeeded","DEFAULT_CREATE_BENDS_AS_NEEDED","createBendpoints","resetAllEdges","level","classicLayout","nodesWithGravity","calculateNodesToApplyGravitationTo","setAllNodesToApplyGravitation","calcNoOfChildrenForAllNodes","calcLowestCommonAncestors","calcInclusionTreeDepths","getRoot","calcEstimatedSize","calcIdealEdgeLengths","incremental","forest","getFlatForest","length","positionNodesRadially","reduceTrees","resetAllNodesToApplyGravitation","allNodes","Set","getAllNodes","intersection","filter","x","has","positionNodesRandomly","keys","handleConstraints","initConstraintVariables","runSpringEmbedder","tick","totalIterations","isConverged","layoutQuality","coolingFactor","Math","max","initialCoolingFactor","pow","log","animationPeriod","ceil","initialAnimationPeriod","sqrt","updateBounds","updateGrid","growTree","DEFAULT_COOLING_FACTOR_INCREMENTAL","gridUpdateAllowed","forceToNodeSurroundingUpdate","totalDisplacement","calcSpringForces","calcRepulsionForces","calcGravitationalForces","moveNodes","animate","getPositionsData","pData","i","rect","id","getCenterX","y","getCenterY","w","width","h","height","layoutEnded","ANIMATE","emit","lNodes","node","calculateDisplacement","updateDisplacements","move","self","idToNodeMap","Map","fixedNodeSet","set","calculateCompoundWeight","compoundNode","nodes","getChild","getNodes","fixedNodeWeight","fixedNodeConstraint","forEach","nodeData","add","nodeId","relativePlacementConstraint","nodeToDummyForVerticalAlignment","nodeToDummyForHorizontalAlignment","dummyToNodeForVerticalAlignment","dummyToNodeForHorizontalAlignment","fixedNodesOnHorizontal","fixedNodesOnVertical","alignmentConstraint","vertical","verticalAlignment","get","push","horizontal","horizontalAlignment","shuffle","array","j","floor","random","nodesInRelativeHorizontal","nodesInRelativeVertical","nodeToRelativeConstraintMapHorizontal","nodeToRelativeConstraintMapVertical","nodeToTempPositionMapHorizontal","nodeToTempPositionMapVertical","constraint","left","nodeIdLeft","nodeIdRight","right","includes","gap","nodeIdTop","top","nodeIdBottom","bottom","subGraphOnHorizontal","subGraphOnVertical","constructComponents","graph","fixedNodes","components","isFixed","queue","visited","count","value","key","currentNode","shift","neighbors","neighbor","resultOnHorizontal","componentsOnHorizontal","fixedComponentsOnHorizontal","resultOnVertical","componentsOnVertical","fixedComponentsOnVertical","fixedNode","displacementX","displacementY","allVerticalAlignments","totalDisplacementX","averageDisplacementX","allHorizontalAlignments","totalDisplacementY","averageDisplacementY","displacement","diff","component","sum","actualNodes","averageDisplacement","nodeList","graphs","getGraphs","size","updateConnected","isConnected","concat","edges","getAllEdges","edge","getSource","getTarget","getBendpoints","createDummyNodesForBendpoints","edgeList","getEdgeListToNode","k","multiEdge","currentStartingPoint","numberOfColumns","currentY","currentX","point","tree","centerNode","findCenterOfTree","radialLayout","transform","WORLD_CENTER_X","WORLD_CENTER_Y","startingPoint","radialSep","maxDiagonalInTree","branchRadialLayout","bounds","calculateBounds","setDeviceOrgX","getMinX","setDeviceOrgY","getMinY","setWorldOrgX","setWorldOrgY","bottomRight","getMaxX","getMaxY","inverseTransformPoint","parentOfNode","startAngle","endAngle","distance","radialSeparation","halfInterval","nodeAngle","teta","TWO_PI","cos_teta","cos","x_","y_","sin","setCenter","neighborEdges","getEdges","childCount","branchCount","incEdgesCount","startIndex","getEdgesBetween","temp","splice","index","indexOf","stepAngle","abs","currentNeighbor","getOtherEnd","childStartAngle","childEndAngle","maxDiagonal","MIN_VALUE","diagonal","getDiagonal","calcRepulsionRange","groupZeroDegreeMembers","tempMemberGroups","memberGroups","idToDummyNode","zeroDegree","getParent","getNodeDegreeWithChildren","undefined","getToBeTiled","p_id","dummyCompoundId","dummyCompound","paddingLeft","paddingRight","paddingBottom","paddingTop","dummyParentGraph","getGraphManager","parentGraph","remove","clearCompounds","childGraphMap","idToNode","performDFSOnCompounds","compoundOrder","child","resetAllNodes","tileCompoundMembers","clearZeroDegreeMembers","tiledZeroDegreePack","tileNodes","centerX","centerY","labelMarginLeft","labelMarginTop","NODE_DIMENSIONS_INCLUDE_LABELS","labelWidth","labelPosHorizontal","setWidth","labelHeight","labelPosVertical","setHeight","repopulateCompounds","lCompoundNode","horizontalMargin","verticalMargin","adjustLocations","tiledMemberPack","repopulateZeroDegreeMembers","tiledPack","childGraph","children","theChild","getNodeDegree","degree","fillCompexOrderByDFS","organization","compoundHorizontalMargin","compoundVerticalMargin","compoundLabelMarginLeft","compoundLabelMarginTop","rows","row","maxHeight","lnode","horizontalPadding","verticalPadding","minWidth","horizontalOrg","tileNodesByFavoringDim","verticalOrg","horizontalRatio","getOrgRatio","verticalRatio","bestOrg","ratio","calcIdealRowWidth","members","favorHorizontalDim","membersSize","totalWidth","totalHeight","maxWidth","getWidth","getHeight","averageWidth","averageHeight","delta","horizontalCountDouble","horizontalCount","idealWidth","tilingCompareBy","TILING_COMPARE_BY","rowWidth","rowHeight","idealRowWidth","getNodeArea","n","areaCompareFcn","n1","n2","sort","cmpBy","sumCenterX","sumCenterY","lNode","insertNodeToRow","canAddHorizontal","rowIndex","getShortestRowIndex","shiftToLastRow","minCompoundSize","secondDimension","extraHeight","r","min","Number","MAX_VALUE","getLongestRowIndex","extraWidth","lastRowIndex","lastRowWidth","sri","hDiff","add_to_row_ratio","add_new_row_ratio","longest","last","instance","prevTotal","finalTotal","tilingPreLayout","tilingPostLayout","containsLeaf","prunedNodesInStepTemp","isInterGraph","otherEnd","relativePosition","getOwner","prunedNodesInStep","lengthOfPrunedNodesInStep","findPlaceforPrunedNode","gridForPrunedNode","nodeToConnect","prunedNode","startGridX","startX","finishGridX","finishX","startGridY","startY","finishGridY","finishY","upNodeCount","downNodeCount","rightNodeCount","leftNodeCount","controlRegions","grid","minCount","minIndex","FDLayoutNode","IMath","loc","getLayout","springForceX","repulsionForceX","gravitationForceX","springForceY","repulsionForceY","gravitationForceY","noOfChildren","maxNodeDisplacement","sign","propogateDisplacementToChildren","dX","dY","moveBy","setPred1","pred1","getPred1","getPred2","pred2","setNext","next","getNext","setProcessed","processed","isProcessed","_toConsumableArray","arr","Array","isArray","arr2","from","Matrix","SVD","nodeIndexes","xCoords","yCoords","calculatePositionDiff","pos1","pos2","calculateAvgPosition","nodeIdSet","xPosSum","yPosSum","findAppropriatePositionForRelativePlacement","direction","dummyPositions","componentSources","setUnion","setA","setB","union","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","done","elem","err","return","inDegrees","adjacent","positionMap","pastMap","NEGATIVE_INFINITY","fixedIds","position","fixedId","_position","_loop","fixedPosition","sinkNodes","_components","isFixedComponent","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","isExist","existAt","ele","minBefore","POSITIVE_INFINITY","minAfter","maxBefore","maxAfter","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","posBefore","posAfter","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_nodeId","applyReflectionForRelativePlacement","relativePlacementConstraints","reflectOnY","notReflectOnY","reflectOnX","notReflectOnX","_i","_i2","_i3","findComponents","_currentNode","dagToUndirected","dag","undirected","dagToReversed","reversed","targetMatrix","sourceMatrix","standardTransformation","reflectionType","dagUndirected","verticalAlign","_loop2","_i4","alignmentSet","xPos","values","horizontalAlign","_loop3","_i5","yPos","largestComponentSize","largestComponentIndex","_i6","constraintsInlargestComponent","positionMapHorizontal","positionMapVertical","transformationMatrix","targetMatrixTranspose","transpose","sourceMatrixTranspose","_i7","multGamma","tempMatrix","multMat","SVDResult","svd","V","U","_i8","temp1","temp2","temp3","dotProduct","translationAmount","posInTheory","posDesired","posDiff","xAlign","_loop4","_i9","yAlign","_loop5","_i10","dummyPositionsForVerticalAlignment","dummyPositionsForHorizontalAlignment","_loop6","_i11","_loop7","_i12","dagOnHorizontal","dagOnVertical","_loop8","sourceId","targetNode","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","undirectedOnHorizontal","undirectedOnVertical","reversedDagOnHorizontal","reversedDagOnVertical","componentSourcesOnHorizontal","componentSourcesOnVertical","_loop9","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_loop10","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","_step7","_i13","_node","__webpack_module_cache__","moduleId","cachedModule","__webpack_exports__"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"layout-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"layout-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"coseBase\"] = factory(require(\"layout-base\"));\n\telse\n\t\troot[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__551__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 45:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __webpack_require__(551);\ncoseBase.CoSEConstants = __webpack_require__(806);\ncoseBase.CoSEEdge = __webpack_require__(767);\ncoseBase.CoSEGraph = __webpack_require__(880);\ncoseBase.CoSEGraphManager = __webpack_require__(578);\ncoseBase.CoSELayout = __webpack_require__(765);\ncoseBase.CoSENode = __webpack_require__(991);\ncoseBase.ConstraintHandler = __webpack_require__(902);\n\nmodule.exports = coseBase;\n\n/***/ }),\n\n/***/ 806:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar FDLayoutConstants = __webpack_require__(551).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\nCoSEConstants.ENFORCE_CONSTRAINTS = true;\nCoSEConstants.APPLY_LAYOUT = true;\nCoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n// This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n// an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\nCoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n\n/***/ 767:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar FDLayoutEdge = __webpack_require__(551).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n\n/***/ 880:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar LGraph = __webpack_require__(551).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n\n/***/ 578:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar LGraphManager = __webpack_require__(551).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n\n/***/ 765:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar FDLayout = __webpack_require__(551).FDLayout;\nvar CoSEGraphManager = __webpack_require__(578);\nvar CoSEGraph = __webpack_require__(880);\nvar CoSENode = __webpack_require__(991);\nvar CoSEEdge = __webpack_require__(767);\nvar CoSEConstants = __webpack_require__(806);\nvar ConstraintHandler = __webpack_require__(902);\nvar FDLayoutConstants = __webpack_require__(551).FDLayoutConstants;\nvar LayoutConstants = __webpack_require__(551).LayoutConstants;\nvar Point = __webpack_require__(551).Point;\nvar PointD = __webpack_require__(551).PointD;\nvar DimensionD = __webpack_require__(551).DimensionD;\nvar Layout = __webpack_require__(551).Layout;\nvar Integer = __webpack_require__(551).Integer;\nvar IGeometry = __webpack_require__(551).IGeometry;\nvar LGraph = __webpack_require__(551).LGraph;\nvar Transform = __webpack_require__(551).Transform;\nvar LinkedList = __webpack_require__(551).LinkedList;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n  this.constraints = {}; // keep layout constraints\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n  }\n};\n\n// This method is used to set CoSE related parameters used by spring embedder.\nCoSELayout.prototype.initSpringEmbedder = function () {\n  FDLayout.prototype.initSpringEmbedder.call(this);\n\n  // variables for cooling\n  this.coolingCycle = 0;\n  this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n  this.finalTemperature = 0.04;\n  this.coolingAdjuster = 1;\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    ConstraintHandler.handleConstraints(this);\n    this.initConstraintVariables();\n  }\n\n  this.initSpringEmbedder();\n  if (CoSEConstants.APPLY_LAYOUT) {\n    this.runSpringEmbedder();\n  }\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\n// overrides moveNodes method in FDLayout\nCoSELayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  // calculate displacement for each node \n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.calculateDisplacement();\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    this.updateDisplacements();\n  }\n\n  // move each node\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\n// constraint related methods: initConstraintVariables and updateDisplacements\n\n// initialize constraint related variables\nCoSELayout.prototype.initConstraintVariables = function () {\n  var self = this;\n  this.idToNodeMap = new Map();\n  this.fixedNodeSet = new Set();\n\n  var allNodes = this.graphManager.getAllNodes();\n\n  // fill idToNodeMap\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    this.idToNodeMap.set(node.id, node);\n  }\n\n  // calculate fixed node weight for given compound node\n  var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n    var nodes = compoundNode.getChild().getNodes();\n    var node;\n    var fixedNodeWeight = 0;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      if (node.getChild() == null) {\n        if (self.fixedNodeSet.has(node.id)) {\n          fixedNodeWeight += 100;\n        }\n      } else {\n        fixedNodeWeight += calculateCompoundWeight(node);\n      }\n    }\n    return fixedNodeWeight;\n  };\n\n  if (this.constraints.fixedNodeConstraint) {\n    // fill fixedNodeSet\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      self.fixedNodeSet.add(nodeData.nodeId);\n    });\n\n    // assign fixed node weights to compounds if they contain fixed nodes\n    var allNodes = this.graphManager.getAllNodes();\n    var node;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getChild() != null) {\n        var fixedNodeWeight = calculateCompoundWeight(node);\n        if (fixedNodeWeight > 0) {\n          node.fixedNodeWeight = fixedNodeWeight;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n    var nodeToDummyForVerticalAlignment = new Map();\n    var nodeToDummyForHorizontalAlignment = new Map();\n    this.dummyToNodeForVerticalAlignment = new Map();\n    this.dummyToNodeForHorizontalAlignment = new Map();\n    this.fixedNodesOnHorizontal = new Set();\n    this.fixedNodesOnVertical = new Set();\n\n    // fill maps and sets\n    this.fixedNodeSet.forEach(function (nodeId) {\n      self.fixedNodesOnHorizontal.add(nodeId);\n      self.fixedNodesOnVertical.add(nodeId);\n    });\n\n    if (this.constraints.alignmentConstraint) {\n      if (this.constraints.alignmentConstraint.vertical) {\n        var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n        for (var i = 0; i < verticalAlignment.length; i++) {\n          this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n          verticalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n      if (this.constraints.alignmentConstraint.horizontal) {\n        var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n        for (var i = 0; i < horizontalAlignment.length; i++) {\n          this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n          horizontalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnVertical.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n    }\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n\n      this.shuffle = function (array) {\n        var j, x, i;\n        for (i = array.length - 1; i >= 2 * array.length / 3; i--) {\n          j = Math.floor(Math.random() * (i + 1));\n          x = array[i];\n          array[i] = array[j];\n          array[j] = x;\n        }\n        return array;\n      };\n\n      this.nodesInRelativeHorizontal = [];\n      this.nodesInRelativeVertical = [];\n      this.nodeToRelativeConstraintMapHorizontal = new Map();\n      this.nodeToRelativeConstraintMapVertical = new Map();\n      this.nodeToTempPositionMapHorizontal = new Map();\n      this.nodeToTempPositionMapVertical = new Map();\n\n      // fill arrays and maps\n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n            self.nodesInRelativeHorizontal.push(nodeIdLeft);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n            }\n          }\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n            self.nodesInRelativeHorizontal.push(nodeIdRight);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n            }\n          }\n\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({ right: nodeIdRight, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({ left: nodeIdLeft, gap: constraint.gap });\n        } else {\n          var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n\n          if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n            self.nodesInRelativeVertical.push(nodeIdTop);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n            }\n          }\n          if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n            self.nodesInRelativeVertical.push(nodeIdBottom);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n            }\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({ bottom: nodeIdBottom, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({ top: nodeIdTop, gap: constraint.gap });\n        }\n      });\n    } else {\n      var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n      var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n\n      // construct subgraphs from relative placement constraints \n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n          if (subGraphOnHorizontal.has(left)) {\n            subGraphOnHorizontal.get(left).push(right);\n          } else {\n            subGraphOnHorizontal.set(left, [right]);\n          }\n          if (subGraphOnHorizontal.has(right)) {\n            subGraphOnHorizontal.get(right).push(left);\n          } else {\n            subGraphOnHorizontal.set(right, [left]);\n          }\n        } else {\n          var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n          if (subGraphOnVertical.has(top)) {\n            subGraphOnVertical.get(top).push(bottom);\n          } else {\n            subGraphOnVertical.set(top, [bottom]);\n          }\n          if (subGraphOnVertical.has(bottom)) {\n            subGraphOnVertical.get(bottom).push(top);\n          } else {\n            subGraphOnVertical.set(bottom, [top]);\n          }\n        }\n      });\n\n      // function to construct components from a given graph \n      // also returns an array that keeps whether each component contains fixed node\n      var constructComponents = function constructComponents(graph, fixedNodes) {\n        var components = [];\n        var isFixed = [];\n        var queue = new LinkedList();\n        var visited = new Set();\n        var count = 0;\n\n        graph.forEach(function (value, key) {\n          if (!visited.has(key)) {\n            components[count] = [];\n            isFixed[count] = false;\n            var currentNode = key;\n            queue.push(currentNode);\n            visited.add(currentNode);\n            components[count].push(currentNode);\n\n            while (queue.length != 0) {\n              currentNode = queue.shift();\n              if (fixedNodes.has(currentNode)) {\n                isFixed[count] = true;\n              }\n              var neighbors = graph.get(currentNode);\n              neighbors.forEach(function (neighbor) {\n                if (!visited.has(neighbor)) {\n                  queue.push(neighbor);\n                  visited.add(neighbor);\n                  components[count].push(neighbor);\n                }\n              });\n            }\n            count++;\n          }\n        });\n\n        return { components: components, isFixed: isFixed };\n      };\n\n      var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n      this.componentsOnHorizontal = resultOnHorizontal.components;\n      this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n      var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n      this.componentsOnVertical = resultOnVertical.components;\n      this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n    }\n  }\n};\n\n// updates node displacements based on constraints\nCoSELayout.prototype.updateDisplacements = function () {\n  var self = this;\n  if (this.constraints.fixedNodeConstraint) {\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n      fixedNode.displacementX = 0;\n      fixedNode.displacementY = 0;\n    });\n  }\n\n  if (this.constraints.alignmentConstraint) {\n    if (this.constraints.alignmentConstraint.vertical) {\n      var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n      for (var i = 0; i < allVerticalAlignments.length; i++) {\n        var totalDisplacementX = 0;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n            totalDisplacementX = 0;\n            break;\n          }\n          totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n        }\n        var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n        }\n      }\n    }\n    if (this.constraints.alignmentConstraint.horizontal) {\n      var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n      for (var i = 0; i < allHorizontalAlignments.length; i++) {\n        var totalDisplacementY = 0;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n            totalDisplacementY = 0;\n            break;\n          }\n          totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n        }\n        var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n      // shuffle array to randomize node processing order\n      if (this.totalIterations % 10 == 0) {\n        this.shuffle(this.nodesInRelativeHorizontal);\n        this.shuffle(this.nodesInRelativeVertical);\n      }\n\n      this.nodesInRelativeHorizontal.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementX;\n          }\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function (constraint) {\n            if (constraint.right) {\n              var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementX = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementX = displacement;\n          }\n        }\n      });\n\n      this.nodesInRelativeVertical.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementY;\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function (constraint) {\n            if (constraint.bottom) {\n              var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementY = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementY = displacement;\n          }\n        }\n      });\n    } else {\n      for (var i = 0; i < this.componentsOnHorizontal.length; i++) {\n        var component = this.componentsOnHorizontal[i];\n        if (this.fixedComponentsOnHorizontal[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementX;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < this.componentsOnVertical.length; i++) {\n        var component = this.componentsOnVertical[i];\n        if (this.fixedComponentsOnVertical[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementY;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n    compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n    var labelMarginLeft = lCompoundNode.labelMarginLeft;\n    var labelMarginTop = lCompoundNode.labelMarginTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n    var labelMarginLeft = compoundNode.labelMarginLeft;\n    var labelMarginTop = compoundNode.labelMarginTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n  x += compoundHorizontalMargin + compoundLabelMarginLeft;\n  y += compoundVerticalMargin + compoundLabelMarginTop;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n    compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);\n  var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);\n\n  var horizontalRatio = this.getOrgRatio(horizontalOrg);\n  var verticalRatio = this.getOrgRatio(verticalOrg);\n  var bestOrg;\n\n  // the best ratio is the one that is closer to 1 since the ratios are already normalized\n  // and the best organization is the one that has the best ratio\n  if (verticalRatio < horizontalRatio) {\n    bestOrg = verticalOrg;\n  } else {\n    bestOrg = horizontalOrg;\n  }\n\n  return bestOrg;\n};\n\n// get the width/height ratio of the organization that is normalized so that it will not be less than 1\nCoSELayout.prototype.getOrgRatio = function (organization) {\n  // get dimensions and calculate the initial ratio\n  var width = organization.width;\n  var height = organization.height;\n  var ratio = width / height;\n\n  // if the initial ratio is less then 1 then inverse it\n  if (ratio < 1) {\n    ratio = 1 / ratio;\n  }\n\n  // return the normalized ratio\n  return ratio;\n};\n\n/*\n * Calculates the ideal width for the rows. This method assumes that\n * each node has the same sizes and calculates the ideal row width that\n * approximates a square shaped complex accordingly. However, since nodes would\n * have different sizes some rows would have different sizes and the resulting\n * shape would not be an exact square.\n */\nCoSELayout.prototype.calcIdealRowWidth = function (members, favorHorizontalDim) {\n  // To approximate a square shaped complex we need to make complex width equal to complex height.\n  // To achieve this we need to solve the following equation system for hc:\n  // (x + bx) * hc - bx = (y + by) * vc - by, hc * vc = n\n  // where x is the avarage width of the nodes, y is the avarage height of nodes\n  // bx and by are the buffer sizes in horizontal and vertical dimensions accordingly,\n  // hc and vc are the number of rows in horizontal and vertical dimensions\n  // n is number of members.\n\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n\n  // number of members\n  var membersSize = members.length;\n\n  // sum of the width of all members\n  var totalWidth = 0;\n\n  // sum of the height of all members\n  var totalHeight = 0;\n\n  var maxWidth = 0;\n\n  // traverse all members to calculate total width and total height and get the maximum members width\n  members.forEach(function (node) {\n    totalWidth += node.getWidth();\n    totalHeight += node.getHeight();\n\n    if (node.getWidth() > maxWidth) {\n      maxWidth = node.getWidth();\n    }\n  });\n\n  // average width of the members\n  var averageWidth = totalWidth / membersSize;\n\n  // average height of the members\n  var averageHeight = totalHeight / membersSize;\n\n  // solving the initial equation system for the hc yields the following second degree equation:\n  // hc^2 * (x+bx) + hc * (by - bx) - n * (y + by) = 0\n\n  // the delta value to solve the equation above for hc\n  var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;\n\n  // solve the equation using delta value to calculate the horizontal count\n  // that represents the number of nodes in an ideal row\n  var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));\n  // round the calculated horizontal count up or down according to the favored dimension\n  var horizontalCount;\n\n  if (favorHorizontalDim) {\n    horizontalCount = Math.ceil(horizontalCountDouble);\n    // if horizontalCount count is not a float value then both of rounding to floor and ceil\n    // will yield the same values. Instead of repeating the same calculation try going up\n    // while favoring horizontal dimension in such cases\n    if (horizontalCount == horizontalCountDouble) {\n      horizontalCount++;\n    }\n  } else {\n    horizontalCount = Math.floor(horizontalCountDouble);\n  }\n\n  // ideal width to be calculated\n  var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;\n\n  // if max width is bigger than calculated ideal width reset ideal width to it\n  if (maxWidth > idealWidth) {\n    idealWidth = maxWidth;\n  }\n\n  // add the left-right margins to the ideal row width\n  idealWidth += horizontalPadding * 2;\n\n  // return the ideal row width1\n  return idealWidth;\n};\n\nCoSELayout.prototype.tileNodesByFavoringDim = function (nodes, minWidth, favorHorizontalDim) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding,\n    centerX: 0,\n    centerY: 0\n  };\n\n  if (tilingCompareBy) {\n    organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);\n  }\n\n  var getNodeArea = function getNodeArea(n) {\n    return n.rect.width * n.rect.height;\n  };\n\n  var areaCompareFcn = function areaCompareFcn(n1, n2) {\n    return getNodeArea(n2) - getNodeArea(n1);\n  };\n\n  // Sort the nodes in descending order of their areas\n  nodes.sort(function (n1, n2) {\n    var cmpBy = areaCompareFcn;\n    if (organization.idealRowWidth) {\n      cmpBy = tilingCompareBy;\n      return cmpBy(n1.id, n2.id);\n    }\n    return cmpBy(n1, n2);\n  });\n\n  // Create the organization -> calculate compound center\n  var sumCenterX = 0;\n  var sumCenterY = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    sumCenterX += lNode.getCenterX();\n    sumCenterY += lNode.getCenterY();\n  }\n\n  organization.centerX = sumCenterX / nodes.length;\n  organization.centerY = sumCenterY / nodes.length;\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      var rowIndex = organization.rows.length - 1;\n      if (!organization.idealRowWidth) {\n        rowIndex = this.getShortestRowIndex(organization);\n      }\n      this.insertNodeToRow(organization, lNode, rowIndex, minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  // if there is an ideal row width specified use it instead of checking the aspect ratio\n  if (organization.idealRowWidth) {\n    var lastRowIndex = organization.rows.length - 1;\n    var lastRowWidth = organization.rowWidth[lastRowIndex];\n\n    // check and return if ideal row width will be exceed if the node is added to the row\n    return lastRowWidth + extraWidth + organization.horizontalPadding <= organization.idealRowWidth;\n  }\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        if (CoSEConstants.PURE_INCREMENTAL) {\n          var otherEnd = node.getEdges()[0].getOtherEnd(node);\n          var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);\n        } else {\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        }\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n\n  if (CoSEConstants.PURE_INCREMENTAL) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n  } else {\n    var startGridX = nodeToConnect.startX;\n    var finishGridX = nodeToConnect.finishX;\n    var startGridY = nodeToConnect.startY;\n    var finishGridY = nodeToConnect.finishY;\n\n    var upNodeCount = 0;\n    var downNodeCount = 0;\n    var rightNodeCount = 0;\n    var leftNodeCount = 0;\n    var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n    if (startGridY > 0) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n      }\n    }\n    if (finishGridX < this.grid.length - 1) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n      }\n    }\n    if (finishGridY < this.grid[0].length - 1) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n      }\n    }\n    if (startGridX > 0) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n      }\n    }\n    var min = Integer.MAX_VALUE;\n    var minCount;\n    var minIndex;\n    for (var j = 0; j < controlRegions.length; j++) {\n      if (controlRegions[j] < min) {\n        min = controlRegions[j];\n        minCount = 1;\n        minIndex = j;\n      } else if (controlRegions[j] == min) {\n        minCount++;\n      }\n    }\n\n    if (minCount == 3 && min == 0) {\n      if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n        gridForPrunedNode = 1;\n      } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 0;\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 3;\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 2;\n      }\n    } else if (minCount == 2 && min == 0) {\n      var random = Math.floor(Math.random() * 2);\n      if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n        ;\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 1;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else {\n        if (random == 0) {\n          gridForPrunedNode = 2;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      }\n    } else if (minCount == 4 && min == 0) {\n      var random = Math.floor(Math.random() * 4);\n      gridForPrunedNode = random;\n    } else {\n      gridForPrunedNode = minIndex;\n    }\n\n    if (gridForPrunedNode == 0) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n    } else if (gridForPrunedNode == 1) {\n      prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    } else if (gridForPrunedNode == 2) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n    } else {\n      prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    }\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n\n/***/ 991:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar FDLayoutNode = __webpack_require__(551).FDLayoutNode;\nvar IMath = __webpack_require__(551).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.calculateDisplacement = function () {\n  var layout = this.graphManager.getLayout();\n  // this check is for compound nodes that contain fixed nodes\n  if (this.getChild() != null && this.fixedNodeWeight) {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n  } else {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n  }\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // non-empty compound node, propogate movement to children as well\n  if (this.child && this.child.getNodes().length > 0) {\n    this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n  }\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n\n  // a simple node or an empty compound node, move it\n  if (this.child == null || this.child.getNodes().length == 0) {\n    this.moveBy(this.displacementX, this.displacementY);\n\n    layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n  }\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n\n/***/ 902:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar CoSEConstants = __webpack_require__(806);\nvar LinkedList = __webpack_require__(551).LinkedList;\nvar Matrix = __webpack_require__(551).Matrix;\nvar SVD = __webpack_require__(551).SVD;\n\nfunction ConstraintHandler() {}\n\nConstraintHandler.handleConstraints = function (layout) {\n  //  let layout = this.graphManager.getLayout();\n\n  // get constraints from layout\n  var constraints = {};\n  constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n  constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n  constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n\n  var idToNodeMap = new Map();\n  var nodeIndexes = new Map();\n  var xCoords = [];\n  var yCoords = [];\n\n  var allNodes = layout.getAllNodes();\n  var index = 0;\n  // fill index map and coordinates\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    if (node.getChild() == null) {\n      nodeIndexes.set(node.id, index++);\n      xCoords.push(node.getCenterX());\n      yCoords.push(node.getCenterY());\n      idToNodeMap.set(node.id, node);\n    }\n  }\n\n  // if there exists relative placement constraint without gap value, set it to default \n  if (constraints.relativePlacementConstraint) {\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (!constraint.gap && constraint.gap != 0) {\n        if (constraint.left) {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n        } else {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n        }\n      }\n    });\n  }\n\n  /* auxiliary functions */\n\n  // calculate difference between two position objects\n  var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n    return { x: pos1.x - pos2.x, y: pos1.y - pos2.y };\n  };\n\n  // calculate average position of the nodes\n  var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n    var xPosSum = 0;\n    var yPosSum = 0;\n    nodeIdSet.forEach(function (nodeId) {\n      xPosSum += xCoords[nodeIndexes.get(nodeId)];\n      yPosSum += yCoords[nodeIndexes.get(nodeId)];\n    });\n\n    return { x: xPosSum / nodeIdSet.size, y: yPosSum / nodeIdSet.size };\n  };\n\n  // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n  // this function also takes the fixed nodes and alignment constraints into account\n  // graph: dag to be evaluated, direction: \"horizontal\" or \"vertical\", \n  // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n  var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n\n    // find union of two sets\n    function setUnion(setA, setB) {\n      var union = new Set(setA);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var elem = _step.value;\n\n          union.add(elem);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return union;\n    }\n\n    // find indegree count for each node\n    var inDegrees = new Map();\n\n    graph.forEach(function (value, key) {\n      inDegrees.set(key, 0);\n    });\n    graph.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n      });\n    });\n\n    var positionMap = new Map(); // keeps the position for each node\n    var pastMap = new Map(); // keeps the predecessors(past) of a node\n    var queue = new LinkedList();\n    inDegrees.forEach(function (value, key) {\n      if (value == 0) {\n        queue.push(key);\n        if (!fixedNodes) {\n          if (direction == \"horizontal\") {\n            positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          } else {\n            positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          }\n        }\n      } else {\n        positionMap.set(key, Number.NEGATIVE_INFINITY);\n      }\n      if (fixedNodes) {\n        pastMap.set(key, new Set([key]));\n      }\n    });\n\n    // align sources of each component in enforcement phase\n    if (fixedNodes) {\n      componentSources.forEach(function (component) {\n        var fixedIds = [];\n        component.forEach(function (nodeId) {\n          if (fixedNodes.has(nodeId)) {\n            fixedIds.push(nodeId);\n          }\n        });\n        if (fixedIds.length > 0) {\n          var position = 0;\n          fixedIds.forEach(function (fixedId) {\n            if (direction == \"horizontal\") {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            } else {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            }\n          });\n          position = position / fixedIds.length;\n          component.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) {\n              positionMap.set(nodeId, position);\n            }\n          });\n        } else {\n          var _position = 0;\n          component.forEach(function (nodeId) {\n            if (direction == \"horizontal\") {\n              _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n          });\n          _position = _position / component.length;\n          component.forEach(function (nodeId) {\n            positionMap.set(nodeId, _position);\n          });\n        }\n      });\n    }\n\n    // calculate positions of the nodes\n\n    var _loop = function _loop() {\n      var currentNode = queue.shift();\n      var neighbors = graph.get(currentNode);\n      neighbors.forEach(function (neighbor) {\n        if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n          if (fixedNodes && fixedNodes.has(neighbor.id)) {\n            var fixedPosition = void 0;\n            if (direction == \"horizontal\") {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            } else {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            }\n            positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n            if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n              var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n              pastMap.get(currentNode).forEach(function (nodeId) {\n                positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n              });\n            }\n          } else {\n            positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n          }\n        }\n        inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n        if (inDegrees.get(neighbor.id) == 0) {\n          queue.push(neighbor.id);\n        }\n        if (fixedNodes) {\n          pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n        }\n      });\n    };\n\n    while (queue.length != 0) {\n      _loop();\n    }\n\n    // readjust position of the nodes after enforcement\n    if (fixedNodes) {\n      // find indegree count for each node\n      var sinkNodes = new Set();\n\n      graph.forEach(function (value, key) {\n        if (value.length == 0) {\n          sinkNodes.add(key);\n        }\n      });\n\n      var _components = [];\n      pastMap.forEach(function (value, key) {\n        if (sinkNodes.has(key)) {\n          var isFixedComponent = false;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var nodeId = _step2.value;\n\n              if (fixedNodes.has(nodeId)) {\n                isFixedComponent = true;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          if (!isFixedComponent) {\n            var isExist = false;\n            var existAt = void 0;\n            _components.forEach(function (component, index) {\n              if (component.has([].concat(_toConsumableArray(value))[0])) {\n                isExist = true;\n                existAt = index;\n              }\n            });\n            if (!isExist) {\n              _components.push(new Set(value));\n            } else {\n              value.forEach(function (ele) {\n                _components[existAt].add(ele);\n              });\n            }\n          }\n        }\n      });\n\n      _components.forEach(function (component, index) {\n        var minBefore = Number.POSITIVE_INFINITY;\n        var minAfter = Number.POSITIVE_INFINITY;\n        var maxBefore = Number.NEGATIVE_INFINITY;\n        var maxAfter = Number.NEGATIVE_INFINITY;\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var nodeId = _step3.value;\n\n            var posBefore = void 0;\n            if (direction == \"horizontal\") {\n              posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n            var posAfter = positionMap.get(nodeId);\n            if (posBefore < minBefore) {\n              minBefore = posBefore;\n            }\n            if (posBefore > maxBefore) {\n              maxBefore = posBefore;\n            }\n            if (posAfter < minAfter) {\n              minAfter = posAfter;\n            }\n            if (posAfter > maxAfter) {\n              maxAfter = posAfter;\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _nodeId = _step4.value;\n\n            positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      });\n    }\n\n    return positionMap;\n  };\n\n  // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n  // or if there are only rel. placement contraints where the largest component isn't sufficiently large\n  var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n    // variables to count votes\n    var reflectOnY = 0,\n        notReflectOnY = 0;\n    var reflectOnX = 0,\n        notReflectOnX = 0;\n\n    relativePlacementConstraints.forEach(function (constraint) {\n      if (constraint.left) {\n        xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n      } else {\n        yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n      }\n    });\n\n    if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n      for (var _i = 0; _i < nodeIndexes.size; _i++) {\n        xCoords[_i] = -1 * xCoords[_i];\n        yCoords[_i] = -1 * yCoords[_i];\n      }\n    } else if (reflectOnY > notReflectOnY) {\n      for (var _i2 = 0; _i2 < nodeIndexes.size; _i2++) {\n        xCoords[_i2] = -1 * xCoords[_i2];\n      }\n    } else if (reflectOnX > notReflectOnX) {\n      for (var _i3 = 0; _i3 < nodeIndexes.size; _i3++) {\n        yCoords[_i3] = -1 * yCoords[_i3];\n      }\n    }\n  };\n\n  // find weakly connected components in undirected graph\n  var findComponents = function findComponents(graph) {\n    // find weakly connected components in dag\n    var components = [];\n    var queue = new LinkedList();\n    var visited = new Set();\n    var count = 0;\n\n    graph.forEach(function (value, key) {\n      if (!visited.has(key)) {\n        components[count] = [];\n        var _currentNode = key;\n        queue.push(_currentNode);\n        visited.add(_currentNode);\n        components[count].push(_currentNode);\n\n        while (queue.length != 0) {\n          _currentNode = queue.shift();\n          var neighbors = graph.get(_currentNode);\n          neighbors.forEach(function (neighbor) {\n            if (!visited.has(neighbor.id)) {\n              queue.push(neighbor.id);\n              visited.add(neighbor.id);\n              components[count].push(neighbor.id);\n            }\n          });\n        }\n        count++;\n      }\n    });\n    return components;\n  };\n\n  // return undirected version of given dag\n  var dagToUndirected = function dagToUndirected(dag) {\n    var undirected = new Map();\n\n    dag.forEach(function (value, key) {\n      undirected.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        undirected.get(key).push(adjacent);\n        undirected.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return undirected;\n  };\n\n  // return reversed (directions inverted) version of given dag\n  var dagToReversed = function dagToReversed(dag) {\n    var reversed = new Map();\n\n    dag.forEach(function (value, key) {\n      reversed.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        reversed.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return reversed;\n  };\n\n  /****  apply transformation to the initial draft layout to better align with constrained nodes ****/\n  // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n  // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n\n  /* construct source and target configurations */\n\n  var targetMatrix = []; // A - target configuration\n  var sourceMatrix = []; // B - source configuration \n  var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n  var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary\n  var fixedNodes = new Set();\n  var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n  var dagUndirected = new Map(); // undirected version of the dag\n  var components = []; // weakly connected components\n\n  // fill fixedNodes collection to use later\n  if (constraints.fixedNodeConstraint) {\n    constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      fixedNodes.add(nodeData.nodeId);\n    });\n  }\n\n  // construct dag from relative placement constraints \n  if (constraints.relativePlacementConstraint) {\n    // construct both directed and undirected version of the dag\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (constraint.left) {\n        if (dag.has(constraint.left)) {\n          dag.get(constraint.left).push({ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" });\n        } else {\n          dag.set(constraint.left, [{ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" }]);\n        }\n        if (!dag.has(constraint.right)) {\n          dag.set(constraint.right, []);\n        }\n      } else {\n        if (dag.has(constraint.top)) {\n          dag.get(constraint.top).push({ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" });\n        } else {\n          dag.set(constraint.top, [{ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" }]);\n        }\n        if (!dag.has(constraint.bottom)) {\n          dag.set(constraint.bottom, []);\n        }\n      }\n    });\n\n    dagUndirected = dagToUndirected(dag);\n    components = findComponents(dagUndirected);\n  }\n\n  if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n    // first check fixed node constraint\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        targetMatrix[i] = [nodeData.position.x, nodeData.position.y];\n        sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeData.nodeId)], yCoords[nodeIndexes.get(nodeData.nodeId)]];\n      });\n      standardTransformation = true;\n    } else if (constraints.alignmentConstraint) {\n      (function () {\n        // then check alignment constraint\n        var count = 0;\n        if (constraints.alignmentConstraint.vertical) {\n          var verticalAlign = constraints.alignmentConstraint.vertical;\n\n          var _loop2 = function _loop2(_i4) {\n            var alignmentSet = new Set();\n            verticalAlign[_i4].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var xPos = void 0;\n            if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n            verticalAlign[_i4].forEach(function (nodeId) {\n              targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i4 = 0; _i4 < verticalAlign.length; _i4++) {\n            _loop2(_i4);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.alignmentConstraint.horizontal) {\n          var horizontalAlign = constraints.alignmentConstraint.horizontal;\n\n          var _loop3 = function _loop3(_i5) {\n            var alignmentSet = new Set();\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var yPos = void 0;\n            if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i5 = 0; _i5 < horizontalAlign.length; _i5++) {\n            _loop3(_i5);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.relativePlacementConstraint) {\n          reflectionType = true;\n        }\n      })();\n    } else if (constraints.relativePlacementConstraint) {\n      // finally check relative placement constraint\n      // find largest component in dag\n      var largestComponentSize = 0;\n      var largestComponentIndex = 0;\n      for (var _i6 = 0; _i6 < components.length; _i6++) {\n        if (components[_i6].length > largestComponentSize) {\n          largestComponentSize = components[_i6].length;\n          largestComponentIndex = _i6;\n        }\n      }\n      // if largest component isn't dominant, then take the votes for reflection\n      if (largestComponentSize < dagUndirected.size / 2) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n        standardTransformation = false;\n        reflectionType = false;\n      } else {\n        // use largest component for transformation\n        // construct horizontal and vertical subgraphs in the largest component\n        var subGraphOnHorizontal = new Map();\n        var subGraphOnVertical = new Map();\n        var constraintsInlargestComponent = [];\n\n        components[largestComponentIndex].forEach(function (nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            if (adjacent.direction == \"horizontal\") {\n              if (subGraphOnHorizontal.has(nodeId)) {\n                subGraphOnHorizontal.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnHorizontal.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnHorizontal.has(adjacent.id)) {\n                subGraphOnHorizontal.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ left: nodeId, right: adjacent.id });\n            } else {\n              if (subGraphOnVertical.has(nodeId)) {\n                subGraphOnVertical.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnVertical.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnVertical.has(adjacent.id)) {\n                subGraphOnVertical.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ top: nodeId, bottom: adjacent.id });\n            }\n          });\n        });\n\n        applyReflectionForRelativePlacement(constraintsInlargestComponent);\n        reflectionType = false;\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n\n        // construct source and target configuration\n        components[largestComponentIndex].forEach(function (nodeId, i) {\n          sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n          targetMatrix[i] = [];\n          if (positionMapHorizontal.has(nodeId)) {\n            targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n          } else {\n            targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n          }\n          if (positionMapVertical.has(nodeId)) {\n            targetMatrix[i][1] = positionMapVertical.get(nodeId);\n          } else {\n            targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n          }\n        });\n\n        standardTransformation = true;\n      }\n    }\n\n    // if transformation is required, then calculate and apply transformation matrix\n    if (standardTransformation) {\n      /* calculate transformation matrix */\n      var transformationMatrix = void 0;\n      var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'\n      var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'\n\n      // centralize transpose matrices\n      for (var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++) {\n        targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n        sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n      }\n\n      // do actual calculation for transformation matrix\n      var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B\n      var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V \n      transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'\n\n      /* apply found transformation matrix to obtain final draft layout */\n      for (var _i8 = 0; _i8 < nodeIndexes.size; _i8++) {\n        var temp1 = [xCoords[_i8], yCoords[_i8]];\n        var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];\n        var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];\n        xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n        yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n      }\n\n      // applied only both alignment and rel. placement constraints exist\n      if (reflectionType) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n      }\n    }\n  }\n\n  if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n    /****  enforce constraints on the transformed draft layout ****/\n\n    /* first enforce fixed node constraint */\n\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n      var translationAmount = { x: 0, y: 0 };\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        var posInTheory = { x: xCoords[nodeIndexes.get(nodeData.nodeId)], y: yCoords[nodeIndexes.get(nodeData.nodeId)] };\n        var posDesired = nodeData.position;\n        var posDiff = calculatePositionDiff(posDesired, posInTheory);\n        translationAmount.x += posDiff.x;\n        translationAmount.y += posDiff.y;\n      });\n      translationAmount.x /= constraints.fixedNodeConstraint.length;\n      translationAmount.y /= constraints.fixedNodeConstraint.length;\n\n      xCoords.forEach(function (value, i) {\n        xCoords[i] += translationAmount.x;\n      });\n\n      yCoords.forEach(function (value, i) {\n        yCoords[i] += translationAmount.y;\n      });\n\n      constraints.fixedNodeConstraint.forEach(function (nodeData) {\n        xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n        yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n      });\n    }\n\n    /* then enforce alignment constraint */\n\n    if (constraints.alignmentConstraint) {\n      if (constraints.alignmentConstraint.vertical) {\n        var xAlign = constraints.alignmentConstraint.vertical;\n\n        var _loop4 = function _loop4(_i9) {\n          var alignmentSet = new Set();\n          xAlign[_i9].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var xPos = void 0;\n          if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n          });\n        };\n\n        for (var _i9 = 0; _i9 < xAlign.length; _i9++) {\n          _loop4(_i9);\n        }\n      }\n      if (constraints.alignmentConstraint.horizontal) {\n        var yAlign = constraints.alignmentConstraint.horizontal;\n\n        var _loop5 = function _loop5(_i10) {\n          var alignmentSet = new Set();\n          yAlign[_i10].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var yPos = void 0;\n          if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n          });\n        };\n\n        for (var _i10 = 0; _i10 < yAlign.length; _i10++) {\n          _loop5(_i10);\n        }\n      }\n    }\n\n    /* finally enforce relative placement constraint */\n\n    if (constraints.relativePlacementConstraint) {\n      (function () {\n        var nodeToDummyForVerticalAlignment = new Map();\n        var nodeToDummyForHorizontalAlignment = new Map();\n        var dummyToNodeForVerticalAlignment = new Map();\n        var dummyToNodeForHorizontalAlignment = new Map();\n        var dummyPositionsForVerticalAlignment = new Map();\n        var dummyPositionsForHorizontalAlignment = new Map();\n        var fixedNodesOnHorizontal = new Set();\n        var fixedNodesOnVertical = new Set();\n\n        // fill maps and sets      \n        fixedNodes.forEach(function (nodeId) {\n          fixedNodesOnHorizontal.add(nodeId);\n          fixedNodesOnVertical.add(nodeId);\n        });\n\n        if (constraints.alignmentConstraint) {\n          if (constraints.alignmentConstraint.vertical) {\n            var verticalAlignment = constraints.alignmentConstraint.vertical;\n\n            var _loop6 = function _loop6(_i11) {\n              dummyToNodeForVerticalAlignment.set(\"dummy\" + _i11, []);\n              verticalAlignment[_i11].forEach(function (nodeId) {\n                nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + _i11);\n                dummyToNodeForVerticalAlignment.get(\"dummy\" + _i11).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnHorizontal.add(\"dummy\" + _i11);\n                }\n              });\n              dummyPositionsForVerticalAlignment.set(\"dummy\" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n            };\n\n            for (var _i11 = 0; _i11 < verticalAlignment.length; _i11++) {\n              _loop6(_i11);\n            }\n          }\n          if (constraints.alignmentConstraint.horizontal) {\n            var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n\n            var _loop7 = function _loop7(_i12) {\n              dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i12, []);\n              horizontalAlignment[_i12].forEach(function (nodeId) {\n                nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + _i12);\n                dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i12).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnVertical.add(\"dummy\" + _i12);\n                }\n              });\n              dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n            };\n\n            for (var _i12 = 0; _i12 < horizontalAlignment.length; _i12++) {\n              _loop7(_i12);\n            }\n          }\n        }\n\n        // construct horizontal and vertical dags (subgraphs) from overall dag\n        var dagOnHorizontal = new Map();\n        var dagOnVertical = new Map();\n\n        var _loop8 = function _loop8(nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            var sourceId = void 0;\n            var targetNode = void 0;\n            if (adjacent[\"direction\"] == \"horizontal\") {\n              sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForVerticalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnHorizontal.has(sourceId)) {\n                dagOnHorizontal.get(sourceId).push(targetNode);\n              } else {\n                dagOnHorizontal.set(sourceId, [targetNode]);\n              }\n              if (!dagOnHorizontal.has(targetNode.id)) {\n                dagOnHorizontal.set(targetNode.id, []);\n              }\n            } else {\n              sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForHorizontalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnVertical.has(sourceId)) {\n                dagOnVertical.get(sourceId).push(targetNode);\n              } else {\n                dagOnVertical.set(sourceId, [targetNode]);\n              }\n              if (!dagOnVertical.has(targetNode.id)) {\n                dagOnVertical.set(targetNode.id, []);\n              }\n            }\n          });\n        };\n\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var nodeId = _step5.value;\n\n            _loop8(nodeId);\n          }\n\n          // find source nodes of each component in horizontal and vertical dags\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n        var undirectedOnVertical = dagToUndirected(dagOnVertical);\n        var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n        var componentsOnVertical = findComponents(undirectedOnVertical);\n        var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n        var reversedDagOnVertical = dagToReversed(dagOnVertical);\n        var componentSourcesOnHorizontal = [];\n        var componentSourcesOnVertical = [];\n\n        componentsOnHorizontal.forEach(function (component, index) {\n          componentSourcesOnHorizontal[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n              componentSourcesOnHorizontal[index].push(nodeId);\n            }\n          });\n        });\n\n        componentsOnVertical.forEach(function (component, index) {\n          componentSourcesOnVertical[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnVertical.get(nodeId).length == 0) {\n              componentSourcesOnVertical[index].push(nodeId);\n            }\n          });\n        });\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n\n        // update positions of the nodes based on relative placement constraints\n\n        var _loop9 = function _loop9(key) {\n          if (dummyToNodeForVerticalAlignment.get(key)) {\n            dummyToNodeForVerticalAlignment.get(key).forEach(function (nodeId) {\n              xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n            });\n          } else {\n            xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var key = _step6.value;\n\n            _loop9(key);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        var _loop10 = function _loop10(key) {\n          if (dummyToNodeForHorizontalAlignment.get(key)) {\n            dummyToNodeForHorizontalAlignment.get(key).forEach(function (nodeId) {\n              yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n            });\n          } else {\n            yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var key = _step7.value;\n\n            _loop10(key);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      })();\n    }\n  }\n\n  // assign new coordinates to nodes after constraint handling\n  for (var _i13 = 0; _i13 < allNodes.length; _i13++) {\n    var _node = allNodes[_i13];\n    if (_node.getChild() == null) {\n      _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n    }\n  }\n};\n\nmodule.exports = ConstraintHandler;\n\n/***/ }),\n\n/***/ 551:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__551__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(45);\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}