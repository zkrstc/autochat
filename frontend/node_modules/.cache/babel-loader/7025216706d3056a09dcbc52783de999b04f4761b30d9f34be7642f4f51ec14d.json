{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.iterator.constructor.js\");\nrequire(\"core-js/modules/es.iterator.filter.js\");\nrequire(\"core-js/modules/es.iterator.for-each.js\");\nrequire(\"core-js/modules/es.set.difference.v2.js\");\nrequire(\"core-js/modules/es.set.intersection.v2.js\");\nrequire(\"core-js/modules/es.set.is-disjoint-from.v2.js\");\nrequire(\"core-js/modules/es.set.is-subset-of.v2.js\");\nrequire(\"core-js/modules/es.set.is-superset-of.v2.js\");\nrequire(\"core-js/modules/es.set.symmetric-difference.v2.js\");\nrequire(\"core-js/modules/es.set.union.v2.js\");\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"layout-base\"));else if (typeof define === 'function' && define.amd) define([\"layout-base\"], factory);else if (typeof exports === 'object') exports[\"coseBase\"] = factory(require(\"layout-base\"));else root[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_0__) {\n  return /******/function (modules) {\n    // webpackBootstrap\n    /******/ // The module cache\n    /******/\n    var installedModules = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId) {\n      /******/\n      /******/ // Check if module is in cache\n      /******/if (installedModules[moduleId]) {\n        /******/return installedModules[moduleId].exports;\n        /******/\n      }\n      /******/ // Create a new module (and put it into the cache)\n      /******/\n      var module = installedModules[moduleId] = {\n        /******/i: moduleId,\n        /******/l: false,\n        /******/exports: {}\n        /******/\n      };\n      /******/\n      /******/ // Execute the module function\n      /******/\n      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n      /******/\n      /******/ // Flag the module as loaded\n      /******/\n      module.l = true;\n      /******/\n      /******/ // Return the exports of the module\n      /******/\n      return module.exports;\n      /******/\n    }\n    /******/\n    /******/\n    /******/ // expose the modules object (__webpack_modules__)\n    /******/\n    __webpack_require__.m = modules;\n    /******/\n    /******/ // expose the module cache\n    /******/\n    __webpack_require__.c = installedModules;\n    /******/\n    /******/ // identity function for calling harmony imports with the correct context\n    /******/\n    __webpack_require__.i = function (value) {\n      return value;\n    };\n    /******/\n    /******/ // define getter function for harmony exports\n    /******/\n    __webpack_require__.d = function (exports, name, getter) {\n      /******/if (!__webpack_require__.o(exports, name)) {\n        /******/Object.defineProperty(exports, name, {\n          /******/configurable: false,\n          /******/enumerable: true,\n          /******/get: getter\n          /******/\n        });\n        /******/\n      }\n      /******/\n    };\n    /******/\n    /******/ // getDefaultExport function for compatibility with non-harmony modules\n    /******/\n    __webpack_require__.n = function (module) {\n      /******/var getter = module && module.__esModule ? /******/function getDefault() {\n        return module['default'];\n      } : /******/function getModuleExports() {\n        return module;\n      };\n      /******/\n      __webpack_require__.d(getter, 'a', getter);\n      /******/\n      return getter;\n      /******/\n    };\n    /******/\n    /******/ // Object.prototype.hasOwnProperty.call\n    /******/\n    __webpack_require__.o = function (object, property) {\n      return Object.prototype.hasOwnProperty.call(object, property);\n    };\n    /******/\n    /******/ // __webpack_public_path__\n    /******/\n    __webpack_require__.p = \"\";\n    /******/\n    /******/ // Load entry module and return exports\n    /******/\n    return __webpack_require__(__webpack_require__.s = 7);\n    /******/\n  }\n  /************************************************************************/\n  /******/([(/* 0 */\n  /***/function (module, exports) {\n    module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n    /***/\n  }), (/* 1 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n    function CoSEConstants() {}\n\n    //CoSEConstants inherits static props in FDLayoutConstants\n    for (var prop in FDLayoutConstants) {\n      CoSEConstants[prop] = FDLayoutConstants[prop];\n    }\n    CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n    CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n    CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n    CoSEConstants.TILE = true;\n    CoSEConstants.TILING_PADDING_VERTICAL = 10;\n    CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n\n    module.exports = CoSEConstants;\n\n    /***/\n  }), (/* 2 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;\n    function CoSEEdge(source, target, vEdge) {\n      FDLayoutEdge.call(this, source, target, vEdge);\n    }\n    CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n    for (var prop in FDLayoutEdge) {\n      CoSEEdge[prop] = FDLayoutEdge[prop];\n    }\n    module.exports = CoSEEdge;\n\n    /***/\n  }), (/* 3 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var LGraph = __webpack_require__(0).LGraph;\n    function CoSEGraph(parent, graphMgr, vGraph) {\n      LGraph.call(this, parent, graphMgr, vGraph);\n    }\n    CoSEGraph.prototype = Object.create(LGraph.prototype);\n    for (var prop in LGraph) {\n      CoSEGraph[prop] = LGraph[prop];\n    }\n    module.exports = CoSEGraph;\n\n    /***/\n  }), (/* 4 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var LGraphManager = __webpack_require__(0).LGraphManager;\n    function CoSEGraphManager(layout) {\n      LGraphManager.call(this, layout);\n    }\n    CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n    for (var prop in LGraphManager) {\n      CoSEGraphManager[prop] = LGraphManager[prop];\n    }\n    module.exports = CoSEGraphManager;\n\n    /***/\n  }), (/* 5 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var FDLayoutNode = __webpack_require__(0).FDLayoutNode;\n    var IMath = __webpack_require__(0).IMath;\n    function CoSENode(gm, loc, size, vNode) {\n      FDLayoutNode.call(this, gm, loc, size, vNode);\n    }\n    CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n    for (var prop in FDLayoutNode) {\n      CoSENode[prop] = FDLayoutNode[prop];\n    }\n    CoSENode.prototype.move = function () {\n      var layout = this.graphManager.getLayout();\n      this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n      this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n      if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n        this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n      }\n      if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n        this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n      }\n\n      // a simple node, just move it\n      if (this.child == null) {\n        this.moveBy(this.displacementX, this.displacementY);\n      }\n      // an empty compound node, again just move it\n      else if (this.child.getNodes().length == 0) {\n        this.moveBy(this.displacementX, this.displacementY);\n      }\n      // non-empty compound node, propogate movement to children as well\n      else {\n        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n      }\n      layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n      this.springForceX = 0;\n      this.springForceY = 0;\n      this.repulsionForceX = 0;\n      this.repulsionForceY = 0;\n      this.gravitationForceX = 0;\n      this.gravitationForceY = 0;\n      this.displacementX = 0;\n      this.displacementY = 0;\n    };\n    CoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n      var nodes = this.getChild().getNodes();\n      var node;\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        if (node.getChild() == null) {\n          node.moveBy(dX, dY);\n          node.displacementX += dX;\n          node.displacementY += dY;\n        } else {\n          node.propogateDisplacementToChildren(dX, dY);\n        }\n      }\n    };\n    CoSENode.prototype.setPred1 = function (pred1) {\n      this.pred1 = pred1;\n    };\n    CoSENode.prototype.getPred1 = function () {\n      return pred1;\n    };\n    CoSENode.prototype.getPred2 = function () {\n      return pred2;\n    };\n    CoSENode.prototype.setNext = function (next) {\n      this.next = next;\n    };\n    CoSENode.prototype.getNext = function () {\n      return next;\n    };\n    CoSENode.prototype.setProcessed = function (processed) {\n      this.processed = processed;\n    };\n    CoSENode.prototype.isProcessed = function () {\n      return processed;\n    };\n    module.exports = CoSENode;\n\n    /***/\n  }), (/* 6 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var FDLayout = __webpack_require__(0).FDLayout;\n    var CoSEGraphManager = __webpack_require__(4);\n    var CoSEGraph = __webpack_require__(3);\n    var CoSENode = __webpack_require__(5);\n    var CoSEEdge = __webpack_require__(2);\n    var CoSEConstants = __webpack_require__(1);\n    var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n    var LayoutConstants = __webpack_require__(0).LayoutConstants;\n    var Point = __webpack_require__(0).Point;\n    var PointD = __webpack_require__(0).PointD;\n    var Layout = __webpack_require__(0).Layout;\n    var Integer = __webpack_require__(0).Integer;\n    var IGeometry = __webpack_require__(0).IGeometry;\n    var LGraph = __webpack_require__(0).LGraph;\n    var Transform = __webpack_require__(0).Transform;\n    function CoSELayout() {\n      FDLayout.call(this);\n      this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n    }\n    CoSELayout.prototype = Object.create(FDLayout.prototype);\n    for (var prop in FDLayout) {\n      CoSELayout[prop] = FDLayout[prop];\n    }\n    CoSELayout.prototype.newGraphManager = function () {\n      var gm = new CoSEGraphManager(this);\n      this.graphManager = gm;\n      return gm;\n    };\n    CoSELayout.prototype.newGraph = function (vGraph) {\n      return new CoSEGraph(null, this.graphManager, vGraph);\n    };\n    CoSELayout.prototype.newNode = function (vNode) {\n      return new CoSENode(this.graphManager, vNode);\n    };\n    CoSELayout.prototype.newEdge = function (vEdge) {\n      return new CoSEEdge(null, null, vEdge);\n    };\n    CoSELayout.prototype.initParameters = function () {\n      FDLayout.prototype.initParameters.call(this, arguments);\n      if (!this.isSubLayout) {\n        if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n          this.idealEdgeLength = 10;\n        } else {\n          this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n        }\n        this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n        this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n        this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n        this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n        this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n        this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n        this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n        // variables for tree reduction support\n        this.prunedNodesAll = [];\n        this.growTreeIterations = 0;\n        this.afterGrowthIterations = 0;\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = false;\n\n        // variables for cooling\n        this.coolingCycle = 0;\n        this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n        this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n        this.coolingAdjuster = 1;\n      }\n    };\n    CoSELayout.prototype.layout = function () {\n      var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n      if (createBendsAsNeeded) {\n        this.createBendpoints();\n        this.graphManager.resetAllEdges();\n      }\n      this.level = 0;\n      return this.classicLayout();\n    };\n    CoSELayout.prototype.classicLayout = function () {\n      this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n      this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n      this.calcNoOfChildrenForAllNodes();\n      this.graphManager.calcLowestCommonAncestors();\n      this.graphManager.calcInclusionTreeDepths();\n      this.graphManager.getRoot().calcEstimatedSize();\n      this.calcIdealEdgeLengths();\n      if (!this.incremental) {\n        var forest = this.getFlatForest();\n\n        // The graph associated with this layout is flat and a forest\n        if (forest.length > 0) {\n          this.positionNodesRadially(forest);\n        }\n        // The graph associated with this layout is not flat or a forest\n        else {\n          // Reduce the trees when incremental mode is not enabled and graph is not a forest \n          this.reduceTrees();\n          // Update nodes that gravity will be applied\n          this.graphManager.resetAllNodesToApplyGravitation();\n          var allNodes = new Set(this.getAllNodes());\n          var intersection = this.nodesWithGravity.filter(function (x) {\n            return allNodes.has(x);\n          });\n          this.graphManager.setAllNodesToApplyGravitation(intersection);\n          this.positionNodesRandomly();\n        }\n      } else {\n        if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n          // Reduce the trees in incremental mode if only this constant is set to true \n          this.reduceTrees();\n          // Update nodes that gravity will be applied\n          this.graphManager.resetAllNodesToApplyGravitation();\n          var allNodes = new Set(this.getAllNodes());\n          var intersection = this.nodesWithGravity.filter(function (x) {\n            return allNodes.has(x);\n          });\n          this.graphManager.setAllNodesToApplyGravitation(intersection);\n        }\n      }\n      this.initSpringEmbedder();\n      this.runSpringEmbedder();\n      return true;\n    };\n    CoSELayout.prototype.tick = function () {\n      this.totalIterations++;\n      if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n        if (this.prunedNodesAll.length > 0) {\n          this.isTreeGrowing = true;\n        } else {\n          return true;\n        }\n      }\n      if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n        if (this.isConverged()) {\n          if (this.prunedNodesAll.length > 0) {\n            this.isTreeGrowing = true;\n          } else {\n            return true;\n          }\n        }\n        this.coolingCycle++;\n        if (this.layoutQuality == 0) {\n          // quality - \"draft\"\n          this.coolingAdjuster = this.coolingCycle;\n        } else if (this.layoutQuality == 1) {\n          // quality - \"default\"\n          this.coolingAdjuster = this.coolingCycle / 3;\n        }\n\n        // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n        this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n        this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n      }\n      // Operations while tree is growing again \n      if (this.isTreeGrowing) {\n        if (this.growTreeIterations % 10 == 0) {\n          if (this.prunedNodesAll.length > 0) {\n            this.graphManager.updateBounds();\n            this.updateGrid();\n            this.growTree(this.prunedNodesAll);\n            // Update nodes that gravity will be applied\n            this.graphManager.resetAllNodesToApplyGravitation();\n            var allNodes = new Set(this.getAllNodes());\n            var intersection = this.nodesWithGravity.filter(function (x) {\n              return allNodes.has(x);\n            });\n            this.graphManager.setAllNodesToApplyGravitation(intersection);\n            this.graphManager.updateBounds();\n            this.updateGrid();\n            this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n          } else {\n            this.isTreeGrowing = false;\n            this.isGrowthFinished = true;\n          }\n        }\n        this.growTreeIterations++;\n      }\n      // Operations after growth is finished\n      if (this.isGrowthFinished) {\n        if (this.isConverged()) {\n          return true;\n        }\n        if (this.afterGrowthIterations % 10 == 0) {\n          this.graphManager.updateBounds();\n          this.updateGrid();\n        }\n        this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n        this.afterGrowthIterations++;\n      }\n      var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n      var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n      this.totalDisplacement = 0;\n      this.graphManager.updateBounds();\n      this.calcSpringForces();\n      this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      this.calcGravitationalForces();\n      this.moveNodes();\n      this.animate();\n      return false; // Layout is not ended yet return false\n    };\n    CoSELayout.prototype.getPositionsData = function () {\n      var allNodes = this.graphManager.getAllNodes();\n      var pData = {};\n      for (var i = 0; i < allNodes.length; i++) {\n        var rect = allNodes[i].rect;\n        var id = allNodes[i].id;\n        pData[id] = {\n          id: id,\n          x: rect.getCenterX(),\n          y: rect.getCenterY(),\n          w: rect.width,\n          h: rect.height\n        };\n      }\n      return pData;\n    };\n    CoSELayout.prototype.runSpringEmbedder = function () {\n      this.initialAnimationPeriod = 25;\n      this.animationPeriod = this.initialAnimationPeriod;\n      var layoutEnded = false;\n\n      // If aminate option is 'during' signal that layout is supposed to start iterating\n      if (FDLayoutConstants.ANIMATE === 'during') {\n        this.emit('layoutstarted');\n      } else {\n        // If aminate option is 'during' tick() function will be called on index.js\n        while (!layoutEnded) {\n          layoutEnded = this.tick();\n        }\n        this.graphManager.updateBounds();\n      }\n    };\n    CoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n      var nodeList = [];\n      var graph;\n      var graphs = this.graphManager.getGraphs();\n      var size = graphs.length;\n      var i;\n      for (i = 0; i < size; i++) {\n        graph = graphs[i];\n        graph.updateConnected();\n        if (!graph.isConnected) {\n          nodeList = nodeList.concat(graph.getNodes());\n        }\n      }\n      return nodeList;\n    };\n    CoSELayout.prototype.createBendpoints = function () {\n      var edges = [];\n      edges = edges.concat(this.graphManager.getAllEdges());\n      var visited = new Set();\n      var i;\n      for (i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n        if (!visited.has(edge)) {\n          var source = edge.getSource();\n          var target = edge.getTarget();\n          if (source == target) {\n            edge.getBendpoints().push(new PointD());\n            edge.getBendpoints().push(new PointD());\n            this.createDummyNodesForBendpoints(edge);\n            visited.add(edge);\n          } else {\n            var edgeList = [];\n            edgeList = edgeList.concat(source.getEdgeListToNode(target));\n            edgeList = edgeList.concat(target.getEdgeListToNode(source));\n            if (!visited.has(edgeList[0])) {\n              if (edgeList.length > 1) {\n                var k;\n                for (k = 0; k < edgeList.length; k++) {\n                  var multiEdge = edgeList[k];\n                  multiEdge.getBendpoints().push(new PointD());\n                  this.createDummyNodesForBendpoints(multiEdge);\n                }\n              }\n              edgeList.forEach(function (edge) {\n                visited.add(edge);\n              });\n            }\n          }\n        }\n        if (visited.size == edges.length) {\n          break;\n        }\n      }\n    };\n    CoSELayout.prototype.positionNodesRadially = function (forest) {\n      // We tile the trees to a grid row by row; first tree starts at (0,0)\n      var currentStartingPoint = new Point(0, 0);\n      var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n      var height = 0;\n      var currentY = 0;\n      var currentX = 0;\n      var point = new PointD(0, 0);\n      for (var i = 0; i < forest.length; i++) {\n        if (i % numberOfColumns == 0) {\n          // Start of a new row, make the x coordinate 0, increment the\n          // y coordinate with the max height of the previous row\n          currentX = 0;\n          currentY = height;\n          if (i != 0) {\n            currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n          }\n          height = 0;\n        }\n        var tree = forest[i];\n\n        // Find the center of the tree\n        var centerNode = Layout.findCenterOfTree(tree);\n\n        // Set the staring point of the next tree\n        currentStartingPoint.x = currentX;\n        currentStartingPoint.y = currentY;\n\n        // Do a radial layout starting with the center\n        point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n        if (point.y > height) {\n          height = Math.floor(point.y);\n        }\n        currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n      }\n      this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n    };\n    CoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n      var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n      CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n      var bounds = LGraph.calculateBounds(tree);\n      var transform = new Transform();\n      transform.setDeviceOrgX(bounds.getMinX());\n      transform.setDeviceOrgY(bounds.getMinY());\n      transform.setWorldOrgX(startingPoint.x);\n      transform.setWorldOrgY(startingPoint.y);\n      for (var i = 0; i < tree.length; i++) {\n        var node = tree[i];\n        node.transform(transform);\n      }\n      var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n      return transform.inverseTransformPoint(bottomRight);\n    };\n    CoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n      // First, position this node by finding its angle.\n      var halfInterval = (endAngle - startAngle + 1) / 2;\n      if (halfInterval < 0) {\n        halfInterval += 180;\n      }\n      var nodeAngle = (halfInterval + startAngle) % 360;\n      var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n      // Make polar to java cordinate conversion.\n      var cos_teta = Math.cos(teta);\n      var x_ = distance * Math.cos(teta);\n      var y_ = distance * Math.sin(teta);\n      node.setCenter(x_, y_);\n\n      // Traverse all neighbors of this node and recursively call this\n      // function.\n      var neighborEdges = [];\n      neighborEdges = neighborEdges.concat(node.getEdges());\n      var childCount = neighborEdges.length;\n      if (parentOfNode != null) {\n        childCount--;\n      }\n      var branchCount = 0;\n      var incEdgesCount = neighborEdges.length;\n      var startIndex;\n      var edges = node.getEdgesBetween(parentOfNode);\n\n      // If there are multiple edges, prune them until there remains only one\n      // edge.\n      while (edges.length > 1) {\n        //neighborEdges.remove(edges.remove(0));\n        var temp = edges[0];\n        edges.splice(0, 1);\n        var index = neighborEdges.indexOf(temp);\n        if (index >= 0) {\n          neighborEdges.splice(index, 1);\n        }\n        incEdgesCount--;\n        childCount--;\n      }\n      if (parentOfNode != null) {\n        //assert edges.length == 1;\n        startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n      } else {\n        startIndex = 0;\n      }\n      var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n      for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n        // Don't back traverse to root node in current tree.\n        if (currentNeighbor == parentOfNode) {\n          continue;\n        }\n        var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n        var childEndAngle = (childStartAngle + stepAngle) % 360;\n        CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n        branchCount++;\n      }\n    };\n    CoSELayout.maxDiagonalInTree = function (tree) {\n      var maxDiagonal = Integer.MIN_VALUE;\n      for (var i = 0; i < tree.length; i++) {\n        var node = tree[i];\n        var diagonal = node.getDiagonal();\n        if (diagonal > maxDiagonal) {\n          maxDiagonal = diagonal;\n        }\n      }\n      return maxDiagonal;\n    };\n    CoSELayout.prototype.calcRepulsionRange = function () {\n      // formula is 2 x (level + 1) x idealEdgeLength\n      return 2 * (this.level + 1) * this.idealEdgeLength;\n    };\n\n    // Tiling methods\n\n    // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\n    CoSELayout.prototype.groupZeroDegreeMembers = function () {\n      var self = this;\n      // array of [parent_id x oneDegreeNode_id]\n      var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n      this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n      this.idToDummyNode = {}; // A map of id to dummy node \n\n      var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n      var allNodes = this.graphManager.getAllNodes();\n\n      // Fill zero degree list\n      for (var i = 0; i < allNodes.length; i++) {\n        var node = allNodes[i];\n        var parent = node.getParent();\n        // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n        if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n          zeroDegree.push(node);\n        }\n      }\n\n      // Create a map of parent node and its zero degree members\n      for (var i = 0; i < zeroDegree.length; i++) {\n        var node = zeroDegree[i]; // Zero degree node itself\n        var p_id = node.getParent().id; // Parent id\n\n        if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n        tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n      }\n\n      // If there are at least two nodes at a level, create a dummy compound for them\n      Object.keys(tempMemberGroups).forEach(function (p_id) {\n        if (tempMemberGroups[p_id].length > 1) {\n          var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n          self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n          var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n          // Create a dummy compound with calculated id\n          var dummyCompound = new CoSENode(self.graphManager);\n          dummyCompound.id = dummyCompoundId;\n          dummyCompound.paddingLeft = parent.paddingLeft || 0;\n          dummyCompound.paddingRight = parent.paddingRight || 0;\n          dummyCompound.paddingBottom = parent.paddingBottom || 0;\n          dummyCompound.paddingTop = parent.paddingTop || 0;\n          self.idToDummyNode[dummyCompoundId] = dummyCompound;\n          var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n          var parentGraph = parent.getChild();\n\n          // Add dummy compound to parent the graph\n          parentGraph.add(dummyCompound);\n\n          // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n          for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n            var node = tempMemberGroups[p_id][i];\n            parentGraph.remove(node);\n            dummyParentGraph.add(node);\n          }\n        }\n      });\n    };\n    CoSELayout.prototype.clearCompounds = function () {\n      var childGraphMap = {};\n      var idToNode = {};\n\n      // Get compound ordering by finding the inner one first\n      this.performDFSOnCompounds();\n      for (var i = 0; i < this.compoundOrder.length; i++) {\n        idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n        childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n        // Remove children of compounds\n        this.graphManager.remove(this.compoundOrder[i].getChild());\n        this.compoundOrder[i].child = null;\n      }\n      this.graphManager.resetAllNodes();\n\n      // Tile the removed children\n      this.tileCompoundMembers(childGraphMap, idToNode);\n    };\n    CoSELayout.prototype.clearZeroDegreeMembers = function () {\n      var self = this;\n      var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n      Object.keys(this.memberGroups).forEach(function (id) {\n        var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n        tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n        // Set the width and height of the dummy compound as calculated\n        compoundNode.rect.width = tiledZeroDegreePack[id].width;\n        compoundNode.rect.height = tiledZeroDegreePack[id].height;\n      });\n    };\n    CoSELayout.prototype.repopulateCompounds = function () {\n      for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n        var lCompoundNode = this.compoundOrder[i];\n        var id = lCompoundNode.id;\n        var horizontalMargin = lCompoundNode.paddingLeft;\n        var verticalMargin = lCompoundNode.paddingTop;\n        this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n      }\n    };\n    CoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n      var self = this;\n      var tiledPack = this.tiledZeroDegreePack;\n      Object.keys(tiledPack).forEach(function (id) {\n        var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n        var horizontalMargin = compoundNode.paddingLeft;\n        var verticalMargin = compoundNode.paddingTop;\n\n        // Adjust the positions of nodes wrt its compound\n        self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n      });\n    };\n    CoSELayout.prototype.getToBeTiled = function (node) {\n      var id = node.id;\n      //firstly check the previous results\n      if (this.toBeTiled[id] != null) {\n        return this.toBeTiled[id];\n      }\n\n      //only compound nodes are to be tiled\n      var childGraph = node.getChild();\n      if (childGraph == null) {\n        this.toBeTiled[id] = false;\n        return false;\n      }\n      var children = childGraph.getNodes(); // Get the children nodes\n\n      //a compound node is not to be tiled if all of its compound children are not to be tiled\n      for (var i = 0; i < children.length; i++) {\n        var theChild = children[i];\n        if (this.getNodeDegree(theChild) > 0) {\n          this.toBeTiled[id] = false;\n          return false;\n        }\n\n        //pass the children not having the compound structure\n        if (theChild.getChild() == null) {\n          this.toBeTiled[theChild.id] = false;\n          continue;\n        }\n        if (!this.getToBeTiled(theChild)) {\n          this.toBeTiled[id] = false;\n          return false;\n        }\n      }\n      this.toBeTiled[id] = true;\n      return true;\n    };\n\n    // Get degree of a node depending of its edges and independent of its children\n    CoSELayout.prototype.getNodeDegree = function (node) {\n      var id = node.id;\n      var edges = node.getEdges();\n      var degree = 0;\n\n      // For the edges connected\n      for (var i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n        if (edge.getSource().id !== edge.getTarget().id) {\n          degree = degree + 1;\n        }\n      }\n      return degree;\n    };\n\n    // Get degree of a node with its children\n    CoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n      var degree = this.getNodeDegree(node);\n      if (node.getChild() == null) {\n        return degree;\n      }\n      var children = node.getChild().getNodes();\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        degree += this.getNodeDegreeWithChildren(child);\n      }\n      return degree;\n    };\n    CoSELayout.prototype.performDFSOnCompounds = function () {\n      this.compoundOrder = [];\n      this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n    };\n    CoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (child.getChild() != null) {\n          this.fillCompexOrderByDFS(child.getChild().getNodes());\n        }\n        if (this.getToBeTiled(child)) {\n          this.compoundOrder.push(child);\n        }\n      }\n    };\n\n    /**\n    * This method places each zero degree member wrt given (x,y) coordinates (top left).\n    */\n    CoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n      x += compoundHorizontalMargin;\n      y += compoundVerticalMargin;\n      var left = x;\n      for (var i = 0; i < organization.rows.length; i++) {\n        var row = organization.rows[i];\n        x = left;\n        var maxHeight = 0;\n        for (var j = 0; j < row.length; j++) {\n          var lnode = row[j];\n          lnode.rect.x = x; // + lnode.rect.width / 2;\n          lnode.rect.y = y; // + lnode.rect.height / 2;\n\n          x += lnode.rect.width + organization.horizontalPadding;\n          if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n        }\n        y += maxHeight + organization.verticalPadding;\n      }\n    };\n    CoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n      var self = this;\n      this.tiledMemberPack = [];\n      Object.keys(childGraphMap).forEach(function (id) {\n        // Get the compound node\n        var compoundNode = idToNode[id];\n        self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n        compoundNode.rect.width = self.tiledMemberPack[id].width;\n        compoundNode.rect.height = self.tiledMemberPack[id].height;\n      });\n    };\n    CoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n      var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n      var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n      var organization = {\n        rows: [],\n        rowWidth: [],\n        rowHeight: [],\n        width: 0,\n        height: minWidth,\n        // assume minHeight equals to minWidth\n        verticalPadding: verticalPadding,\n        horizontalPadding: horizontalPadding\n      };\n\n      // Sort the nodes in ascending order of their areas\n      nodes.sort(function (n1, n2) {\n        if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n        if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n        return 0;\n      });\n\n      // Create the organization -> tile members\n      for (var i = 0; i < nodes.length; i++) {\n        var lNode = nodes[i];\n        if (organization.rows.length == 0) {\n          this.insertNodeToRow(organization, lNode, 0, minWidth);\n        } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n          this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n        } else {\n          this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n        }\n        this.shiftToLastRow(organization);\n      }\n      return organization;\n    };\n    CoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n      var minCompoundSize = minWidth;\n\n      // Add new row if needed\n      if (rowIndex == organization.rows.length) {\n        var secondDimension = [];\n        organization.rows.push(secondDimension);\n        organization.rowWidth.push(minCompoundSize);\n        organization.rowHeight.push(0);\n      }\n\n      // Update row width\n      var w = organization.rowWidth[rowIndex] + node.rect.width;\n      if (organization.rows[rowIndex].length > 0) {\n        w += organization.horizontalPadding;\n      }\n      organization.rowWidth[rowIndex] = w;\n      // Update compound width\n      if (organization.width < w) {\n        organization.width = w;\n      }\n\n      // Update height\n      var h = node.rect.height;\n      if (rowIndex > 0) h += organization.verticalPadding;\n      var extraHeight = 0;\n      if (h > organization.rowHeight[rowIndex]) {\n        extraHeight = organization.rowHeight[rowIndex];\n        organization.rowHeight[rowIndex] = h;\n        extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n      }\n      organization.height += extraHeight;\n\n      // Insert node\n      organization.rows[rowIndex].push(node);\n    };\n\n    //Scans the rows of an organization and returns the one with the min width\n    CoSELayout.prototype.getShortestRowIndex = function (organization) {\n      var r = -1;\n      var min = Number.MAX_VALUE;\n      for (var i = 0; i < organization.rows.length; i++) {\n        if (organization.rowWidth[i] < min) {\n          r = i;\n          min = organization.rowWidth[i];\n        }\n      }\n      return r;\n    };\n\n    //Scans the rows of an organization and returns the one with the max width\n    CoSELayout.prototype.getLongestRowIndex = function (organization) {\n      var r = -1;\n      var max = Number.MIN_VALUE;\n      for (var i = 0; i < organization.rows.length; i++) {\n        if (organization.rowWidth[i] > max) {\n          r = i;\n          max = organization.rowWidth[i];\n        }\n      }\n      return r;\n    };\n\n    /**\n    * This method checks whether adding extra width to the organization violates\n    * the aspect ratio(1) or not.\n    */\n    CoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n      var sri = this.getShortestRowIndex(organization);\n      if (sri < 0) {\n        return true;\n      }\n      var min = organization.rowWidth[sri];\n      if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n      var hDiff = 0;\n\n      // Adding to an existing row\n      if (organization.rowHeight[sri] < extraHeight) {\n        if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n      }\n      var add_to_row_ratio;\n      if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n        add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n      } else {\n        add_to_row_ratio = (organization.height + hDiff) / organization.width;\n      }\n\n      // Adding a new row for this node\n      hDiff = extraHeight + organization.verticalPadding;\n      var add_new_row_ratio;\n      if (organization.width < extraWidth) {\n        add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n      } else {\n        add_new_row_ratio = (organization.height + hDiff) / organization.width;\n      }\n      if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n      if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n      return add_to_row_ratio < add_new_row_ratio;\n    };\n\n    //If moving the last node from the longest row and adding it to the last\n    //row makes the bounding box smaller, do it.\n    CoSELayout.prototype.shiftToLastRow = function (organization) {\n      var longest = this.getLongestRowIndex(organization);\n      var last = organization.rowWidth.length - 1;\n      var row = organization.rows[longest];\n      var node = row[row.length - 1];\n      var diff = node.width + organization.horizontalPadding;\n\n      // Check if there is enough space on the last row\n      if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n        // Remove the last element of the longest row\n        row.splice(-1, 1);\n\n        // Push it to the last row\n        organization.rows[last].push(node);\n        organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n        organization.rowWidth[last] = organization.rowWidth[last] + diff;\n        organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n        // Update heights of the organization\n        var maxHeight = Number.MIN_VALUE;\n        for (var i = 0; i < row.length; i++) {\n          if (row[i].height > maxHeight) maxHeight = row[i].height;\n        }\n        if (longest > 0) maxHeight += organization.verticalPadding;\n        var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n        organization.rowHeight[longest] = maxHeight;\n        if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n        var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n        organization.height += finalTotal - prevTotal;\n        this.shiftToLastRow(organization);\n      }\n    };\n    CoSELayout.prototype.tilingPreLayout = function () {\n      if (CoSEConstants.TILE) {\n        // Find zero degree nodes and create a compound for each level\n        this.groupZeroDegreeMembers();\n        // Tile and clear children of each compound\n        this.clearCompounds();\n        // Separately tile and clear zero degree nodes for each level\n        this.clearZeroDegreeMembers();\n      }\n    };\n    CoSELayout.prototype.tilingPostLayout = function () {\n      if (CoSEConstants.TILE) {\n        this.repopulateZeroDegreeMembers();\n        this.repopulateCompounds();\n      }\n    };\n\n    // -----------------------------------------------------------------------------\n    // Section: Tree Reduction methods\n    // -----------------------------------------------------------------------------\n    // Reduce trees \n    CoSELayout.prototype.reduceTrees = function () {\n      var prunedNodesAll = [];\n      var containsLeaf = true;\n      var node;\n      while (containsLeaf) {\n        var allNodes = this.graphManager.getAllNodes();\n        var prunedNodesInStepTemp = [];\n        containsLeaf = false;\n        for (var i = 0; i < allNodes.length; i++) {\n          node = allNodes[i];\n          if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n            prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n            containsLeaf = true;\n          }\n        }\n        if (containsLeaf == true) {\n          var prunedNodesInStep = [];\n          for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n            if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n              prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n              prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n            }\n          }\n          prunedNodesAll.push(prunedNodesInStep);\n          this.graphManager.resetAllNodes();\n          this.graphManager.resetAllEdges();\n        }\n      }\n      this.prunedNodesAll = prunedNodesAll;\n    };\n\n    // Grow tree one step \n    CoSELayout.prototype.growTree = function (prunedNodesAll) {\n      var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n      var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n      var nodeData;\n      for (var i = 0; i < prunedNodesInStep.length; i++) {\n        nodeData = prunedNodesInStep[i];\n        this.findPlaceforPrunedNode(nodeData);\n        nodeData[2].add(nodeData[0]);\n        nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n      }\n      prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    };\n\n    // Find an appropriate position to replace pruned node, this method can be improved\n    CoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n      var gridForPrunedNode;\n      var nodeToConnect;\n      var prunedNode = nodeData[0];\n      if (prunedNode == nodeData[1].source) {\n        nodeToConnect = nodeData[1].target;\n      } else {\n        nodeToConnect = nodeData[1].source;\n      }\n      var startGridX = nodeToConnect.startX;\n      var finishGridX = nodeToConnect.finishX;\n      var startGridY = nodeToConnect.startY;\n      var finishGridY = nodeToConnect.finishY;\n      var upNodeCount = 0;\n      var downNodeCount = 0;\n      var rightNodeCount = 0;\n      var leftNodeCount = 0;\n      var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n      if (startGridY > 0) {\n        for (var i = startGridX; i <= finishGridX; i++) {\n          controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n        }\n      }\n      if (finishGridX < this.grid.length - 1) {\n        for (var i = startGridY; i <= finishGridY; i++) {\n          controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n        }\n      }\n      if (finishGridY < this.grid[0].length - 1) {\n        for (var i = startGridX; i <= finishGridX; i++) {\n          controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n        }\n      }\n      if (startGridX > 0) {\n        for (var i = startGridY; i <= finishGridY; i++) {\n          controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n        }\n      }\n      var min = Integer.MAX_VALUE;\n      var minCount;\n      var minIndex;\n      for (var j = 0; j < controlRegions.length; j++) {\n        if (controlRegions[j] < min) {\n          min = controlRegions[j];\n          minCount = 1;\n          minIndex = j;\n        } else if (controlRegions[j] == min) {\n          minCount++;\n        }\n      }\n      if (minCount == 3 && min == 0) {\n        if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n          gridForPrunedNode = 1;\n        } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n          gridForPrunedNode = 0;\n        } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n          gridForPrunedNode = 3;\n        } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n          gridForPrunedNode = 2;\n        }\n      } else if (minCount == 2 && min == 0) {\n        var random = Math.floor(Math.random() * 2);\n        if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n          ;\n          if (random == 0) {\n            gridForPrunedNode = 0;\n          } else {\n            gridForPrunedNode = 1;\n          }\n        } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n          if (random == 0) {\n            gridForPrunedNode = 0;\n          } else {\n            gridForPrunedNode = 2;\n          }\n        } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n          if (random == 0) {\n            gridForPrunedNode = 0;\n          } else {\n            gridForPrunedNode = 3;\n          }\n        } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n          if (random == 0) {\n            gridForPrunedNode = 1;\n          } else {\n            gridForPrunedNode = 2;\n          }\n        } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n          if (random == 0) {\n            gridForPrunedNode = 1;\n          } else {\n            gridForPrunedNode = 3;\n          }\n        } else {\n          if (random == 0) {\n            gridForPrunedNode = 2;\n          } else {\n            gridForPrunedNode = 3;\n          }\n        }\n      } else if (minCount == 4 && min == 0) {\n        var random = Math.floor(Math.random() * 4);\n        gridForPrunedNode = random;\n      } else {\n        gridForPrunedNode = minIndex;\n      }\n      if (gridForPrunedNode == 0) {\n        prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n      } else if (gridForPrunedNode == 1) {\n        prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n      } else if (gridForPrunedNode == 2) {\n        prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n      } else {\n        prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n      }\n    };\n    module.exports = CoSELayout;\n\n    /***/\n  }), (/* 7 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var coseBase = {};\n    coseBase.layoutBase = __webpack_require__(0);\n    coseBase.CoSEConstants = __webpack_require__(1);\n    coseBase.CoSEEdge = __webpack_require__(2);\n    coseBase.CoSEGraph = __webpack_require__(3);\n    coseBase.CoSEGraphManager = __webpack_require__(4);\n    coseBase.CoSELayout = __webpack_require__(6);\n    coseBase.CoSENode = __webpack_require__(5);\n    module.exports = coseBase;\n\n    /***/\n  }\n  /******/)]);\n});","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","__WEBPACK_EXTERNAL_MODULE_0__","modules","installedModules","__webpack_require__","moduleId","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","FDLayoutConstants","CoSEConstants","prop","DEFAULT_USE_MULTI_LEVEL_SCALING","DEFAULT_RADIAL_SEPARATION","DEFAULT_EDGE_LENGTH","DEFAULT_COMPONENT_SEPERATION","TILE","TILING_PADDING_VERTICAL","TILING_PADDING_HORIZONTAL","TREE_REDUCTION_ON_INCREMENTAL","FDLayoutEdge","CoSEEdge","source","target","vEdge","create","LGraph","CoSEGraph","parent","graphMgr","vGraph","LGraphManager","CoSEGraphManager","layout","FDLayoutNode","IMath","CoSENode","gm","loc","size","vNode","move","graphManager","getLayout","displacementX","coolingFactor","springForceX","repulsionForceX","gravitationForceX","noOfChildren","displacementY","springForceY","repulsionForceY","gravitationForceY","Math","abs","maxNodeDisplacement","sign","child","moveBy","getNodes","length","propogateDisplacementToChildren","totalDisplacement","dX","dY","nodes","getChild","node","setPred1","pred1","getPred1","getPred2","pred2","setNext","next","getNext","setProcessed","processed","isProcessed","FDLayout","LayoutConstants","Point","PointD","Layout","Integer","IGeometry","Transform","CoSELayout","toBeTiled","newGraphManager","newGraph","newNode","newEdge","initParameters","arguments","isSubLayout","idealEdgeLength","useSmartIdealEdgeLengthCalculation","DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION","springConstant","DEFAULT_SPRING_STRENGTH","repulsionConstant","DEFAULT_REPULSION_STRENGTH","gravityConstant","DEFAULT_GRAVITY_STRENGTH","compoundGravityConstant","DEFAULT_COMPOUND_GRAVITY_STRENGTH","gravityRangeFactor","DEFAULT_GRAVITY_RANGE_FACTOR","compoundGravityRangeFactor","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","prunedNodesAll","growTreeIterations","afterGrowthIterations","isTreeGrowing","isGrowthFinished","coolingCycle","maxCoolingCycle","maxIterations","CONVERGENCE_CHECK_PERIOD","finalTemperature","coolingAdjuster","createBendsAsNeeded","DEFAULT_CREATE_BENDS_AS_NEEDED","createBendpoints","resetAllEdges","level","classicLayout","nodesWithGravity","calculateNodesToApplyGravitationTo","setAllNodesToApplyGravitation","calcNoOfChildrenForAllNodes","calcLowestCommonAncestors","calcInclusionTreeDepths","getRoot","calcEstimatedSize","calcIdealEdgeLengths","incremental","forest","getFlatForest","positionNodesRadially","reduceTrees","resetAllNodesToApplyGravitation","allNodes","Set","getAllNodes","intersection","filter","x","has","positionNodesRandomly","initSpringEmbedder","runSpringEmbedder","tick","totalIterations","isConverged","layoutQuality","max","initialCoolingFactor","pow","log","animationPeriod","ceil","initialAnimationPeriod","sqrt","updateBounds","updateGrid","growTree","DEFAULT_COOLING_FACTOR_INCREMENTAL","gridUpdateAllowed","forceToNodeSurroundingUpdate","calcSpringForces","calcRepulsionForces","calcGravitationalForces","moveNodes","animate","getPositionsData","pData","rect","id","getCenterX","y","getCenterY","w","width","h","height","layoutEnded","ANIMATE","emit","nodeList","graph","graphs","getGraphs","updateConnected","isConnected","concat","edges","getAllEdges","visited","edge","getSource","getTarget","getBendpoints","push","createDummyNodesForBendpoints","add","edgeList","getEdgeListToNode","k","multiEdge","forEach","currentStartingPoint","numberOfColumns","currentY","currentX","point","tree","centerNode","findCenterOfTree","radialLayout","floor","transform","WORLD_CENTER_X","WORLD_CENTER_Y","startingPoint","radialSep","maxDiagonalInTree","branchRadialLayout","bounds","calculateBounds","setDeviceOrgX","getMinX","setDeviceOrgY","getMinY","setWorldOrgX","setWorldOrgY","bottomRight","getMaxX","getMaxY","inverseTransformPoint","parentOfNode","startAngle","endAngle","distance","radialSeparation","halfInterval","nodeAngle","teta","TWO_PI","cos_teta","cos","x_","y_","sin","setCenter","neighborEdges","getEdges","childCount","branchCount","incEdgesCount","startIndex","getEdgesBetween","temp","splice","index","indexOf","stepAngle","currentNeighbor","getOtherEnd","childStartAngle","childEndAngle","maxDiagonal","MIN_VALUE","diagonal","getDiagonal","calcRepulsionRange","groupZeroDegreeMembers","self","tempMemberGroups","memberGroups","idToDummyNode","zeroDegree","getParent","getNodeDegreeWithChildren","undefined","getToBeTiled","p_id","keys","dummyCompoundId","dummyCompound","paddingLeft","paddingRight","paddingBottom","paddingTop","dummyParentGraph","getGraphManager","parentGraph","remove","clearCompounds","childGraphMap","idToNode","performDFSOnCompounds","compoundOrder","resetAllNodes","tileCompoundMembers","clearZeroDegreeMembers","tiledZeroDegreePack","compoundNode","tileNodes","repopulateCompounds","lCompoundNode","horizontalMargin","verticalMargin","adjustLocations","tiledMemberPack","repopulateZeroDegreeMembers","tiledPack","childGraph","children","theChild","getNodeDegree","degree","fillCompexOrderByDFS","organization","compoundHorizontalMargin","compoundVerticalMargin","left","rows","row","maxHeight","j","lnode","horizontalPadding","verticalPadding","minWidth","rowWidth","rowHeight","sort","n1","n2","lNode","insertNodeToRow","canAddHorizontal","getShortestRowIndex","shiftToLastRow","rowIndex","minCompoundSize","secondDimension","extraHeight","r","min","Number","MAX_VALUE","getLongestRowIndex","extraWidth","sri","hDiff","add_to_row_ratio","add_new_row_ratio","longest","last","diff","instance","prevTotal","finalTotal","tilingPreLayout","tilingPostLayout","containsLeaf","prunedNodesInStepTemp","isInterGraph","getOwner","prunedNodesInStep","lengthOfPrunedNodesInStep","nodeData","findPlaceforPrunedNode","gridForPrunedNode","nodeToConnect","prunedNode","startGridX","startX","finishGridX","finishX","startGridY","startY","finishGridY","finishY","upNodeCount","downNodeCount","rightNodeCount","leftNodeCount","controlRegions","grid","minCount","minIndex","random","getHeight","getWidth","coseBase","layoutBase"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/cose-base/cose-base.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"layout-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"layout-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"coseBase\"] = factory(require(\"layout-base\"));\n\telse\n\t\troot[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraph = __webpack_require__(0).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphManager = __webpack_require__(0).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutNode = __webpack_require__(0).FDLayoutNode;\nvar IMath = __webpack_require__(0).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n  this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n  this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // a simple node, just move it\n  if (this.child == null) {\n    this.moveBy(this.displacementX, this.displacementY);\n  }\n  // an empty compound node, again just move it\n  else if (this.child.getNodes().length == 0) {\n      this.moveBy(this.displacementX, this.displacementY);\n    }\n    // non-empty compound node, propogate movement to children as well\n    else {\n        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n      }\n\n  layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.moveBy(dX, dY);\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayout = __webpack_require__(0).FDLayout;\nvar CoSEGraphManager = __webpack_require__(4);\nvar CoSEGraph = __webpack_require__(3);\nvar CoSENode = __webpack_require__(5);\nvar CoSEEdge = __webpack_require__(2);\nvar CoSEConstants = __webpack_require__(1);\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\nvar LayoutConstants = __webpack_require__(0).LayoutConstants;\nvar Point = __webpack_require__(0).Point;\nvar PointD = __webpack_require__(0).PointD;\nvar Layout = __webpack_require__(0).Layout;\nvar Integer = __webpack_require__(0).Integer;\nvar IGeometry = __webpack_require__(0).IGeometry;\nvar LGraph = __webpack_require__(0).LGraph;\nvar Transform = __webpack_require__(0).Transform;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n    this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n\n    // variables for cooling\n    this.coolingCycle = 0;\n    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n    this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n    this.coolingAdjuster = 1;\n  }\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  this.initSpringEmbedder();\n  this.runSpringEmbedder();\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n  x += compoundHorizontalMargin;\n  y += compoundVerticalMargin;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding\n  };\n\n  // Sort the nodes in ascending order of their areas\n  nodes.sort(function (n1, n2) {\n    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n    return 0;\n  });\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n  var startGridX = nodeToConnect.startX;\n  var finishGridX = nodeToConnect.finishX;\n  var startGridY = nodeToConnect.startY;\n  var finishGridY = nodeToConnect.finishY;\n\n  var upNodeCount = 0;\n  var downNodeCount = 0;\n  var rightNodeCount = 0;\n  var leftNodeCount = 0;\n  var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n  if (startGridY > 0) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n    }\n  }\n  if (finishGridX < this.grid.length - 1) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n    }\n  }\n  if (finishGridY < this.grid[0].length - 1) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n    }\n  }\n  if (startGridX > 0) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n    }\n  }\n  var min = Integer.MAX_VALUE;\n  var minCount;\n  var minIndex;\n  for (var j = 0; j < controlRegions.length; j++) {\n    if (controlRegions[j] < min) {\n      min = controlRegions[j];\n      minCount = 1;\n      minIndex = j;\n    } else if (controlRegions[j] == min) {\n      minCount++;\n    }\n  }\n\n  if (minCount == 3 && min == 0) {\n    if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n      gridForPrunedNode = 1;\n    } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 0;\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 3;\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 2;\n    }\n  } else if (minCount == 2 && min == 0) {\n    var random = Math.floor(Math.random() * 2);\n    if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n      ;\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 1;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else {\n      if (random == 0) {\n        gridForPrunedNode = 2;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    }\n  } else if (minCount == 4 && min == 0) {\n    var random = Math.floor(Math.random() * 4);\n    gridForPrunedNode = random;\n  } else {\n    gridForPrunedNode = minIndex;\n  }\n\n  if (gridForPrunedNode == 0) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n  } else if (gridForPrunedNode == 1) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  } else if (gridForPrunedNode == 2) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n  } else {\n    prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __webpack_require__(0);\ncoseBase.CoSEConstants = __webpack_require__(1);\ncoseBase.CoSEEdge = __webpack_require__(2);\ncoseBase.CoSEGraph = __webpack_require__(3);\ncoseBase.CoSEGraphManager = __webpack_require__(4);\ncoseBase.CoSELayout = __webpack_require__(6);\ncoseBase.CoSENode = __webpack_require__(5);\n\nmodule.exports = coseBase;\n\n/***/ })\n/******/ ]);\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}