{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.iterator.constructor.js\");\nrequire(\"core-js/modules/es.iterator.filter.js\");\nrequire(\"core-js/modules/es.iterator.for-each.js\");\nrequire(\"core-js/modules/es.iterator.map.js\");\nrequire(\"core-js/modules/es.set.difference.v2.js\");\nrequire(\"core-js/modules/es.set.intersection.v2.js\");\nrequire(\"core-js/modules/es.set.is-disjoint-from.v2.js\");\nrequire(\"core-js/modules/es.set.is-subset-of.v2.js\");\nrequire(\"core-js/modules/es.set.is-superset-of.v2.js\");\nrequire(\"core-js/modules/es.set.symmetric-difference.v2.js\");\nrequire(\"core-js/modules/es.set.union.v2.js\");\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"cose-base\"));else if (typeof define === 'function' && define.amd) define([\"cose-base\"], factory);else if (typeof exports === 'object') exports[\"cytoscapeFcose\"] = factory(require(\"cose-base\"));else root[\"cytoscapeFcose\"] = factory(root[\"coseBase\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE__140__) {\n  return /******/(() => {\n    // webpackBootstrap\n    /******/\n    \"use strict\";\n\n    /******/\n    var __webpack_modules__ = {\n      /***/658: (/***/module => {\n        // Simple, internal Object.assign() polyfill for options objects etc.\n\n        module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n          for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            srcs[_key - 1] = arguments[_key];\n          }\n          srcs.forEach(function (src) {\n            Object.keys(src).forEach(function (k) {\n              return tgt[k] = src[k];\n            });\n          });\n          return tgt;\n        };\n\n        /***/\n      }),\n      /***/548: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var _slicedToArray = function () {\n          function sliceIterator(arr, i) {\n            var _arr = [];\n            var _n = true;\n            var _d = false;\n            var _e = undefined;\n            try {\n              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n                _arr.push(_s.value);\n                if (i && _arr.length === i) break;\n              }\n            } catch (err) {\n              _d = true;\n              _e = err;\n            } finally {\n              try {\n                if (!_n && _i[\"return\"]) _i[\"return\"]();\n              } finally {\n                if (_d) throw _e;\n              }\n            }\n            return _arr;\n          }\n          return function (arr, i) {\n            if (Array.isArray(arr)) {\n              return arr;\n            } else if (Symbol.iterator in Object(arr)) {\n              return sliceIterator(arr, i);\n            } else {\n              throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n            }\n          };\n        }();\n\n        /*\n         * Auxiliary functions\n         */\n\n        var LinkedList = __webpack_require__(140).layoutBase.LinkedList;\n        var auxiliary = {};\n\n        // get the top most nodes\n        auxiliary.getTopMostNodes = function (nodes) {\n          var nodesMap = {};\n          for (var i = 0; i < nodes.length; i++) {\n            nodesMap[nodes[i].id()] = true;\n          }\n          var roots = nodes.filter(function (ele, i) {\n            if (typeof ele === \"number\") {\n              ele = i;\n            }\n            var parent = ele.parent()[0];\n            while (parent != null) {\n              if (nodesMap[parent.id()]) {\n                return false;\n              }\n              parent = parent.parent()[0];\n            }\n            return true;\n          });\n          return roots;\n        };\n\n        // find disconnected components and create dummy nodes that connect them\n        auxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n          var queue = new LinkedList();\n          var visited = new Set();\n          var visitedTopMostNodes = [];\n          var currentNeighbor = void 0;\n          var minDegreeNode = void 0;\n          var minDegree = void 0;\n          var isConnected = false;\n          var count = 1;\n          var nodesConnectedToDummy = [];\n          var components = [];\n          var _loop = function _loop() {\n            var cmpt = cy.collection();\n            components.push(cmpt);\n            var currentNode = topMostNodes[0];\n            var childrenOfCurrentNode = cy.collection();\n            childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n            visitedTopMostNodes.push(currentNode);\n            childrenOfCurrentNode.forEach(function (node) {\n              queue.push(node);\n              visited.add(node);\n              cmpt.merge(node);\n            });\n            var _loop2 = function _loop2() {\n              currentNode = queue.shift();\n\n              // Traverse all neighbors of this node\n              var neighborNodes = cy.collection();\n              currentNode.neighborhood().nodes().forEach(function (node) {\n                if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n                  neighborNodes.merge(node);\n                }\n              });\n              for (var i = 0; i < neighborNodes.length; i++) {\n                var neighborNode = neighborNodes[i];\n                currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n                if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n                  var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n                  childrenOfNeighbor.forEach(function (node) {\n                    queue.push(node);\n                    visited.add(node);\n                    cmpt.merge(node);\n                    if (topMostNodes.has(node)) {\n                      visitedTopMostNodes.push(node);\n                    }\n                  });\n                }\n              }\n            };\n            while (queue.length != 0) {\n              _loop2();\n            }\n            cmpt.forEach(function (node) {\n              eles.intersection(node.connectedEdges()).forEach(function (e) {\n                // connectedEdges() usually cached\n                if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n                  // has() is cheap\n                  cmpt.merge(e);\n                }\n              });\n            });\n            if (visitedTopMostNodes.length == topMostNodes.length) {\n              isConnected = true;\n            }\n            if (!isConnected || isConnected && count > 1) {\n              minDegreeNode = visitedTopMostNodes[0];\n              minDegree = minDegreeNode.connectedEdges().length;\n              visitedTopMostNodes.forEach(function (node) {\n                if (node.connectedEdges().length < minDegree) {\n                  minDegree = node.connectedEdges().length;\n                  minDegreeNode = node;\n                }\n              });\n              nodesConnectedToDummy.push(minDegreeNode.id());\n              // TO DO: Check efficiency of this part\n              var temp = cy.collection();\n              temp.merge(visitedTopMostNodes[0]);\n              visitedTopMostNodes.forEach(function (node) {\n                temp.merge(node);\n              });\n              visitedTopMostNodes = [];\n              topMostNodes = topMostNodes.difference(temp);\n              count++;\n            }\n          };\n          do {\n            _loop();\n          } while (!isConnected);\n          if (dummyNodes) {\n            if (nodesConnectedToDummy.length > 0) {\n              dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n            }\n          }\n          return components;\n        };\n\n        // relocates componentResult to originalCenter if there is no fixedNodeConstraint\n        auxiliary.relocateComponent = function (originalCenter, componentResult, options) {\n          if (!options.fixedNodeConstraint) {\n            var minXCoord = Number.POSITIVE_INFINITY;\n            var maxXCoord = Number.NEGATIVE_INFINITY;\n            var minYCoord = Number.POSITIVE_INFINITY;\n            var maxYCoord = Number.NEGATIVE_INFINITY;\n            if (options.quality == \"draft\") {\n              // calculate current bounding box\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n              try {\n                for (var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var _ref = _step.value;\n                  var _ref2 = _slicedToArray(_ref, 2);\n                  var key = _ref2[0];\n                  var value = _ref2[1];\n                  var cyNode = options.cy.getElementById(key);\n                  if (cyNode) {\n                    var nodeBB = cyNode.boundingBox();\n                    var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n                    var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n                    var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n                    var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n                    if (leftX < minXCoord) minXCoord = leftX;\n                    if (rightX > maxXCoord) maxXCoord = rightX;\n                    if (topY < minYCoord) minYCoord = topY;\n                    if (bottomY > maxYCoord) maxYCoord = bottomY;\n                  }\n                }\n                // find difference between current and original center\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n              var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n              var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n              // move component to original center\n              componentResult.xCoords = componentResult.xCoords.map(function (x) {\n                return x + diffOnX;\n              });\n              componentResult.yCoords = componentResult.yCoords.map(function (y) {\n                return y + diffOnY;\n              });\n            } else {\n              // calculate current bounding box\n              Object.keys(componentResult).forEach(function (item) {\n                var node = componentResult[item];\n                var leftX = node.getRect().x;\n                var rightX = node.getRect().x + node.getRect().width;\n                var topY = node.getRect().y;\n                var bottomY = node.getRect().y + node.getRect().height;\n                if (leftX < minXCoord) minXCoord = leftX;\n                if (rightX > maxXCoord) maxXCoord = rightX;\n                if (topY < minYCoord) minYCoord = topY;\n                if (bottomY > maxYCoord) maxYCoord = bottomY;\n              });\n              // find difference between current and original center\n              var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n              var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n              // move component to original center\n              Object.keys(componentResult).forEach(function (item) {\n                var node = componentResult[item];\n                node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n              });\n            }\n          }\n        };\n        auxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n          // calculate bounds\n          var left = Number.MAX_SAFE_INTEGER;\n          var right = Number.MIN_SAFE_INTEGER;\n          var top = Number.MAX_SAFE_INTEGER;\n          var bottom = Number.MIN_SAFE_INTEGER;\n          var nodeLeft = void 0;\n          var nodeRight = void 0;\n          var nodeTop = void 0;\n          var nodeBottom = void 0;\n          var nodes = parentNode.descendants().not(\":parent\");\n          var s = nodes.length;\n          for (var i = 0; i < s; i++) {\n            var node = nodes[i];\n            nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n            nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n            nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n            nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n            if (left > nodeLeft) {\n              left = nodeLeft;\n            }\n            if (right < nodeRight) {\n              right = nodeRight;\n            }\n            if (top > nodeTop) {\n              top = nodeTop;\n            }\n            if (bottom < nodeBottom) {\n              bottom = nodeBottom;\n            }\n          }\n          var boundingBox = {};\n          boundingBox.topLeftX = left;\n          boundingBox.topLeftY = top;\n          boundingBox.width = right - left;\n          boundingBox.height = bottom - top;\n          return boundingBox;\n        };\n\n        // This function finds and returns parent nodes whose all children are hidden\n        auxiliary.calcParentsWithoutChildren = function (cy, eles) {\n          var parentsWithoutChildren = cy.collection();\n          eles.nodes(':parent').forEach(function (parent) {\n            var check = false;\n            parent.children().forEach(function (child) {\n              if (child.css('display') != 'none') {\n                check = true;\n              }\n            });\n            if (!check) {\n              parentsWithoutChildren.merge(parent);\n            }\n          });\n          return parentsWithoutChildren;\n        };\n        module.exports = auxiliary;\n\n        /***/\n      }),\n      /***/816: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        /**\n          The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n        */\n\n        var aux = __webpack_require__(548);\n        var CoSELayout = __webpack_require__(140).CoSELayout;\n        var CoSENode = __webpack_require__(140).CoSENode;\n        var PointD = __webpack_require__(140).layoutBase.PointD;\n        var DimensionD = __webpack_require__(140).layoutBase.DimensionD;\n        var LayoutConstants = __webpack_require__(140).layoutBase.LayoutConstants;\n        var FDLayoutConstants = __webpack_require__(140).layoutBase.FDLayoutConstants;\n        var CoSEConstants = __webpack_require__(140).CoSEConstants;\n\n        // main function that cose layout is processed\n        var coseLayout = function coseLayout(options, spectralResult) {\n          var cy = options.cy;\n          var eles = options.eles;\n          var nodes = eles.nodes();\n          var edges = eles.edges();\n          var nodeIndexes = void 0;\n          var xCoords = void 0;\n          var yCoords = void 0;\n          var idToLNode = {};\n          if (options.randomize) {\n            nodeIndexes = spectralResult[\"nodeIndexes\"];\n            xCoords = spectralResult[\"xCoords\"];\n            yCoords = spectralResult[\"yCoords\"];\n          }\n          var isFn = function isFn(fn) {\n            return typeof fn === 'function';\n          };\n          var optFn = function optFn(opt, ele) {\n            if (isFn(opt)) {\n              return opt(ele);\n            } else {\n              return opt;\n            }\n          };\n\n          /**** Postprocessing functions ****/\n\n          var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n\n          // transfer cytoscape nodes to cose nodes\n          var processChildrenList = function processChildrenList(parent, children, layout, options) {\n            var size = children.length;\n            for (var i = 0; i < size; i++) {\n              var theChild = children[i];\n              var children_of_children = null;\n              if (theChild.intersection(parentsWithoutChildren).length == 0) {\n                children_of_children = theChild.children();\n              }\n              var theNode = void 0;\n              var dimensions = theChild.layoutDimensions({\n                nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n              });\n              if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n                if (options.randomize) {\n                  if (!theChild.isParent()) {\n                    theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                  } else {\n                    var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n                    if (theChild.intersection(parentsWithoutChildren).length == 0) {\n                      theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n                    } else {\n                      // for the parentsWithoutChildren\n                      theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                    }\n                  }\n                } else {\n                  theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                }\n              } else {\n                theNode = parent.add(new CoSENode(this.graphManager));\n              }\n              // Attach id to the layout node and repulsion value\n              theNode.id = theChild.data(\"id\");\n              theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n              // Attach the paddings of cy node to layout node\n              theNode.paddingLeft = parseInt(theChild.css('padding'));\n              theNode.paddingTop = parseInt(theChild.css('padding'));\n              theNode.paddingRight = parseInt(theChild.css('padding'));\n              theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n              //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n              //These properties will be used while updating bounds of compounds during iterations or tiling\n              //and will be used for simple nodes while transferring final positions to cytoscape\n              if (options.nodeDimensionsIncludeLabels) {\n                theNode.labelWidth = theChild.boundingBox({\n                  includeLabels: true,\n                  includeNodes: false,\n                  includeOverlays: false\n                }).w;\n                theNode.labelHeight = theChild.boundingBox({\n                  includeLabels: true,\n                  includeNodes: false,\n                  includeOverlays: false\n                }).h;\n                theNode.labelPosVertical = theChild.css(\"text-valign\");\n                theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n              }\n\n              // Map the layout node\n              idToLNode[theChild.data(\"id\")] = theNode;\n              if (isNaN(theNode.rect.x)) {\n                theNode.rect.x = 0;\n              }\n              if (isNaN(theNode.rect.y)) {\n                theNode.rect.y = 0;\n              }\n              if (children_of_children != null && children_of_children.length > 0) {\n                var theNewGraph = void 0;\n                theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n                processChildrenList(theNewGraph, children_of_children, layout, options);\n              }\n            }\n          };\n\n          // transfer cytoscape edges to cose edges\n          var processEdges = function processEdges(layout, gm, edges) {\n            var idealLengthTotal = 0;\n            var edgeCount = 0;\n            for (var i = 0; i < edges.length; i++) {\n              var edge = edges[i];\n              var sourceNode = idToLNode[edge.data(\"source\")];\n              var targetNode = idToLNode[edge.data(\"target\")];\n              if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n                var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n                e1.id = edge.id();\n                e1.idealLength = optFn(options.idealEdgeLength, edge);\n                e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n                idealLengthTotal += e1.idealLength;\n                edgeCount++;\n              }\n            }\n            // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n            // in case there is no edge, use other options\n            if (options.idealEdgeLength != null) {\n              if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength))\n                // in case there is no edge, but option gives a value to use\n                CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else\n                // in case there is no edge and we cannot get a value from option (because it's a function)\n                CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n              // we need to update these constant values based on the ideal edge length constant\n              CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n              CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n            }\n          };\n\n          // transfer cytoscape constraints to cose layout\n          var processConstraints = function processConstraints(layout, options) {\n            // get nodes to be fixed\n            if (options.fixedNodeConstraint) {\n              layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n            }\n            // get nodes to be aligned\n            if (options.alignmentConstraint) {\n              layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n            }\n            // get nodes to be relatively placed\n            if (options.relativePlacementConstraint) {\n              layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n            }\n          };\n\n          /**** Apply postprocessing ****/\n          if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n          if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n          if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n          if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n          if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n          if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n          if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n          if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n          if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n          CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n          CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n          CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n          CoSEConstants.TILE = options.tile;\n          CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n          CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n          CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n          CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n          LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n          // This part is for debug/demo purpose\n          if (options.step == \"transformed\") {\n            CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n            CoSEConstants.ENFORCE_CONSTRAINTS = false;\n            CoSEConstants.APPLY_LAYOUT = false;\n          }\n          if (options.step == \"enforced\") {\n            CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n            CoSEConstants.ENFORCE_CONSTRAINTS = true;\n            CoSEConstants.APPLY_LAYOUT = false;\n          }\n          if (options.step == \"cose\") {\n            CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n            CoSEConstants.ENFORCE_CONSTRAINTS = false;\n            CoSEConstants.APPLY_LAYOUT = true;\n          }\n          if (options.step == \"all\") {\n            if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n            CoSEConstants.ENFORCE_CONSTRAINTS = true;\n            CoSEConstants.APPLY_LAYOUT = true;\n          }\n          if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n            CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n          } else {\n            CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n          }\n          var coseLayout = new CoSELayout();\n          var gm = coseLayout.newGraphManager();\n          processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n          processEdges(coseLayout, gm, edges);\n          processConstraints(coseLayout, options);\n          coseLayout.runLayout();\n          return idToLNode;\n        };\n        module.exports = {\n          coseLayout: coseLayout\n        };\n\n        /***/\n      }),\n      /***/212: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var _createClass = function () {\n          function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n          return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n          };\n        }();\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        /**\n          The implementation of the fcose layout algorithm\n        */\n\n        var assign = __webpack_require__(658);\n        var aux = __webpack_require__(548);\n        var _require = __webpack_require__(657),\n          spectralLayout = _require.spectralLayout;\n        var _require2 = __webpack_require__(816),\n          coseLayout = _require2.coseLayout;\n        var defaults = Object.freeze({\n          // 'draft', 'default' or 'proof' \n          // - 'draft' only applies spectral layout \n          // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n          // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n          quality: \"default\",\n          // Use random node positions at beginning of layout\n          // if this is set to false, then quality option must be \"proof\"\n          randomize: true,\n          // Whether or not to animate the layout\n          animate: true,\n          // Duration of animation in ms, if enabled\n          animationDuration: 1000,\n          // Easing of animation, if enabled\n          animationEasing: undefined,\n          // Fit the viewport to the repositioned nodes\n          fit: true,\n          // Padding around layout\n          padding: 30,\n          // Whether to include labels in node dimensions. Valid in \"proof\" quality\n          nodeDimensionsIncludeLabels: false,\n          // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n          uniformNodeDimensions: false,\n          // Whether to pack disconnected components - valid only if randomize: true\n          packComponents: true,\n          // Layout step - all, transformed, enforced, cose - for debug purpose only\n          step: \"all\",\n          /* spectral layout options */\n\n          // False for random, true for greedy\n          samplingType: true,\n          // Sample size to construct distance matrix\n          sampleSize: 25,\n          // Separation amount between nodes\n          nodeSeparation: 75,\n          // Power iteration tolerance\n          piTol: 0.0000001,\n          /* CoSE layout options */\n\n          // Node repulsion (non overlapping) multiplier\n          nodeRepulsion: function nodeRepulsion(node) {\n            return 4500;\n          },\n          // Ideal edge (non nested) length\n          idealEdgeLength: function idealEdgeLength(edge) {\n            return 50;\n          },\n          // Divisor to compute edge forces\n          edgeElasticity: function edgeElasticity(edge) {\n            return 0.45;\n          },\n          // Nesting factor (multiplier) to compute ideal edge length for nested edges\n          nestingFactor: 0.1,\n          // Gravity force (constant)\n          gravity: 0.25,\n          // Maximum number of iterations to perform\n          numIter: 2500,\n          // For enabling tiling\n          tile: true,\n          // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n          // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n          tilingCompareBy: undefined,\n          // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n          tilingPaddingVertical: 10,\n          // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n          tilingPaddingHorizontal: 10,\n          // Gravity range (constant) for compounds\n          gravityRangeCompound: 1.5,\n          // Gravity force (constant) for compounds\n          gravityCompound: 1.0,\n          // Gravity range (constant)\n          gravityRange: 3.8,\n          // Initial cooling factor for incremental layout  \n          initialEnergyOnIncremental: 0.3,\n          /* constraint options */\n\n          // Fix required nodes to predefined positions\n          // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n          fixedNodeConstraint: undefined,\n          // Align required nodes in vertical/horizontal direction\n          // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n          alignmentConstraint: undefined,\n          // Place two nodes relatively in vertical/horizontal direction \n          // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n          relativePlacementConstraint: undefined,\n          /* layout event callbacks */\n          ready: function ready() {},\n          // on layoutready\n          stop: function stop() {} // on layoutstop\n        });\n        var Layout = function () {\n          function Layout(options) {\n            _classCallCheck(this, Layout);\n            this.options = assign({}, defaults, options);\n          }\n          _createClass(Layout, [{\n            key: 'run',\n            value: function run() {\n              var layout = this;\n              var options = this.options;\n              var cy = options.cy;\n              var eles = options.eles;\n              var spectralResult = [];\n              var xCoords = void 0;\n              var yCoords = void 0;\n              var coseResult = [];\n              var components = void 0;\n              var componentCenters = [];\n\n              // basic validity check for constraint inputs \n              if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n                options.fixedNodeConstraint = undefined;\n              }\n              if (options.alignmentConstraint) {\n                if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n                  options.alignmentConstraint.vertical = undefined;\n                }\n                if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n                  options.alignmentConstraint.horizontal = undefined;\n                }\n              }\n              if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n                options.relativePlacementConstraint = undefined;\n              }\n\n              // if any constraint exists, set some options\n              var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n              if (constraintExist) {\n                // constraints work with these options\n                options.tile = false;\n                options.packComponents = false;\n              }\n\n              // decide component packing is enabled or not\n              var layUtil = void 0;\n              var packingEnabled = false;\n              if (cy.layoutUtilities && options.packComponents) {\n                layUtil = cy.layoutUtilities(\"get\");\n                if (!layUtil) layUtil = cy.layoutUtilities();\n                packingEnabled = true;\n              }\n              if (eles.nodes().length > 0) {\n                // if packing is not enabled, perform layout on the whole graph\n                if (!packingEnabled) {\n                  // store component center\n                  var boundingBox = options.eles.boundingBox();\n                  componentCenters.push({\n                    x: boundingBox.x1 + boundingBox.w / 2,\n                    y: boundingBox.y1 + boundingBox.h / 2\n                  });\n                  // apply spectral layout\n                  if (options.randomize) {\n                    var result = spectralLayout(options);\n                    spectralResult.push(result);\n                  }\n                  // apply cose layout as postprocessing\n                  if (options.quality == \"default\" || options.quality == \"proof\") {\n                    coseResult.push(coseLayout(options, spectralResult[0]));\n                    aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position\n                  } else {\n                    aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position\n                  }\n                } else {\n                  // packing is enabled\n                  var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n                  components = aux.connectComponents(cy, options.eles, topMostNodes);\n                  // store component centers\n                  components.forEach(function (component) {\n                    var boundingBox = component.boundingBox();\n                    componentCenters.push({\n                      x: boundingBox.x1 + boundingBox.w / 2,\n                      y: boundingBox.y1 + boundingBox.h / 2\n                    });\n                  });\n\n                  //send each component to spectral layout if randomized\n                  if (options.randomize) {\n                    components.forEach(function (component) {\n                      options.eles = component;\n                      spectralResult.push(spectralLayout(options));\n                    });\n                  }\n                  if (options.quality == \"default\" || options.quality == \"proof\") {\n                    var toBeTiledNodes = cy.collection();\n                    if (options.tile) {\n                      // behave nodes to be tiled as one component\n                      var nodeIndexes = new Map();\n                      var _xCoords = [];\n                      var _yCoords = [];\n                      var count = 0;\n                      var tempSpectralResult = {\n                        nodeIndexes: nodeIndexes,\n                        xCoords: _xCoords,\n                        yCoords: _yCoords\n                      };\n                      var indexesToBeDeleted = [];\n                      components.forEach(function (component, index) {\n                        if (component.edges().length == 0) {\n                          component.nodes().forEach(function (node, i) {\n                            toBeTiledNodes.merge(component.nodes()[i]);\n                            if (!node.isParent()) {\n                              tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                              tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                              tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                            }\n                          });\n                          indexesToBeDeleted.push(index);\n                        }\n                      });\n                      if (toBeTiledNodes.length > 1) {\n                        var _boundingBox = toBeTiledNodes.boundingBox();\n                        componentCenters.push({\n                          x: _boundingBox.x1 + _boundingBox.w / 2,\n                          y: _boundingBox.y1 + _boundingBox.h / 2\n                        });\n                        components.push(toBeTiledNodes);\n                        spectralResult.push(tempSpectralResult);\n                        for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                          components.splice(indexesToBeDeleted[i], 1);\n                          spectralResult.splice(indexesToBeDeleted[i], 1);\n                          componentCenters.splice(indexesToBeDeleted[i], 1);\n                        }\n                        ;\n                      }\n                    }\n                    components.forEach(function (component, index) {\n                      // send each component to cose layout\n                      options.eles = component;\n                      coseResult.push(coseLayout(options, spectralResult[index]));\n                      aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position\n                    });\n                  } else {\n                    components.forEach(function (component, index) {\n                      aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position\n                    });\n                  }\n\n                  // packing\n                  var componentsEvaluated = new Set();\n                  if (components.length > 1) {\n                    var subgraphs = [];\n                    var hiddenEles = eles.filter(function (ele) {\n                      return ele.css('display') == 'none';\n                    });\n                    components.forEach(function (component, index) {\n                      var nodeIndexes = void 0;\n                      if (options.quality == \"draft\") {\n                        nodeIndexes = spectralResult[index].nodeIndexes;\n                      }\n                      if (component.nodes().not(hiddenEles).length > 0) {\n                        var subgraph = {};\n                        subgraph.edges = [];\n                        subgraph.nodes = [];\n                        var nodeIndex = void 0;\n                        component.nodes().not(hiddenEles).forEach(function (node) {\n                          if (options.quality == \"draft\") {\n                            if (!node.isParent()) {\n                              nodeIndex = nodeIndexes.get(node.id());\n                              subgraph.nodes.push({\n                                x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2,\n                                y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2,\n                                width: node.boundingbox().w,\n                                height: node.boundingbox().h\n                              });\n                            } else {\n                              var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                              subgraph.nodes.push({\n                                x: parentInfo.topLeftX,\n                                y: parentInfo.topLeftY,\n                                width: parentInfo.width,\n                                height: parentInfo.height\n                              });\n                            }\n                          } else {\n                            if (coseResult[index][node.id()]) {\n                              subgraph.nodes.push({\n                                x: coseResult[index][node.id()].getLeft(),\n                                y: coseResult[index][node.id()].getTop(),\n                                width: coseResult[index][node.id()].getWidth(),\n                                height: coseResult[index][node.id()].getHeight()\n                              });\n                            }\n                          }\n                        });\n                        component.edges().forEach(function (edge) {\n                          var source = edge.source();\n                          var target = edge.target();\n                          if (source.css(\"display\") != \"none\" && target.css(\"display\") != \"none\") {\n                            if (options.quality == \"draft\") {\n                              var sourceNodeIndex = nodeIndexes.get(source.id());\n                              var targetNodeIndex = nodeIndexes.get(target.id());\n                              var sourceCenter = [];\n                              var targetCenter = [];\n                              if (source.isParent()) {\n                                var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                                sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                                sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                              } else {\n                                sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                                sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                              }\n                              if (target.isParent()) {\n                                var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                                targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                                targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                              } else {\n                                targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                                targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                              }\n                              subgraph.edges.push({\n                                startX: sourceCenter[0],\n                                startY: sourceCenter[1],\n                                endX: targetCenter[0],\n                                endY: targetCenter[1]\n                              });\n                            } else {\n                              if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                                subgraph.edges.push({\n                                  startX: coseResult[index][source.id()].getCenterX(),\n                                  startY: coseResult[index][source.id()].getCenterY(),\n                                  endX: coseResult[index][target.id()].getCenterX(),\n                                  endY: coseResult[index][target.id()].getCenterY()\n                                });\n                              }\n                            }\n                          }\n                        });\n                        if (subgraph.nodes.length > 0) {\n                          subgraphs.push(subgraph);\n                          componentsEvaluated.add(index);\n                        }\n                      }\n                    });\n                    var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n                    if (options.quality == \"draft\") {\n                      spectralResult.forEach(function (result, index) {\n                        var newXCoords = result.xCoords.map(function (x) {\n                          return x + shiftResult[index].dx;\n                        });\n                        var newYCoords = result.yCoords.map(function (y) {\n                          return y + shiftResult[index].dy;\n                        });\n                        result.xCoords = newXCoords;\n                        result.yCoords = newYCoords;\n                      });\n                    } else {\n                      var _count = 0;\n                      componentsEvaluated.forEach(function (index) {\n                        Object.keys(coseResult[index]).forEach(function (item) {\n                          var nodeRectangle = coseResult[index][item];\n                          nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                        });\n                        _count++;\n                      });\n                    }\n                  }\n                }\n              }\n\n              // get each element's calculated position\n              var getPositions = function getPositions(ele, i) {\n                if (options.quality == \"default\" || options.quality == \"proof\") {\n                  if (typeof ele === \"number\") {\n                    ele = i;\n                  }\n                  var pos = void 0;\n                  var node = void 0;\n                  var theId = ele.data('id');\n                  coseResult.forEach(function (result) {\n                    if (theId in result) {\n                      pos = {\n                        x: result[theId].getRect().getCenterX(),\n                        y: result[theId].getRect().getCenterY()\n                      };\n                      node = result[theId];\n                    }\n                  });\n                  if (options.nodeDimensionsIncludeLabels) {\n                    if (node.labelWidth) {\n                      if (node.labelPosHorizontal == \"left\") {\n                        pos.x += node.labelWidth / 2;\n                      } else if (node.labelPosHorizontal == \"right\") {\n                        pos.x -= node.labelWidth / 2;\n                      }\n                    }\n                    if (node.labelHeight) {\n                      if (node.labelPosVertical == \"top\") {\n                        pos.y += node.labelHeight / 2;\n                      } else if (node.labelPosVertical == \"bottom\") {\n                        pos.y -= node.labelHeight / 2;\n                      }\n                    }\n                  }\n                  if (pos == undefined) pos = {\n                    x: ele.position(\"x\"),\n                    y: ele.position(\"y\")\n                  };\n                  return {\n                    x: pos.x,\n                    y: pos.y\n                  };\n                } else {\n                  var _pos = void 0;\n                  spectralResult.forEach(function (result) {\n                    var index = result.nodeIndexes.get(ele.id());\n                    if (index != undefined) {\n                      _pos = {\n                        x: result.xCoords[index],\n                        y: result.yCoords[index]\n                      };\n                    }\n                  });\n                  if (_pos == undefined) _pos = {\n                    x: ele.position(\"x\"),\n                    y: ele.position(\"y\")\n                  };\n                  return {\n                    x: _pos.x,\n                    y: _pos.y\n                  };\n                }\n              };\n\n              // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n              if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n                // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n                var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n                var _hiddenEles = eles.filter(function (ele) {\n                  return ele.css('display') == 'none';\n                });\n                options.eles = eles.not(_hiddenEles);\n                eles.nodes().not(\":parent\").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n                if (parentsWithoutChildren.length > 0) {\n                  parentsWithoutChildren.forEach(function (ele) {\n                    ele.position(getPositions(ele));\n                  });\n                }\n              } else {\n                console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n              }\n            }\n          }]);\n          return Layout;\n        }();\n        module.exports = Layout;\n\n        /***/\n      }),\n      /***/657: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        /**\n          The implementation of the spectral layout that is the first part of the fcose layout algorithm\n        */\n\n        var aux = __webpack_require__(548);\n        var Matrix = __webpack_require__(140).layoutBase.Matrix;\n        var SVD = __webpack_require__(140).layoutBase.SVD;\n\n        // main function that spectral layout is processed\n        var spectralLayout = function spectralLayout(options) {\n          var cy = options.cy;\n          var eles = options.eles;\n          var nodes = eles.nodes();\n          var parentNodes = eles.nodes(\":parent\");\n          var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n          var nodeIndexes = new Map(); // map to keep indexes to nodes\n          var parentChildMap = new Map(); // mapping btw. compound and its representative node \n          var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n          var xCoords = [];\n          var yCoords = [];\n          var samplesColumn = []; // sampled vertices\n          var minDistancesColumn = [];\n          var C = []; // column sampling matrix\n          var PHI = []; // intersection of column and row sampling matrices \n          var INV = []; // inverse of PHI \n\n          var firstSample = void 0; // the first sampled node\n          var nodeSize = void 0;\n          var infinity = 100000000;\n          var small = 0.000000001;\n          var piTol = options.piTol;\n          var samplingType = options.samplingType; // false for random, true for greedy\n          var nodeSeparation = options.nodeSeparation;\n          var sampleSize = void 0;\n\n          /**** Spectral-preprocessing functions ****/\n\n          /**** Spectral layout functions ****/\n\n          // determine which columns to be sampled\n          var randomSampleCR = function randomSampleCR() {\n            var sample = 0;\n            var count = 0;\n            var flag = false;\n            while (count < sampleSize) {\n              sample = Math.floor(Math.random() * nodeSize);\n              flag = false;\n              for (var i = 0; i < count; i++) {\n                if (samplesColumn[i] == sample) {\n                  flag = true;\n                  break;\n                }\n              }\n              if (!flag) {\n                samplesColumn[count] = sample;\n                count++;\n              } else {\n                continue;\n              }\n            }\n          };\n\n          // takes the index of the node(pivot) to initiate BFS as a parameter\n          var BFS = function BFS(pivot, index, samplingMethod) {\n            var path = []; // the front of the path\n            var front = 0; // the back of the path\n            var back = 0;\n            var current = 0;\n            var temp = void 0;\n            var distance = [];\n            var max_dist = 0; // the furthest node to be returned\n            var max_ind = 1;\n            for (var i = 0; i < nodeSize; i++) {\n              distance[i] = infinity;\n            }\n            path[back] = pivot;\n            distance[pivot] = 0;\n            while (back >= front) {\n              current = path[front++];\n              var neighbors = allNodesNeighborhood[current];\n              for (var _i = 0; _i < neighbors.length; _i++) {\n                temp = nodeIndexes.get(neighbors[_i]);\n                if (distance[temp] == infinity) {\n                  distance[temp] = distance[current] + 1;\n                  path[++back] = temp;\n                }\n              }\n              C[current][index] = distance[current] * nodeSeparation;\n            }\n            if (samplingMethod) {\n              for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n                if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n              }\n              for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n                if (minDistancesColumn[_i3] > max_dist) {\n                  max_dist = minDistancesColumn[_i3];\n                  max_ind = _i3;\n                }\n              }\n            }\n            return max_ind;\n          };\n\n          // apply BFS to all nodes or selected samples\n          var allBFS = function allBFS(samplingMethod) {\n            var sample = void 0;\n            if (!samplingMethod) {\n              randomSampleCR();\n\n              // call BFS\n              for (var i = 0; i < sampleSize; i++) {\n                BFS(samplesColumn[i], i, samplingMethod, false);\n              }\n            } else {\n              sample = Math.floor(Math.random() * nodeSize);\n              firstSample = sample;\n              for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n                minDistancesColumn[_i4] = infinity;\n              }\n              for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n                samplesColumn[_i5] = sample;\n                sample = BFS(sample, _i5, samplingMethod);\n              }\n            }\n\n            // form the squared distances for C\n            for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n              for (var j = 0; j < sampleSize; j++) {\n                C[_i6][j] *= C[_i6][j];\n              }\n            }\n\n            // form PHI\n            for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n              PHI[_i7] = [];\n            }\n            for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n              for (var _j = 0; _j < sampleSize; _j++) {\n                PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n              }\n            }\n          };\n\n          // perform the SVD algorithm and apply a regularization step\n          var sample = function sample() {\n            var SVDResult = SVD.svd(PHI);\n            var a_q = SVDResult.S;\n            var a_u = SVDResult.U;\n            var a_v = SVDResult.V;\n            var max_s = a_q[0] * a_q[0] * a_q[0];\n            var a_Sig = [];\n\n            //  regularization\n            for (var i = 0; i < sampleSize; i++) {\n              a_Sig[i] = [];\n              for (var j = 0; j < sampleSize; j++) {\n                a_Sig[i][j] = 0;\n                if (i == j) {\n                  a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n                }\n              }\n            }\n            INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n          };\n\n          // calculate final coordinates \n          var powerIteration = function powerIteration() {\n            // two largest eigenvalues\n            var theta1 = void 0;\n            var theta2 = void 0;\n\n            // initial guesses for eigenvectors\n            var Y1 = [];\n            var Y2 = [];\n            var V1 = [];\n            var V2 = [];\n            for (var i = 0; i < nodeSize; i++) {\n              Y1[i] = Math.random();\n              Y2[i] = Math.random();\n            }\n            Y1 = Matrix.normalize(Y1);\n            Y2 = Matrix.normalize(Y2);\n            var count = 0;\n            // to keep track of the improvement ratio in power iteration\n            var current = small;\n            var previous = small;\n            var temp = void 0;\n            while (true) {\n              count++;\n              for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n                V1[_i9] = Y1[_i9];\n              }\n              Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n              theta1 = Matrix.dotProduct(V1, Y1);\n              Y1 = Matrix.normalize(Y1);\n              current = Matrix.dotProduct(V1, Y1);\n              temp = Math.abs(current / previous);\n              if (temp <= 1 + piTol && temp >= 1) {\n                break;\n              }\n              previous = current;\n            }\n            for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n              V1[_i10] = Y1[_i10];\n            }\n            count = 0;\n            previous = small;\n            while (true) {\n              count++;\n              for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n                V2[_i11] = Y2[_i11];\n              }\n              V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n              Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n              theta2 = Matrix.dotProduct(V2, Y2);\n              Y2 = Matrix.normalize(Y2);\n              current = Matrix.dotProduct(V2, Y2);\n              temp = Math.abs(current / previous);\n              if (temp <= 1 + piTol && temp >= 1) {\n                break;\n              }\n              previous = current;\n            }\n            for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n              V2[_i12] = Y2[_i12];\n            }\n\n            // theta1 now contains dominant eigenvalue\n            // theta2 now contains the second-largest eigenvalue\n            // V1 now contains theta1's eigenvector\n            // V2 now contains theta2's eigenvector\n\n            //populate the two vectors\n            xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n            yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n          };\n\n          /**** Preparation for spectral layout (Preprocessing) ****/\n\n          // connect disconnected components (first top level, then inside of each compound node)\n          aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n          parentNodes.forEach(function (ele) {\n            aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n          });\n\n          // assign indexes to nodes (first real, then dummy nodes)\n          var index = 0;\n          for (var i = 0; i < nodes.length; i++) {\n            if (!nodes[i].isParent()) {\n              nodeIndexes.set(nodes[i].id(), index++);\n            }\n          }\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n          try {\n            for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var key = _step.value;\n              nodeIndexes.set(key, index++);\n            }\n\n            // instantiate the neighborhood matrix\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n          for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n            allNodesNeighborhood[_i13] = [];\n          }\n\n          // form a parent-child map to keep representative node of each compound node  \n          parentNodes.forEach(function (ele) {\n            var children = ele.children().intersection(eles);\n\n            //      let random = 0;\n            while (children.nodes(\":childless\").length == 0) {\n              //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n              children = children.nodes()[0].children().intersection(eles);\n            }\n            //  select the representative node - we can apply different methods here\n            //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n            var index = 0;\n            var min = children.nodes(\":childless\")[0].connectedEdges().length;\n            children.nodes(\":childless\").forEach(function (ele2, i) {\n              if (ele2.connectedEdges().length < min) {\n                min = ele2.connectedEdges().length;\n                index = i;\n              }\n            });\n            parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n          });\n\n          // add neighborhood relations (first real, then dummy nodes)\n          nodes.forEach(function (ele) {\n            var eleIndex = void 0;\n            if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n            ele.neighborhood().nodes().forEach(function (node) {\n              if (eles.intersection(ele.edgesWith(node)).length > 0) {\n                if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n              }\n            });\n          });\n          var _loop = function _loop(_key) {\n            var eleIndex = nodeIndexes.get(_key);\n            var disconnectedId = void 0;\n            dummyNodes.get(_key).forEach(function (id) {\n              if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n              allNodesNeighborhood[eleIndex].push(disconnectedId);\n              allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n            });\n          };\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n          try {\n            for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var _key = _step2.value;\n              _loop(_key);\n            }\n\n            // nodeSize now only considers the size of transformed graph\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n          nodeSize = nodeIndexes.size;\n          var spectralResult = void 0;\n\n          // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n          // So skip spectral and layout the graph with cose\n          if (nodeSize > 2) {\n            // if # of nodes in transformed graph is smaller than sample size,\n            // then use # of nodes as sample size\n            sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n            // instantiates the partial matrices that will be used in spectral layout\n            for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n              C[_i14] = [];\n            }\n            for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n              INV[_i15] = [];\n            }\n\n            /**** Apply spectral layout ****/\n\n            if (options.quality == \"draft\" || options.step == \"all\") {\n              allBFS(samplingType);\n              sample();\n              powerIteration();\n              spectralResult = {\n                nodeIndexes: nodeIndexes,\n                xCoords: xCoords,\n                yCoords: yCoords\n              };\n            } else {\n              nodeIndexes.forEach(function (value, key) {\n                xCoords.push(cy.getElementById(key).position(\"x\"));\n                yCoords.push(cy.getElementById(key).position(\"y\"));\n              });\n              spectralResult = {\n                nodeIndexes: nodeIndexes,\n                xCoords: xCoords,\n                yCoords: yCoords\n              };\n            }\n            return spectralResult;\n          } else {\n            var iterator = nodeIndexes.keys();\n            var firstNode = cy.getElementById(iterator.next().value);\n            var firstNodePos = firstNode.position();\n            var firstNodeWidth = firstNode.outerWidth();\n            xCoords.push(firstNodePos.x);\n            yCoords.push(firstNodePos.y);\n            if (nodeSize == 2) {\n              var secondNode = cy.getElementById(iterator.next().value);\n              var secondNodeWidth = secondNode.outerWidth();\n              xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n              yCoords.push(firstNodePos.y);\n            }\n            spectralResult = {\n              nodeIndexes: nodeIndexes,\n              xCoords: xCoords,\n              yCoords: yCoords\n            };\n            return spectralResult;\n          }\n        };\n        module.exports = {\n          spectralLayout: spectralLayout\n        };\n\n        /***/\n      }),\n      /***/579: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var impl = __webpack_require__(212);\n\n        // registers the extension on a cytoscape lib ref\n        var register = function register(cytoscape) {\n          if (!cytoscape) {\n            return;\n          } // can't register if cytoscape unspecified\n\n          cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n        };\n        if (typeof cytoscape !== 'undefined') {\n          // expose to global cytoscape (i.e. window.cytoscape)\n          register(cytoscape);\n        }\n        module.exports = register;\n\n        /***/\n      }),\n      /***/140: (/***/module => {\n        module.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n\n        /***/\n      })\n\n      /******/\n    };\n    /************************************************************************/\n    /******/ // The module cache\n    /******/\n    var __webpack_module_cache__ = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId) {\n      /******/ // Check if module is in cache\n      /******/var cachedModule = __webpack_module_cache__[moduleId];\n      /******/\n      if (cachedModule !== undefined) {\n        /******/return cachedModule.exports;\n        /******/\n      }\n      /******/ // Create a new module (and put it into the cache)\n      /******/\n      var module = __webpack_module_cache__[moduleId] = {\n        /******/ // no module.id needed\n        /******/ // no module.loaded needed\n        /******/exports: {}\n        /******/\n      };\n      /******/\n      /******/ // Execute the module function\n      /******/\n      __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n      /******/\n      /******/ // Return the exports of the module\n      /******/\n      return module.exports;\n      /******/\n    }\n    /******/\n    /************************************************************************/\n    /******/\n    /******/ // startup\n    /******/ // Load entry module and return exports\n    /******/ // This entry module is referenced by other modules so it can't be inlined\n    /******/\n    var __webpack_exports__ = __webpack_require__(579);\n    /******/\n    /******/\n    return __webpack_exports__;\n    /******/\n  })();\n});","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","__WEBPACK_EXTERNAL_MODULE__140__","__webpack_modules__","Object","assign","bind","tgt","_len","arguments","length","srcs","Array","_key","forEach","src","keys","k","__unused_webpack_exports","__webpack_require__","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","err","isArray","TypeError","LinkedList","layoutBase","auxiliary","getTopMostNodes","nodes","nodesMap","id","roots","filter","ele","parent","connectComponents","cy","eles","topMostNodes","dummyNodes","queue","visited","Set","visitedTopMostNodes","currentNeighbor","minDegreeNode","minDegree","isConnected","count","nodesConnectedToDummy","components","_loop","cmpt","collection","currentNode","childrenOfCurrentNode","merge","descendants","intersection","node","add","_loop2","shift","neighborNodes","neighborhood","edgesWith","neighborNode","union","ancestors","has","childrenOfNeighbor","connectedEdges","e","source","target","temp","difference","set","size","relocateComponent","originalCenter","componentResult","options","fixedNodeConstraint","minXCoord","Number","POSITIVE_INFINITY","maxXCoord","NEGATIVE_INFINITY","minYCoord","maxYCoord","quality","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","nodeIndexes","_step","_ref","_ref2","key","cyNode","getElementById","nodeBB","boundingBox","leftX","xCoords","w","rightX","topY","yCoords","h","bottomY","return","diffOnX","x","diffOnY","y","map","item","getRect","width","height","_diffOnX","_diffOnY","setCenter","getCenterX","getCenterY","calcBoundingBox","parentNode","left","MAX_SAFE_INTEGER","right","MIN_SAFE_INTEGER","top","bottom","nodeLeft","nodeRight","nodeTop","nodeBottom","not","s","get","topLeftX","topLeftY","calcParentsWithoutChildren","parentsWithoutChildren","check","children","child","css","aux","CoSELayout","CoSENode","PointD","DimensionD","LayoutConstants","FDLayoutConstants","CoSEConstants","coseLayout","spectralResult","edges","idToLNode","randomize","isFn","fn","optFn","opt","processChildrenList","layout","theChild","children_of_children","theNode","dimensions","layoutDimensions","nodeDimensionsIncludeLabels","outerWidth","outerHeight","isParent","graphManager","parseFloat","parentInfo","position","data","nodeRepulsion","paddingLeft","parseInt","paddingTop","paddingRight","paddingBottom","labelWidth","includeLabels","includeNodes","includeOverlays","labelHeight","labelPosVertical","labelPosHorizontal","isNaN","rect","theNewGraph","getGraphManager","newGraph","processEdges","gm","idealLengthTotal","edgeCount","edge","sourceNode","targetNode","getEdgesBetween","e1","newEdge","idealLength","idealEdgeLength","edgeElasticity","DEFAULT_EDGE_LENGTH","MIN_REPULSION_DIST","DEFAULT_RADIAL_SEPARATION","processConstraints","constraints","alignmentConstraint","relativePlacementConstraint","nestingFactor","PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR","gravity","DEFAULT_GRAVITY_STRENGTH","numIter","MAX_ITERATIONS","gravityRange","DEFAULT_GRAVITY_RANGE_FACTOR","gravityCompound","DEFAULT_COMPOUND_GRAVITY_STRENGTH","gravityRangeCompound","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","initialEnergyOnIncremental","DEFAULT_COOLING_FACTOR_INCREMENTAL","tilingCompareBy","TILING_COMPARE_BY","QUALITY","NODE_DIMENSIONS_INCLUDE_LABELS","DEFAULT_INCREMENTAL","ANIMATE","animate","TILE","tile","TILING_PADDING_VERTICAL","tilingPaddingVertical","call","TILING_PADDING_HORIZONTAL","tilingPaddingHorizontal","PURE_INCREMENTAL","DEFAULT_UNIFORM_LEAF_NODE_SIZES","uniformNodeDimensions","step","TRANSFORM_ON_CONSTRAINT_HANDLING","ENFORCE_CONSTRAINTS","APPLY_LAYOUT","TREE_REDUCTION_ON_INCREMENTAL","newGraphManager","addRoot","runLayout","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","defineProperty","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","_require","spectralLayout","_require2","defaults","freeze","animationDuration","animationEasing","fit","padding","packComponents","samplingType","sampleSize","nodeSeparation","piTol","ready","stop","Layout","run","coseResult","componentCenters","vertical","horizontal","constraintExist","layUtil","packingEnabled","layoutUtilities","x1","y1","result","component","toBeTiledNodes","Map","_xCoords","_yCoords","tempSpectralResult","indexesToBeDeleted","index","_boundingBox","splice","componentsEvaluated","subgraphs","hiddenEles","subgraph","nodeIndex","boundingbox","getLeft","getTop","getWidth","getHeight","sourceNodeIndex","targetNodeIndex","sourceCenter","targetCenter","_parentInfo","startX","startY","endX","endY","shiftResult","shifts","newXCoords","dx","newYCoords","dy","_count","nodeRectangle","getPositions","pos","theId","_pos","_hiddenEles","layoutPositions","console","log","Matrix","SVD","parentNodes","parentChildMap","allNodesNeighborhood","samplesColumn","minDistancesColumn","C","PHI","INV","firstSample","nodeSize","infinity","small","randomSampleCR","sample","flag","Math","floor","random","BFS","pivot","samplingMethod","path","front","back","current","distance","max_dist","max_ind","neighbors","_i2","_i3","allBFS","_i4","_i5","_i6","j","_i7","_i8","_j","SVDResult","svd","a_q","S","a_u","U","a_v","V","max_s","a_Sig","multMat","transpose","powerIteration","theta1","theta2","Y1","Y2","V1","V2","normalize","previous","_i9","multGamma","multL","dotProduct","abs","_i10","_i11","minusOp","multCons","_i12","sqrt","_i13","min","ele2","eleIndex","disconnectedId","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_i14","_i15","firstNode","firstNodePos","firstNodeWidth","secondNode","secondNodeWidth","impl","register","cytoscape","__webpack_module_cache__","moduleId","cachedModule","__webpack_exports__"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/cytoscape-fcose/cytoscape-fcose.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"cose-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"cose-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cytoscapeFcose\"] = factory(require(\"cose-base\"));\n\telse\n\t\troot[\"cytoscapeFcose\"] = factory(root[\"coseBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__140__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 658:\n/***/ ((module) => {\n\n\n\n// Simple, internal Object.assign() polyfill for options objects etc.\n\nmodule.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.forEach(function (src) {\n    Object.keys(src).forEach(function (k) {\n      return tgt[k] = src[k];\n    });\n  });\n\n  return tgt;\n};\n\n/***/ }),\n\n/***/ 548:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/*\n * Auxiliary functions\n */\n\nvar LinkedList = __webpack_require__(140).layoutBase.LinkedList;\n\nvar auxiliary = {};\n\n// get the top most nodes\nauxiliary.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n// find disconnected components and create dummy nodes that connect them\nauxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n  var queue = new LinkedList();\n  var visited = new Set();\n  var visitedTopMostNodes = [];\n  var currentNeighbor = void 0;\n  var minDegreeNode = void 0;\n  var minDegree = void 0;\n\n  var isConnected = false;\n  var count = 1;\n  var nodesConnectedToDummy = [];\n  var components = [];\n\n  var _loop = function _loop() {\n    var cmpt = cy.collection();\n    components.push(cmpt);\n\n    var currentNode = topMostNodes[0];\n    var childrenOfCurrentNode = cy.collection();\n    childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n    visitedTopMostNodes.push(currentNode);\n\n    childrenOfCurrentNode.forEach(function (node) {\n      queue.push(node);\n      visited.add(node);\n      cmpt.merge(node);\n    });\n\n    var _loop2 = function _loop2() {\n      currentNode = queue.shift();\n\n      // Traverse all neighbors of this node\n      var neighborNodes = cy.collection();\n      currentNode.neighborhood().nodes().forEach(function (node) {\n        if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n          neighborNodes.merge(node);\n        }\n      });\n\n      for (var i = 0; i < neighborNodes.length; i++) {\n        var neighborNode = neighborNodes[i];\n        currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n        if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n          var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n\n          childrenOfNeighbor.forEach(function (node) {\n            queue.push(node);\n            visited.add(node);\n            cmpt.merge(node);\n            if (topMostNodes.has(node)) {\n              visitedTopMostNodes.push(node);\n            }\n          });\n        }\n      }\n    };\n\n    while (queue.length != 0) {\n      _loop2();\n    }\n\n    cmpt.forEach(function (node) {\n      eles.intersection(node.connectedEdges()).forEach(function (e) {\n        // connectedEdges() usually cached\n        if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n          // has() is cheap\n          cmpt.merge(e);\n        }\n      });\n    });\n\n    if (visitedTopMostNodes.length == topMostNodes.length) {\n      isConnected = true;\n    }\n\n    if (!isConnected || isConnected && count > 1) {\n      minDegreeNode = visitedTopMostNodes[0];\n      minDegree = minDegreeNode.connectedEdges().length;\n      visitedTopMostNodes.forEach(function (node) {\n        if (node.connectedEdges().length < minDegree) {\n          minDegree = node.connectedEdges().length;\n          minDegreeNode = node;\n        }\n      });\n      nodesConnectedToDummy.push(minDegreeNode.id());\n      // TO DO: Check efficiency of this part\n      var temp = cy.collection();\n      temp.merge(visitedTopMostNodes[0]);\n      visitedTopMostNodes.forEach(function (node) {\n        temp.merge(node);\n      });\n      visitedTopMostNodes = [];\n      topMostNodes = topMostNodes.difference(temp);\n      count++;\n    }\n  };\n\n  do {\n    _loop();\n  } while (!isConnected);\n\n  if (dummyNodes) {\n    if (nodesConnectedToDummy.length > 0) {\n      dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n    }\n  }\n  return components;\n};\n\n// relocates componentResult to originalCenter if there is no fixedNodeConstraint\nauxiliary.relocateComponent = function (originalCenter, componentResult, options) {\n  if (!options.fixedNodeConstraint) {\n    var minXCoord = Number.POSITIVE_INFINITY;\n    var maxXCoord = Number.NEGATIVE_INFINITY;\n    var minYCoord = Number.POSITIVE_INFINITY;\n    var maxYCoord = Number.NEGATIVE_INFINITY;\n    if (options.quality == \"draft\") {\n      // calculate current bounding box\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref = _step.value;\n\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          var key = _ref2[0];\n          var value = _ref2[1];\n\n          var cyNode = options.cy.getElementById(key);\n          if (cyNode) {\n            var nodeBB = cyNode.boundingBox();\n            var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n            var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n            var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n            var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n\n            if (leftX < minXCoord) minXCoord = leftX;\n            if (rightX > maxXCoord) maxXCoord = rightX;\n            if (topY < minYCoord) minYCoord = topY;\n            if (bottomY > maxYCoord) maxYCoord = bottomY;\n          }\n        }\n        // find difference between current and original center\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      componentResult.xCoords = componentResult.xCoords.map(function (x) {\n        return x + diffOnX;\n      });\n      componentResult.yCoords = componentResult.yCoords.map(function (y) {\n        return y + diffOnY;\n      });\n    } else {\n      // calculate current bounding box\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        var leftX = node.getRect().x;\n        var rightX = node.getRect().x + node.getRect().width;\n        var topY = node.getRect().y;\n        var bottomY = node.getRect().y + node.getRect().height;\n\n        if (leftX < minXCoord) minXCoord = leftX;\n        if (rightX > maxXCoord) maxXCoord = rightX;\n        if (topY < minYCoord) minYCoord = topY;\n        if (bottomY > maxYCoord) maxYCoord = bottomY;\n      });\n      // find difference between current and original center\n      var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n      });\n    }\n  }\n};\n\nauxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n  // calculate bounds\n  var left = Number.MAX_SAFE_INTEGER;\n  var right = Number.MIN_SAFE_INTEGER;\n  var top = Number.MAX_SAFE_INTEGER;\n  var bottom = Number.MIN_SAFE_INTEGER;\n  var nodeLeft = void 0;\n  var nodeRight = void 0;\n  var nodeTop = void 0;\n  var nodeBottom = void 0;\n\n  var nodes = parentNode.descendants().not(\":parent\");\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var node = nodes[i];\n\n    nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n    nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n    nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n    nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingBox = {};\n  boundingBox.topLeftX = left;\n  boundingBox.topLeftY = top;\n  boundingBox.width = right - left;\n  boundingBox.height = bottom - top;\n  return boundingBox;\n};\n\n// This function finds and returns parent nodes whose all children are hidden\nauxiliary.calcParentsWithoutChildren = function (cy, eles) {\n  var parentsWithoutChildren = cy.collection();\n  eles.nodes(':parent').forEach(function (parent) {\n    var check = false;\n    parent.children().forEach(function (child) {\n      if (child.css('display') != 'none') {\n        check = true;\n      }\n    });\n    if (!check) {\n      parentsWithoutChildren.merge(parent);\n    }\n  });\n\n  return parentsWithoutChildren;\n};\n\nmodule.exports = auxiliary;\n\n/***/ }),\n\n/***/ 816:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\n/**\n  The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n*/\n\nvar aux = __webpack_require__(548);\nvar CoSELayout = __webpack_require__(140).CoSELayout;\nvar CoSENode = __webpack_require__(140).CoSENode;\nvar PointD = __webpack_require__(140).layoutBase.PointD;\nvar DimensionD = __webpack_require__(140).layoutBase.DimensionD;\nvar LayoutConstants = __webpack_require__(140).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __webpack_require__(140).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __webpack_require__(140).CoSEConstants;\n\n// main function that cose layout is processed\nvar coseLayout = function coseLayout(options, spectralResult) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var edges = eles.edges();\n\n  var nodeIndexes = void 0;\n  var xCoords = void 0;\n  var yCoords = void 0;\n  var idToLNode = {};\n\n  if (options.randomize) {\n    nodeIndexes = spectralResult[\"nodeIndexes\"];\n    xCoords = spectralResult[\"xCoords\"];\n    yCoords = spectralResult[\"yCoords\"];\n  }\n\n  var isFn = function isFn(fn) {\n    return typeof fn === 'function';\n  };\n\n  var optFn = function optFn(opt, ele) {\n    if (isFn(opt)) {\n      return opt(ele);\n    } else {\n      return opt;\n    }\n  };\n\n  /**** Postprocessing functions ****/\n\n  var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n\n  // transfer cytoscape nodes to cose nodes\n  var processChildrenList = function processChildrenList(parent, children, layout, options) {\n    var size = children.length;\n    for (var i = 0; i < size; i++) {\n      var theChild = children[i];\n      var children_of_children = null;\n      if (theChild.intersection(parentsWithoutChildren).length == 0) {\n        children_of_children = theChild.children();\n      }\n      var theNode = void 0;\n\n      var dimensions = theChild.layoutDimensions({\n        nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n      });\n\n      if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n        if (options.randomize) {\n          if (!theChild.isParent()) {\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n          } else {\n            var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n            if (theChild.intersection(parentsWithoutChildren).length == 0) {\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n            } else {\n              // for the parentsWithoutChildren\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n            }\n          }\n        } else {\n          theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n        }\n      } else {\n        theNode = parent.add(new CoSENode(this.graphManager));\n      }\n      // Attach id to the layout node and repulsion value\n      theNode.id = theChild.data(\"id\");\n      theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n      // Attach the paddings of cy node to layout node\n      theNode.paddingLeft = parseInt(theChild.css('padding'));\n      theNode.paddingTop = parseInt(theChild.css('padding'));\n      theNode.paddingRight = parseInt(theChild.css('padding'));\n      theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n      //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n      //These properties will be used while updating bounds of compounds during iterations or tiling\n      //and will be used for simple nodes while transferring final positions to cytoscape\n      if (options.nodeDimensionsIncludeLabels) {\n        theNode.labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).w;\n        theNode.labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).h;\n        theNode.labelPosVertical = theChild.css(\"text-valign\");\n        theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n      }\n\n      // Map the layout node\n      idToLNode[theChild.data(\"id\")] = theNode;\n\n      if (isNaN(theNode.rect.x)) {\n        theNode.rect.x = 0;\n      }\n\n      if (isNaN(theNode.rect.y)) {\n        theNode.rect.y = 0;\n      }\n\n      if (children_of_children != null && children_of_children.length > 0) {\n        var theNewGraph = void 0;\n        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n        processChildrenList(theNewGraph, children_of_children, layout, options);\n      }\n    }\n  };\n\n  // transfer cytoscape edges to cose edges\n  var processEdges = function processEdges(layout, gm, edges) {\n    var idealLengthTotal = 0;\n    var edgeCount = 0;\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var sourceNode = idToLNode[edge.data(\"source\")];\n      var targetNode = idToLNode[edge.data(\"target\")];\n      if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n        e1.id = edge.id();\n        e1.idealLength = optFn(options.idealEdgeLength, edge);\n        e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n        idealLengthTotal += e1.idealLength;\n        edgeCount++;\n      }\n    }\n    // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n    // in case there is no edge, use other options\n    if (options.idealEdgeLength != null) {\n      if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength)) // in case there is no edge, but option gives a value to use\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else // in case there is no edge and we cannot get a value from option (because it's a function)\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n      // we need to update these constant values based on the ideal edge length constant\n      CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n    }\n  };\n\n  // transfer cytoscape constraints to cose layout\n  var processConstraints = function processConstraints(layout, options) {\n    // get nodes to be fixed\n    if (options.fixedNodeConstraint) {\n      layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n    }\n    // get nodes to be aligned\n    if (options.alignmentConstraint) {\n      layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n    }\n    // get nodes to be relatively placed\n    if (options.relativePlacementConstraint) {\n      layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n    }\n  };\n\n  /**** Apply postprocessing ****/\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n\n  if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n  CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n  LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n  // This part is for debug/demo purpose\n  if (options.step == \"transformed\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"enforced\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"cose\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n  if (options.step == \"all\") {\n    if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n\n  if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n  } else {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n  }\n\n  var coseLayout = new CoSELayout();\n  var gm = coseLayout.newGraphManager();\n\n  processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n  processEdges(coseLayout, gm, edges);\n  processConstraints(coseLayout, options);\n\n  coseLayout.runLayout();\n\n  return idToLNode;\n};\n\nmodule.exports = { coseLayout: coseLayout };\n\n/***/ }),\n\n/***/ 212:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n  The implementation of the fcose layout algorithm\n*/\n\nvar assign = __webpack_require__(658);\nvar aux = __webpack_require__(548);\n\nvar _require = __webpack_require__(657),\n    spectralLayout = _require.spectralLayout;\n\nvar _require2 = __webpack_require__(816),\n    coseLayout = _require2.coseLayout;\n\nvar defaults = Object.freeze({\n\n  // 'draft', 'default' or 'proof' \n  // - 'draft' only applies spectral layout \n  // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n  // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n  quality: \"default\",\n  // Use random node positions at beginning of layout\n  // if this is set to false, then quality option must be \"proof\"\n  randomize: true,\n  // Whether or not to animate the layout\n  animate: true,\n  // Duration of animation in ms, if enabled\n  animationDuration: 1000,\n  // Easing of animation, if enabled\n  animationEasing: undefined,\n  // Fit the viewport to the repositioned nodes\n  fit: true,\n  // Padding around layout\n  padding: 30,\n  // Whether to include labels in node dimensions. Valid in \"proof\" quality\n  nodeDimensionsIncludeLabels: false,\n  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n  uniformNodeDimensions: false,\n  // Whether to pack disconnected components - valid only if randomize: true\n  packComponents: true,\n  // Layout step - all, transformed, enforced, cose - for debug purpose only\n  step: \"all\",\n\n  /* spectral layout options */\n\n  // False for random, true for greedy\n  samplingType: true,\n  // Sample size to construct distance matrix\n  sampleSize: 25,\n  // Separation amount between nodes\n  nodeSeparation: 75,\n  // Power iteration tolerance\n  piTol: 0.0000001,\n\n  /* CoSE layout options */\n\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 4500;\n  },\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 50;\n  },\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 0.45;\n  },\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n  // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n  tilingCompareBy: undefined,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout  \n  initialEnergyOnIncremental: 0.3,\n\n  /* constraint options */\n\n  // Fix required nodes to predefined positions\n  // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n  fixedNodeConstraint: undefined,\n  // Align required nodes in vertical/horizontal direction\n  // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n  alignmentConstraint: undefined,\n  // Place two nodes relatively in vertical/horizontal direction \n  // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n  relativePlacementConstraint: undefined,\n\n  /* layout event callbacks */\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {} // on layoutstop\n});\n\nvar Layout = function () {\n  function Layout(options) {\n    _classCallCheck(this, Layout);\n\n    this.options = assign({}, defaults, options);\n  }\n\n  _createClass(Layout, [{\n    key: 'run',\n    value: function run() {\n      var layout = this;\n      var options = this.options;\n      var cy = options.cy;\n      var eles = options.eles;\n\n      var spectralResult = [];\n      var xCoords = void 0;\n      var yCoords = void 0;\n      var coseResult = [];\n      var components = void 0;\n      var componentCenters = [];\n\n      // basic validity check for constraint inputs \n      if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n        options.fixedNodeConstraint = undefined;\n      }\n\n      if (options.alignmentConstraint) {\n        if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n          options.alignmentConstraint.vertical = undefined;\n        }\n        if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n          options.alignmentConstraint.horizontal = undefined;\n        }\n      }\n\n      if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n        options.relativePlacementConstraint = undefined;\n      }\n\n      // if any constraint exists, set some options\n      var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n      if (constraintExist) {\n        // constraints work with these options\n        options.tile = false;\n        options.packComponents = false;\n      }\n\n      // decide component packing is enabled or not\n      var layUtil = void 0;\n      var packingEnabled = false;\n      if (cy.layoutUtilities && options.packComponents) {\n        layUtil = cy.layoutUtilities(\"get\");\n        if (!layUtil) layUtil = cy.layoutUtilities();\n        packingEnabled = true;\n      }\n\n      if (eles.nodes().length > 0) {\n        // if packing is not enabled, perform layout on the whole graph\n        if (!packingEnabled) {\n          // store component center\n          var boundingBox = options.eles.boundingBox();\n          componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          // apply spectral layout\n          if (options.randomize) {\n            var result = spectralLayout(options);\n            spectralResult.push(result);\n          }\n          // apply cose layout as postprocessing\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            coseResult.push(coseLayout(options, spectralResult[0]));\n            aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position\n          } else {\n            aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position\n          }\n        } else {\n          // packing is enabled\n          var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n          components = aux.connectComponents(cy, options.eles, topMostNodes);\n          // store component centers\n          components.forEach(function (component) {\n            var boundingBox = component.boundingBox();\n            componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          });\n\n          //send each component to spectral layout if randomized\n          if (options.randomize) {\n            components.forEach(function (component) {\n              options.eles = component;\n              spectralResult.push(spectralLayout(options));\n            });\n          }\n\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            var toBeTiledNodes = cy.collection();\n            if (options.tile) {\n              // behave nodes to be tiled as one component\n              var nodeIndexes = new Map();\n              var _xCoords = [];\n              var _yCoords = [];\n              var count = 0;\n              var tempSpectralResult = { nodeIndexes: nodeIndexes, xCoords: _xCoords, yCoords: _yCoords };\n              var indexesToBeDeleted = [];\n              components.forEach(function (component, index) {\n                if (component.edges().length == 0) {\n                  component.nodes().forEach(function (node, i) {\n                    toBeTiledNodes.merge(component.nodes()[i]);\n                    if (!node.isParent()) {\n                      tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                      tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                      tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                    }\n                  });\n                  indexesToBeDeleted.push(index);\n                }\n              });\n              if (toBeTiledNodes.length > 1) {\n                var _boundingBox = toBeTiledNodes.boundingBox();\n                componentCenters.push({ x: _boundingBox.x1 + _boundingBox.w / 2, y: _boundingBox.y1 + _boundingBox.h / 2 });\n                components.push(toBeTiledNodes);\n                spectralResult.push(tempSpectralResult);\n                for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                  components.splice(indexesToBeDeleted[i], 1);\n                  spectralResult.splice(indexesToBeDeleted[i], 1);\n                  componentCenters.splice(indexesToBeDeleted[i], 1);\n                };\n              }\n            }\n            components.forEach(function (component, index) {\n              // send each component to cose layout\n              options.eles = component;\n              coseResult.push(coseLayout(options, spectralResult[index]));\n              aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position\n            });\n          } else {\n            components.forEach(function (component, index) {\n              aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position\n            });\n          }\n\n          // packing\n          var componentsEvaluated = new Set();\n          if (components.length > 1) {\n            var subgraphs = [];\n            var hiddenEles = eles.filter(function (ele) {\n              return ele.css('display') == 'none';\n            });\n            components.forEach(function (component, index) {\n              var nodeIndexes = void 0;\n              if (options.quality == \"draft\") {\n                nodeIndexes = spectralResult[index].nodeIndexes;\n              }\n\n              if (component.nodes().not(hiddenEles).length > 0) {\n                var subgraph = {};\n                subgraph.edges = [];\n                subgraph.nodes = [];\n                var nodeIndex = void 0;\n                component.nodes().not(hiddenEles).forEach(function (node) {\n                  if (options.quality == \"draft\") {\n                    if (!node.isParent()) {\n                      nodeIndex = nodeIndexes.get(node.id());\n                      subgraph.nodes.push({ x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2, y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2, width: node.boundingbox().w, height: node.boundingbox().h });\n                    } else {\n                      var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                      subgraph.nodes.push({ x: parentInfo.topLeftX, y: parentInfo.topLeftY, width: parentInfo.width, height: parentInfo.height });\n                    }\n                  } else {\n                    if (coseResult[index][node.id()]) {\n                      subgraph.nodes.push({ x: coseResult[index][node.id()].getLeft(), y: coseResult[index][node.id()].getTop(), width: coseResult[index][node.id()].getWidth(), height: coseResult[index][node.id()].getHeight() });\n                    }\n                  }\n                });\n                component.edges().forEach(function (edge) {\n                  var source = edge.source();\n                  var target = edge.target();\n                  if (source.css(\"display\") != \"none\" && target.css(\"display\") != \"none\") {\n                    if (options.quality == \"draft\") {\n                      var sourceNodeIndex = nodeIndexes.get(source.id());\n                      var targetNodeIndex = nodeIndexes.get(target.id());\n                      var sourceCenter = [];\n                      var targetCenter = [];\n                      if (source.isParent()) {\n                        var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                        sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                      } else {\n                        sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                        sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                      }\n                      if (target.isParent()) {\n                        var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                        targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                      } else {\n                        targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                        targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                      }\n                      subgraph.edges.push({ startX: sourceCenter[0], startY: sourceCenter[1], endX: targetCenter[0], endY: targetCenter[1] });\n                    } else {\n                      if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                        subgraph.edges.push({ startX: coseResult[index][source.id()].getCenterX(), startY: coseResult[index][source.id()].getCenterY(), endX: coseResult[index][target.id()].getCenterX(), endY: coseResult[index][target.id()].getCenterY() });\n                      }\n                    }\n                  }\n                });\n                if (subgraph.nodes.length > 0) {\n                  subgraphs.push(subgraph);\n                  componentsEvaluated.add(index);\n                }\n              }\n            });\n            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n            if (options.quality == \"draft\") {\n              spectralResult.forEach(function (result, index) {\n                var newXCoords = result.xCoords.map(function (x) {\n                  return x + shiftResult[index].dx;\n                });\n                var newYCoords = result.yCoords.map(function (y) {\n                  return y + shiftResult[index].dy;\n                });\n                result.xCoords = newXCoords;\n                result.yCoords = newYCoords;\n              });\n            } else {\n              var _count = 0;\n              componentsEvaluated.forEach(function (index) {\n                Object.keys(coseResult[index]).forEach(function (item) {\n                  var nodeRectangle = coseResult[index][item];\n                  nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                });\n                _count++;\n              });\n            }\n          }\n        }\n      }\n\n      // get each element's calculated position\n      var getPositions = function getPositions(ele, i) {\n        if (options.quality == \"default\" || options.quality == \"proof\") {\n          if (typeof ele === \"number\") {\n            ele = i;\n          }\n          var pos = void 0;\n          var node = void 0;\n          var theId = ele.data('id');\n          coseResult.forEach(function (result) {\n            if (theId in result) {\n              pos = { x: result[theId].getRect().getCenterX(), y: result[theId].getRect().getCenterY() };\n              node = result[theId];\n            }\n          });\n          if (options.nodeDimensionsIncludeLabels) {\n            if (node.labelWidth) {\n              if (node.labelPosHorizontal == \"left\") {\n                pos.x += node.labelWidth / 2;\n              } else if (node.labelPosHorizontal == \"right\") {\n                pos.x -= node.labelWidth / 2;\n              }\n            }\n            if (node.labelHeight) {\n              if (node.labelPosVertical == \"top\") {\n                pos.y += node.labelHeight / 2;\n              } else if (node.labelPosVertical == \"bottom\") {\n                pos.y -= node.labelHeight / 2;\n              }\n            }\n          }\n          if (pos == undefined) pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: pos.x,\n            y: pos.y\n          };\n        } else {\n          var _pos = void 0;\n          spectralResult.forEach(function (result) {\n            var index = result.nodeIndexes.get(ele.id());\n            if (index != undefined) {\n              _pos = { x: result.xCoords[index], y: result.yCoords[index] };\n            }\n          });\n          if (_pos == undefined) _pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: _pos.x,\n            y: _pos.y\n          };\n        }\n      };\n\n      // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n      if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n        // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n        var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n        var _hiddenEles = eles.filter(function (ele) {\n          return ele.css('display') == 'none';\n        });\n        options.eles = eles.not(_hiddenEles);\n\n        eles.nodes().not(\":parent\").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n\n        if (parentsWithoutChildren.length > 0) {\n          parentsWithoutChildren.forEach(function (ele) {\n            ele.position(getPositions(ele));\n          });\n        }\n      } else {\n        console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n      }\n    }\n  }]);\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n\n/***/ 657:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\n/**\n  The implementation of the spectral layout that is the first part of the fcose layout algorithm\n*/\n\nvar aux = __webpack_require__(548);\nvar Matrix = __webpack_require__(140).layoutBase.Matrix;\nvar SVD = __webpack_require__(140).layoutBase.SVD;\n\n// main function that spectral layout is processed\nvar spectralLayout = function spectralLayout(options) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var parentNodes = eles.nodes(\":parent\");\n\n  var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n  var nodeIndexes = new Map(); // map to keep indexes to nodes\n  var parentChildMap = new Map(); // mapping btw. compound and its representative node \n  var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n  var xCoords = [];\n  var yCoords = [];\n\n  var samplesColumn = []; // sampled vertices\n  var minDistancesColumn = [];\n  var C = []; // column sampling matrix\n  var PHI = []; // intersection of column and row sampling matrices \n  var INV = []; // inverse of PHI \n\n  var firstSample = void 0; // the first sampled node\n  var nodeSize = void 0;\n\n  var infinity = 100000000;\n  var small = 0.000000001;\n\n  var piTol = options.piTol;\n  var samplingType = options.samplingType; // false for random, true for greedy\n  var nodeSeparation = options.nodeSeparation;\n  var sampleSize = void 0;\n\n  /**** Spectral-preprocessing functions ****/\n\n  /**** Spectral layout functions ****/\n\n  // determine which columns to be sampled\n  var randomSampleCR = function randomSampleCR() {\n    var sample = 0;\n    var count = 0;\n    var flag = false;\n\n    while (count < sampleSize) {\n      sample = Math.floor(Math.random() * nodeSize);\n\n      flag = false;\n      for (var i = 0; i < count; i++) {\n        if (samplesColumn[i] == sample) {\n          flag = true;\n          break;\n        }\n      }\n\n      if (!flag) {\n        samplesColumn[count] = sample;\n        count++;\n      } else {\n        continue;\n      }\n    }\n  };\n\n  // takes the index of the node(pivot) to initiate BFS as a parameter\n  var BFS = function BFS(pivot, index, samplingMethod) {\n    var path = []; // the front of the path\n    var front = 0; // the back of the path\n    var back = 0;\n    var current = 0;\n    var temp = void 0;\n    var distance = [];\n\n    var max_dist = 0; // the furthest node to be returned\n    var max_ind = 1;\n\n    for (var i = 0; i < nodeSize; i++) {\n      distance[i] = infinity;\n    }\n\n    path[back] = pivot;\n    distance[pivot] = 0;\n\n    while (back >= front) {\n      current = path[front++];\n      var neighbors = allNodesNeighborhood[current];\n      for (var _i = 0; _i < neighbors.length; _i++) {\n        temp = nodeIndexes.get(neighbors[_i]);\n        if (distance[temp] == infinity) {\n          distance[temp] = distance[current] + 1;\n          path[++back] = temp;\n        }\n      }\n      C[current][index] = distance[current] * nodeSeparation;\n    }\n\n    if (samplingMethod) {\n      for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n        if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n      }\n\n      for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n        if (minDistancesColumn[_i3] > max_dist) {\n          max_dist = minDistancesColumn[_i3];\n          max_ind = _i3;\n        }\n      }\n    }\n    return max_ind;\n  };\n\n  // apply BFS to all nodes or selected samples\n  var allBFS = function allBFS(samplingMethod) {\n\n    var sample = void 0;\n\n    if (!samplingMethod) {\n      randomSampleCR();\n\n      // call BFS\n      for (var i = 0; i < sampleSize; i++) {\n        BFS(samplesColumn[i], i, samplingMethod, false);\n      }\n    } else {\n      sample = Math.floor(Math.random() * nodeSize);\n      firstSample = sample;\n\n      for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n        minDistancesColumn[_i4] = infinity;\n      }\n\n      for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n        samplesColumn[_i5] = sample;\n        sample = BFS(sample, _i5, samplingMethod);\n      }\n    }\n\n    // form the squared distances for C\n    for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n      for (var j = 0; j < sampleSize; j++) {\n        C[_i6][j] *= C[_i6][j];\n      }\n    }\n\n    // form PHI\n    for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n      PHI[_i7] = [];\n    }\n\n    for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n      for (var _j = 0; _j < sampleSize; _j++) {\n        PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n      }\n    }\n  };\n\n  // perform the SVD algorithm and apply a regularization step\n  var sample = function sample() {\n\n    var SVDResult = SVD.svd(PHI);\n\n    var a_q = SVDResult.S;\n    var a_u = SVDResult.U;\n    var a_v = SVDResult.V;\n\n    var max_s = a_q[0] * a_q[0] * a_q[0];\n\n    var a_Sig = [];\n\n    //  regularization\n    for (var i = 0; i < sampleSize; i++) {\n      a_Sig[i] = [];\n      for (var j = 0; j < sampleSize; j++) {\n        a_Sig[i][j] = 0;\n        if (i == j) {\n          a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n        }\n      }\n    }\n\n    INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n  };\n\n  // calculate final coordinates \n  var powerIteration = function powerIteration() {\n    // two largest eigenvalues\n    var theta1 = void 0;\n    var theta2 = void 0;\n\n    // initial guesses for eigenvectors\n    var Y1 = [];\n    var Y2 = [];\n\n    var V1 = [];\n    var V2 = [];\n\n    for (var i = 0; i < nodeSize; i++) {\n      Y1[i] = Math.random();\n      Y2[i] = Math.random();\n    }\n\n    Y1 = Matrix.normalize(Y1);\n    Y2 = Matrix.normalize(Y2);\n\n    var count = 0;\n    // to keep track of the improvement ratio in power iteration\n    var current = small;\n    var previous = small;\n\n    var temp = void 0;\n\n    while (true) {\n      count++;\n\n      for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n        V1[_i9] = Y1[_i9];\n      }\n\n      Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n      theta1 = Matrix.dotProduct(V1, Y1);\n      Y1 = Matrix.normalize(Y1);\n\n      current = Matrix.dotProduct(V1, Y1);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n      V1[_i10] = Y1[_i10];\n    }\n\n    count = 0;\n    previous = small;\n    while (true) {\n      count++;\n\n      for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n        V2[_i11] = Y2[_i11];\n      }\n\n      V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n      Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n      theta2 = Matrix.dotProduct(V2, Y2);\n      Y2 = Matrix.normalize(Y2);\n\n      current = Matrix.dotProduct(V2, Y2);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n      V2[_i12] = Y2[_i12];\n    }\n\n    // theta1 now contains dominant eigenvalue\n    // theta2 now contains the second-largest eigenvalue\n    // V1 now contains theta1's eigenvector\n    // V2 now contains theta2's eigenvector\n\n    //populate the two vectors\n    xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n    yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n  };\n\n  /**** Preparation for spectral layout (Preprocessing) ****/\n\n  // connect disconnected components (first top level, then inside of each compound node)\n  aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n\n  parentNodes.forEach(function (ele) {\n    aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n  });\n\n  // assign indexes to nodes (first real, then dummy nodes)\n  var index = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    if (!nodes[i].isParent()) {\n      nodeIndexes.set(nodes[i].id(), index++);\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      nodeIndexes.set(key, index++);\n    }\n\n    // instantiate the neighborhood matrix\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n    allNodesNeighborhood[_i13] = [];\n  }\n\n  // form a parent-child map to keep representative node of each compound node  \n  parentNodes.forEach(function (ele) {\n    var children = ele.children().intersection(eles);\n\n    //      let random = 0;\n    while (children.nodes(\":childless\").length == 0) {\n      //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n      children = children.nodes()[0].children().intersection(eles);\n    }\n    //  select the representative node - we can apply different methods here\n    //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n    var index = 0;\n    var min = children.nodes(\":childless\")[0].connectedEdges().length;\n    children.nodes(\":childless\").forEach(function (ele2, i) {\n      if (ele2.connectedEdges().length < min) {\n        min = ele2.connectedEdges().length;\n        index = i;\n      }\n    });\n    parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n  });\n\n  // add neighborhood relations (first real, then dummy nodes)\n  nodes.forEach(function (ele) {\n    var eleIndex = void 0;\n\n    if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n\n    ele.neighborhood().nodes().forEach(function (node) {\n      if (eles.intersection(ele.edgesWith(node)).length > 0) {\n        if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n      }\n    });\n  });\n\n  var _loop = function _loop(_key) {\n    var eleIndex = nodeIndexes.get(_key);\n    var disconnectedId = void 0;\n    dummyNodes.get(_key).forEach(function (id) {\n      if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n\n      allNodesNeighborhood[eleIndex].push(disconnectedId);\n      allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n    });\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _key = _step2.value;\n\n      _loop(_key);\n    }\n\n    // nodeSize now only considers the size of transformed graph\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  nodeSize = nodeIndexes.size;\n\n  var spectralResult = void 0;\n\n  // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n  // So skip spectral and layout the graph with cose\n  if (nodeSize > 2) {\n    // if # of nodes in transformed graph is smaller than sample size,\n    // then use # of nodes as sample size\n    sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n    // instantiates the partial matrices that will be used in spectral layout\n    for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n      C[_i14] = [];\n    }\n    for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n      INV[_i15] = [];\n    }\n\n    /**** Apply spectral layout ****/\n\n    if (options.quality == \"draft\" || options.step == \"all\") {\n      allBFS(samplingType);\n      sample();\n      powerIteration();\n\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    } else {\n      nodeIndexes.forEach(function (value, key) {\n        xCoords.push(cy.getElementById(key).position(\"x\"));\n        yCoords.push(cy.getElementById(key).position(\"y\"));\n      });\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    }\n    return spectralResult;\n  } else {\n    var iterator = nodeIndexes.keys();\n    var firstNode = cy.getElementById(iterator.next().value);\n    var firstNodePos = firstNode.position();\n    var firstNodeWidth = firstNode.outerWidth();\n    xCoords.push(firstNodePos.x);\n    yCoords.push(firstNodePos.y);\n    if (nodeSize == 2) {\n      var secondNode = cy.getElementById(iterator.next().value);\n      var secondNodeWidth = secondNode.outerWidth();\n      xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n      yCoords.push(firstNodePos.y);\n    }\n\n    spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    return spectralResult;\n  }\n};\n\nmodule.exports = { spectralLayout: spectralLayout };\n\n/***/ }),\n\n/***/ 579:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar impl = __webpack_require__(212);\n\n// registers the extension on a cytoscape lib ref\nvar register = function register(cytoscape) {\n  if (!cytoscape) {\n    return;\n  } // can't register if cytoscape unspecified\n\n  cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n};\n\nif (typeof cytoscape !== 'undefined') {\n  // expose to global cytoscape (i.e. window.cytoscape)\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ }),\n\n/***/ 140:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(579);\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}