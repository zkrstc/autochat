{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { wrapSVGContent } from './defs.mjs';\nimport { getSVGViewBox } from './viewbox.mjs';\nfunction parseSVGContent(content) {\n  const match = content.trim().match(/(?:<(?:\\?xml|!DOCTYPE)[^>]+>\\s*)*<svg([^>]+)>([\\s\\S]+)<\\/svg[^>]*>/);\n  if (!match) {\n    return;\n  }\n  const body = match[2].trim();\n  const attribsList = match[1].match(/[\\w:-]+=\"[^\"]*\"/g);\n  const attribs = /* @__PURE__ */Object.create(null);\n  attribsList?.forEach(row => {\n    const match2 = row.match(/([\\w:-]+)=\"([^\"]*)\"/);\n    if (match2) {\n      attribs[match2[1]] = match2[2];\n    }\n  });\n  return {\n    attribs,\n    body\n  };\n}\nfunction build(data) {\n  const attribs = data.attribs;\n  const viewBox = getSVGViewBox(attribs[\"viewBox\"] ?? \"\");\n  if (!viewBox) {\n    return;\n  }\n  const groupAttributes = [];\n  for (const key in attribs) {\n    if (key === \"style\" || key.startsWith(\"fill\") || key.startsWith(\"stroke\")) {\n      groupAttributes.push(`${key}=\"${attribs[key]}\"`);\n    }\n  }\n  let body = data.body;\n  if (groupAttributes.length) {\n    body = wrapSVGContent(body, \"<g \" + groupAttributes.join(\" \") + \">\", \"</g>\");\n  }\n  return {\n    // Copy dimensions if exist\n    width: attribs.width,\n    height: attribs.height,\n    viewBox,\n    body\n  };\n}\nfunction buildParsedSVG(data) {\n  const result = build(data);\n  if (result) {\n    return {\n      attributes: {\n        // Copy dimensions if exist\n        width: result.width,\n        height: result.height,\n        // Merge viewBox\n        viewBox: result.viewBox.join(\" \")\n      },\n      viewBox: result.viewBox,\n      body: result.body\n    };\n  }\n}\nfunction convertParsedSVG(data) {\n  const result = build(data);\n  if (result) {\n    const viewBox = result.viewBox;\n    return {\n      left: viewBox[0],\n      top: viewBox[1],\n      width: viewBox[2],\n      height: viewBox[3],\n      body: result.body\n    };\n  }\n}\nexport { buildParsedSVG, convertParsedSVG, parseSVGContent };","map":{"version":3,"names":["wrapSVGContent","getSVGViewBox","parseSVGContent","content","match","trim","body","attribsList","attribs","Object","create","forEach","row","match2","build","data","viewBox","groupAttributes","key","startsWith","push","length","join","width","height","buildParsedSVG","result","attributes","convertParsedSVG","left","top"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/@iconify/utils/lib/svg/parse.mjs"],"sourcesContent":["import { wrapSVGContent } from './defs.mjs';\nimport { getSVGViewBox } from './viewbox.mjs';\n\nfunction parseSVGContent(content) {\n  const match = content.trim().match(\n    /(?:<(?:\\?xml|!DOCTYPE)[^>]+>\\s*)*<svg([^>]+)>([\\s\\S]+)<\\/svg[^>]*>/\n  );\n  if (!match) {\n    return;\n  }\n  const body = match[2].trim();\n  const attribsList = match[1].match(/[\\w:-]+=\"[^\"]*\"/g);\n  const attribs = /* @__PURE__ */ Object.create(null);\n  attribsList?.forEach((row) => {\n    const match2 = row.match(/([\\w:-]+)=\"([^\"]*)\"/);\n    if (match2) {\n      attribs[match2[1]] = match2[2];\n    }\n  });\n  return {\n    attribs,\n    body\n  };\n}\nfunction build(data) {\n  const attribs = data.attribs;\n  const viewBox = getSVGViewBox(attribs[\"viewBox\"] ?? \"\");\n  if (!viewBox) {\n    return;\n  }\n  const groupAttributes = [];\n  for (const key in attribs) {\n    if (key === \"style\" || key.startsWith(\"fill\") || key.startsWith(\"stroke\")) {\n      groupAttributes.push(`${key}=\"${attribs[key]}\"`);\n    }\n  }\n  let body = data.body;\n  if (groupAttributes.length) {\n    body = wrapSVGContent(\n      body,\n      \"<g \" + groupAttributes.join(\" \") + \">\",\n      \"</g>\"\n    );\n  }\n  return {\n    // Copy dimensions if exist\n    width: attribs.width,\n    height: attribs.height,\n    viewBox,\n    body\n  };\n}\nfunction buildParsedSVG(data) {\n  const result = build(data);\n  if (result) {\n    return {\n      attributes: {\n        // Copy dimensions if exist\n        width: result.width,\n        height: result.height,\n        // Merge viewBox\n        viewBox: result.viewBox.join(\" \")\n      },\n      viewBox: result.viewBox,\n      body: result.body\n    };\n  }\n}\nfunction convertParsedSVG(data) {\n  const result = build(data);\n  if (result) {\n    const viewBox = result.viewBox;\n    return {\n      left: viewBox[0],\n      top: viewBox[1],\n      width: viewBox[2],\n      height: viewBox[3],\n      body: result.body\n    };\n  }\n}\n\nexport { buildParsedSVG, convertParsedSVG, parseSVGContent };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}