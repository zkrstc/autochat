{"ast":null,"code":"import * as _ from 'lodash-es';\nexport { longestPath, slack };\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nfunction longestPath(g) {\n  var visited = {};\n  function dfs(v) {\n    var label = g.node(v);\n    if (Object.prototype.hasOwnProperty.call(visited, v)) {\n      return label.rank;\n    }\n    visited[v] = true;\n    var rank = _.min(_.map(g.outEdges(v), function (e) {\n      return dfs(e.w) - g.edge(e).minlen;\n    }));\n    if (rank === Number.POSITIVE_INFINITY ||\n    // return value of _.map([]) for Lodash 3\n    rank === undefined ||\n    // return value of _.map([]) for Lodash 4\n    rank === null) {\n      // return value of _.map([null])\n      rank = 0;\n    }\n    return label.rank = rank;\n  }\n  _.forEach(g.sources(), dfs);\n}\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nfunction slack(g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;\n}","map":{"version":3,"names":["_","longestPath","slack","g","visited","dfs","v","label","node","Object","prototype","hasOwnProperty","call","rank","min","map","outEdges","e","w","edge","minlen","Number","POSITIVE_INFINITY","undefined","forEach","sources"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/dagre-d3-es/src/dagre/rank/util.js"],"sourcesContent":["import * as _ from 'lodash-es';\n\nexport { longestPath, slack };\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nfunction longestPath(g) {\n  var visited = {};\n\n  function dfs(v) {\n    var label = g.node(v);\n    if (Object.prototype.hasOwnProperty.call(visited, v)) {\n      return label.rank;\n    }\n    visited[v] = true;\n\n    var rank = _.min(\n      _.map(g.outEdges(v), function (e) {\n        return dfs(e.w) - g.edge(e).minlen;\n      }),\n    );\n\n    if (\n      rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3\n      rank === undefined || // return value of _.map([]) for Lodash 4\n      rank === null\n    ) {\n      // return value of _.map([null])\n      rank = 0;\n    }\n\n    return (label.rank = rank);\n  }\n\n  _.forEach(g.sources(), dfs);\n}\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nfunction slack(g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;\n}\n"],"mappings":"AAAA,OAAO,KAAKA,CAAC,MAAM,WAAW;AAE9B,SAASC,WAAW,EAAEC,KAAK;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,WAAWA,CAACE,CAAC,EAAE;EACtB,IAAIC,OAAO,GAAG,CAAC,CAAC;EAEhB,SAASC,GAAGA,CAACC,CAAC,EAAE;IACd,IAAIC,KAAK,GAAGJ,CAAC,CAACK,IAAI,CAACF,CAAC,CAAC;IACrB,IAAIG,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACR,OAAO,EAAEE,CAAC,CAAC,EAAE;MACpD,OAAOC,KAAK,CAACM,IAAI;IACnB;IACAT,OAAO,CAACE,CAAC,CAAC,GAAG,IAAI;IAEjB,IAAIO,IAAI,GAAGb,CAAC,CAACc,GAAG,CACdd,CAAC,CAACe,GAAG,CAACZ,CAAC,CAACa,QAAQ,CAACV,CAAC,CAAC,EAAE,UAAUW,CAAC,EAAE;MAChC,OAAOZ,GAAG,CAACY,CAAC,CAACC,CAAC,CAAC,GAAGf,CAAC,CAACgB,IAAI,CAACF,CAAC,CAAC,CAACG,MAAM;IACpC,CAAC,CACH,CAAC;IAED,IACEP,IAAI,KAAKQ,MAAM,CAACC,iBAAiB;IAAI;IACrCT,IAAI,KAAKU,SAAS;IAAI;IACtBV,IAAI,KAAK,IAAI,EACb;MACA;MACAA,IAAI,GAAG,CAAC;IACV;IAEA,OAAQN,KAAK,CAACM,IAAI,GAAGA,IAAI;EAC3B;EAEAb,CAAC,CAACwB,OAAO,CAACrB,CAAC,CAACsB,OAAO,CAAC,CAAC,EAAEpB,GAAG,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACA,SAASH,KAAKA,CAACC,CAAC,EAAEc,CAAC,EAAE;EACnB,OAAOd,CAAC,CAACK,IAAI,CAACS,CAAC,CAACC,CAAC,CAAC,CAACL,IAAI,GAAGV,CAAC,CAACK,IAAI,CAACS,CAAC,CAACX,CAAC,CAAC,CAACO,IAAI,GAAGV,CAAC,CAACgB,IAAI,CAACF,CAAC,CAAC,CAACG,MAAM;AAC/D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}