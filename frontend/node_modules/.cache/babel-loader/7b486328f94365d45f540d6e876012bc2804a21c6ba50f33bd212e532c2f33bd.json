{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { emojiComponents } from '../data.mjs';\nfunction mergeComponentTypes(value) {\n  return \"[\" + value.join(\",\") + \"]\";\n}\nfunction mergeComponentsCount(value) {\n  const keys = [];\n  for (const key in emojiComponents) {\n    const type = key;\n    for (let i = 0; i < value[type]; i++) {\n      keys.push(type);\n    }\n  }\n  return keys.length ? mergeComponentTypes(keys) : \"\";\n}\nfunction getGroupItem(items, components) {\n  const key = mergeComponentsCount(components);\n  const item = items[key];\n  if (item) {\n    item.parsed = true;\n    return item.item;\n  }\n}\nfunction getEmojiTestDataTree(data) {\n  const groups = /* @__PURE__ */Object.create(null);\n  for (const key in data) {\n    const item = data[key];\n    const text = item.name.key;\n    const parent = groups[text] || (groups[text] = {});\n    const components = {\n      \"hair-style\": 0,\n      \"skin-tone\": 0\n    };\n    item.sequence.forEach(value => {\n      if (typeof value !== \"number\") {\n        components[value]++;\n      }\n    });\n    const componentsKey = mergeComponentsCount(components);\n    if (parent[componentsKey]) {\n      throw new Error(`Duplicate components tree item for \"${text}\"`);\n    }\n    parent[componentsKey] = {\n      item: {\n        ...item,\n        components,\n        componentsKey\n      }\n    };\n  }\n  const results = /* @__PURE__ */Object.create(null);\n  for (const key in groups) {\n    const items = groups[key];\n    const check = (parent, parentComponents, type) => {\n      const item = parse(parentComponents, [type]);\n      if (item) {\n        const children = parent.children || (parent.children = {});\n        children[type] = item;\n        return true;\n      }\n    };\n    const parse = (parentComponents, newComponents) => {\n      const components = {\n        \"hair-style\": 0,\n        \"skin-tone\": 0\n      };\n      const componentsList = parentComponents.concat(newComponents);\n      componentsList.forEach(type => {\n        components[type]++;\n      });\n      let item = getGroupItem(items, components);\n      if (!item && newComponents.length === 1 && newComponents[0] === \"skin-tone\") {\n        const doubleComponents = {\n          ...components\n        };\n        doubleComponents[\"skin-tone\"]++;\n        item = getGroupItem(items, doubleComponents);\n      }\n      if (item) {\n        const result = {\n          item\n        };\n        for (const key2 in emojiComponents) {\n          check(result, componentsList, key2);\n        }\n        return result;\n      }\n    };\n    const root = parse([], []);\n    if (!root) {\n      throw new Error(`Cannot find parent item for \"${key}\"`);\n    }\n    for (const itemsKey in items) {\n      if (!items[itemsKey].parsed) {\n        throw new Error(`Error generating tree for \"${key}\"`);\n      }\n    }\n    if (root.children) {\n      results[key] = root;\n    }\n  }\n  return results;\n}\nexport { getEmojiTestDataTree };","map":{"version":3,"names":["emojiComponents","mergeComponentTypes","value","join","mergeComponentsCount","keys","key","type","i","push","length","getGroupItem","items","components","item","parsed","getEmojiTestDataTree","data","groups","Object","create","text","name","parent","sequence","forEach","componentsKey","Error","results","check","parentComponents","parse","children","newComponents","componentsList","concat","doubleComponents","result","key2","root","itemsKey"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/@iconify/utils/lib/emoji/test/tree.mjs"],"sourcesContent":["import { emojiComponents } from '../data.mjs';\n\nfunction mergeComponentTypes(value) {\n  return \"[\" + value.join(\",\") + \"]\";\n}\nfunction mergeComponentsCount(value) {\n  const keys = [];\n  for (const key in emojiComponents) {\n    const type = key;\n    for (let i = 0; i < value[type]; i++) {\n      keys.push(type);\n    }\n  }\n  return keys.length ? mergeComponentTypes(keys) : \"\";\n}\nfunction getGroupItem(items, components) {\n  const key = mergeComponentsCount(components);\n  const item = items[key];\n  if (item) {\n    item.parsed = true;\n    return item.item;\n  }\n}\nfunction getEmojiTestDataTree(data) {\n  const groups = /* @__PURE__ */ Object.create(null);\n  for (const key in data) {\n    const item = data[key];\n    const text = item.name.key;\n    const parent = groups[text] || (groups[text] = {});\n    const components = {\n      \"hair-style\": 0,\n      \"skin-tone\": 0\n    };\n    item.sequence.forEach((value) => {\n      if (typeof value !== \"number\") {\n        components[value]++;\n      }\n    });\n    const componentsKey = mergeComponentsCount(components);\n    if (parent[componentsKey]) {\n      throw new Error(`Duplicate components tree item for \"${text}\"`);\n    }\n    parent[componentsKey] = {\n      item: {\n        ...item,\n        components,\n        componentsKey\n      }\n    };\n  }\n  const results = /* @__PURE__ */ Object.create(null);\n  for (const key in groups) {\n    const items = groups[key];\n    const check = (parent, parentComponents, type) => {\n      const item = parse(parentComponents, [type]);\n      if (item) {\n        const children = parent.children || (parent.children = {});\n        children[type] = item;\n        return true;\n      }\n    };\n    const parse = (parentComponents, newComponents) => {\n      const components = {\n        \"hair-style\": 0,\n        \"skin-tone\": 0\n      };\n      const componentsList = parentComponents.concat(newComponents);\n      componentsList.forEach((type) => {\n        components[type]++;\n      });\n      let item = getGroupItem(items, components);\n      if (!item && newComponents.length === 1 && newComponents[0] === \"skin-tone\") {\n        const doubleComponents = {\n          ...components\n        };\n        doubleComponents[\"skin-tone\"]++;\n        item = getGroupItem(items, doubleComponents);\n      }\n      if (item) {\n        const result = {\n          item\n        };\n        for (const key2 in emojiComponents) {\n          check(result, componentsList, key2);\n        }\n        return result;\n      }\n    };\n    const root = parse([], []);\n    if (!root) {\n      throw new Error(`Cannot find parent item for \"${key}\"`);\n    }\n    for (const itemsKey in items) {\n      if (!items[itemsKey].parsed) {\n        throw new Error(`Error generating tree for \"${key}\"`);\n      }\n    }\n    if (root.children) {\n      results[key] = root;\n    }\n  }\n  return results;\n}\n\nexport { getEmojiTestDataTree };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}