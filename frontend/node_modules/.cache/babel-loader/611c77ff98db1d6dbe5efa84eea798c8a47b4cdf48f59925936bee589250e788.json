{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { ref, computed } from 'vue';\nimport { isPct, getPct, isPx, getPx } from './useSize.mjs';\nfunction useResize(panels, containerSize, pxSizes) {\n  const ptg2px = ptg => ptg * containerSize.value || 0;\n  function getLimitSize(str, defaultLimit) {\n    if (isPct(str)) {\n      return ptg2px(getPct(str));\n    } else if (isPx(str)) {\n      return getPx(str);\n    }\n    return str != null ? str : defaultLimit;\n  }\n  const movingIndex = ref(null);\n  let cachePxSizes = [];\n  const limitSizes = computed(() => panels.value.map(item => [item.min, item.max]));\n  const onMoveStart = index => {\n    movingIndex.value = {\n      index,\n      confirmed: false\n    };\n    cachePxSizes = pxSizes.value;\n  };\n  const onMoving = (index, offset) => {\n    var _a, _b;\n    let confirmedIndex = null;\n    if ((!movingIndex.value || !movingIndex.value.confirmed) && offset !== 0) {\n      if (offset > 0) {\n        confirmedIndex = index;\n        movingIndex.value = {\n          index,\n          confirmed: true\n        };\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cachePxSizes[i] > 0) {\n            confirmedIndex = i;\n            movingIndex.value = {\n              index: i,\n              confirmed: true\n            };\n            break;\n          }\n        }\n      }\n    }\n    const mergedIndex = (_b = confirmedIndex != null ? confirmedIndex : (_a = movingIndex.value) == null ? void 0 : _a.index) != null ? _b : index;\n    const numSizes = [...cachePxSizes];\n    const nextIndex = mergedIndex + 1;\n    const startMinSize = getLimitSize(limitSizes.value[mergedIndex][0], 0);\n    const endMinSize = getLimitSize(limitSizes.value[nextIndex][0], 0);\n    const startMaxSize = getLimitSize(limitSizes.value[mergedIndex][1], containerSize.value || 0);\n    const endMaxSize = getLimitSize(limitSizes.value[nextIndex][1], containerSize.value || 0);\n    let mergedOffset = offset;\n    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex] - endMinSize;\n    }\n    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex] - endMaxSize;\n    }\n    numSizes[mergedIndex] += mergedOffset;\n    numSizes[nextIndex] -= mergedOffset;\n    panels.value.forEach((panel, index2) => {\n      panel.size = numSizes[index2];\n    });\n  };\n  const onMoveEnd = () => {\n    movingIndex.value = null;\n    cachePxSizes = [];\n  };\n  const cacheCollapsedSize = [];\n  const onCollapse = (index, type) => {\n    const currentSizes = pxSizes.value;\n    const currentIndex = type === \"start\" ? index : index + 1;\n    const targetIndex = type === \"start\" ? index + 1 : index;\n    const currentSize = currentSizes[currentIndex];\n    const targetSize = currentSizes[targetIndex];\n    if (currentSize !== 0 && targetSize !== 0) {\n      currentSizes[currentIndex] = 0;\n      currentSizes[targetIndex] += currentSize;\n      cacheCollapsedSize[index] = currentSize;\n    } else {\n      const totalSize = currentSize + targetSize;\n      const targetCacheCollapsedSize = cacheCollapsedSize[index];\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;\n      currentSizes[targetIndex] = targetCacheCollapsedSize;\n      currentSizes[currentIndex] = currentCacheCollapsedSize;\n    }\n    panels.value.forEach((panel, index2) => {\n      panel.size = currentSizes[index2];\n    });\n  };\n  return {\n    onMoveStart,\n    onMoving,\n    onMoveEnd,\n    movingIndex,\n    onCollapse\n  };\n}\nexport { useResize };","map":{"version":3,"names":["useResize","panels","containerSize","pxSizes","ptg2px","ptg","value","getLimitSize","str","defaultLimit","isPct","getPct","isPx","getPx","movingIndex","ref","cachePxSizes","limitSizes","computed","map","item","min","max","onMoveStart","index","confirmed","onMoving","offset","_a","_b","confirmedIndex","i","mergedIndex","numSizes","nextIndex","startMinSize","endMinSize","startMaxSize","endMaxSize","mergedOffset","forEach","panel","index2","size","onMoveEnd","cacheCollapsedSize","onCollapse","type","currentSizes","currentIndex","targetIndex","currentSize","targetSize","totalSize","targetCacheCollapsedSize","currentCacheCollapsedSize"],"sources":["../../../../../../../packages/components/splitter/src/hooks/useResize.ts"],"sourcesContent":["import { computed, ref } from 'vue'\nimport { getPct, getPx, isPct, isPx } from './useSize'\nimport type { ComputedRef, Ref } from 'vue'\nimport type { PanelItemState } from '../type'\n\nexport function useResize(\n  panels: Ref<PanelItemState[]>,\n  containerSize: ComputedRef<number>,\n  pxSizes: ComputedRef<number[]>\n) {\n  const ptg2px = (ptg: number) => ptg * containerSize.value || 0\n\n  function getLimitSize(\n    str: string | number | undefined,\n    defaultLimit: number\n  ) {\n    if (isPct(str)) {\n      return ptg2px(getPct(str))\n    } else if (isPx(str)) {\n      return getPx(str)\n    }\n    return str ?? defaultLimit\n  }\n\n  const movingIndex = ref<{\n    index: number\n    confirmed: boolean\n  } | null>(null)\n\n  let cachePxSizes: number[] = []\n\n  const limitSizes = computed(() =>\n    panels.value.map((item) => [item.min, item.max])\n  )\n\n  const onMoveStart = (index: number) => {\n    movingIndex.value = { index, confirmed: false }\n    cachePxSizes = pxSizes.value\n  }\n\n  const onMoving = (index: number, offset: number) => {\n    let confirmedIndex: number | null = null\n\n    // When overlapping, find the nearest draggable index\n    if ((!movingIndex.value || !movingIndex.value.confirmed) && offset !== 0) {\n      if (offset > 0) {\n        confirmedIndex = index\n        movingIndex.value = { index, confirmed: true }\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cachePxSizes[i]! > 0) {\n            confirmedIndex = i\n            movingIndex.value = { index: i, confirmed: true }\n            break\n          }\n        }\n      }\n    }\n    const mergedIndex = confirmedIndex ?? movingIndex.value?.index ?? index\n\n    const numSizes = [...cachePxSizes]\n    const nextIndex = mergedIndex + 1\n\n    // Handle the maximum and minimum edge cases\n    const startMinSize = getLimitSize(limitSizes.value[mergedIndex]![0], 0)\n    const endMinSize = getLimitSize(limitSizes.value[nextIndex]![0], 0)\n    const startMaxSize = getLimitSize(\n      limitSizes.value[mergedIndex]![1],\n      containerSize.value || 0\n    )\n    const endMaxSize = getLimitSize(\n      limitSizes.value[nextIndex]![1],\n      containerSize.value || 0\n    )\n\n    let mergedOffset = offset\n\n    if (numSizes[mergedIndex]! + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex]!\n    }\n    if (numSizes[nextIndex]! - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex]! - endMinSize\n    }\n    if (numSizes[mergedIndex]! + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex]!\n    }\n    if (numSizes[nextIndex]! - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex]! - endMaxSize\n    }\n\n    numSizes[mergedIndex]! += mergedOffset\n    numSizes[nextIndex]! -= mergedOffset\n\n    panels.value.forEach((panel, index) => {\n      panel.size = numSizes[index]\n    })\n  }\n\n  const onMoveEnd = () => {\n    movingIndex.value = null\n    cachePxSizes = []\n  }\n\n  const cacheCollapsedSize: number[] = []\n  const onCollapse = (index: number, type: 'start' | 'end') => {\n    const currentSizes = pxSizes.value\n\n    const currentIndex = type === 'start' ? index : index + 1\n    const targetIndex = type === 'start' ? index + 1 : index\n\n    const currentSize = currentSizes[currentIndex]!\n    const targetSize = currentSizes[targetIndex]!\n\n    if (currentSize !== 0 && targetSize !== 0) {\n      currentSizes[currentIndex] = 0\n      currentSizes[targetIndex]! += currentSize\n      cacheCollapsedSize[index] = currentSize\n    } else {\n      const totalSize = currentSize + targetSize\n\n      const targetCacheCollapsedSize = cacheCollapsedSize[index]!\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize\n\n      currentSizes[targetIndex] = targetCacheCollapsedSize\n      currentSizes[currentIndex] = currentCacheCollapsedSize\n    }\n\n    panels.value.forEach((panel, index) => {\n      panel.size = currentSizes[index]\n    })\n  }\n\n  return { onMoveStart, onMoving, onMoveEnd, movingIndex, onCollapse }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}