{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { getEmojiSequenceFromString, getUnqualifiedEmojiSequence } from '../cleanup.mjs';\nimport { getEmojiSequenceKeyword } from '../format.mjs';\nimport '../convert.mjs';\nimport '../data.mjs';\nconst componentStatus = \"component\";\nconst allowedStatus = /* @__PURE__ */new Set([componentStatus, \"fully-qualified\", \"minimally-qualified\", \"unqualified\"]);\nfunction getQualifiedTestData(data) {\n  const results = /* @__PURE__ */Object.create(null);\n  for (const key in data) {\n    const item = data[key];\n    const sequence = getUnqualifiedEmojiSequence(item.sequence);\n    const shortKey = getEmojiSequenceKeyword(sequence);\n    if (!results[shortKey] || results[shortKey].sequence.length < sequence.length) {\n      results[shortKey] = item;\n    }\n  }\n  return results;\n}\nfunction parseEmojiTestFile(data) {\n  const results = /* @__PURE__ */Object.create(null);\n  let group;\n  let subgroup;\n  data.split(\"\\n\").forEach(line => {\n    line = line.trim();\n    const parts = line.split(\"#\");\n    if (parts.length < 2) {\n      return;\n    }\n    const firstChunk = parts.shift().trim();\n    const secondChunk = parts.join(\"#\").trim();\n    if (!firstChunk) {\n      const commentParts = secondChunk.split(\":\");\n      if (commentParts.length === 2) {\n        const key2 = commentParts[0].trim();\n        const value = commentParts[1].trim();\n        switch (key2) {\n          case \"group\":\n            group = value;\n            subgroup = void 0;\n            break;\n          case \"subgroup\":\n            subgroup = value;\n            break;\n        }\n      }\n      return;\n    }\n    if (!group || !subgroup) {\n      return;\n    }\n    const firstChunkParts = firstChunk.split(\";\");\n    if (firstChunkParts.length !== 2) {\n      return;\n    }\n    const code = firstChunkParts[0].trim();\n    if (!code || !code.match(/^[A-F0-9]+[A-F0-9\\s]*[A-F0-9]+$/)) {\n      return;\n    }\n    const status = firstChunkParts[1].trim();\n    if (!allowedStatus.has(status)) {\n      throw new Error(`Bad emoji type: ${status}`);\n    }\n    const secondChunkParts = secondChunk.split(/\\s+/);\n    if (secondChunkParts.length < 3) {\n      throw new Error(`Bad emoji comment for: ${code}`);\n    }\n    const emoji = secondChunkParts.shift();\n    const version = secondChunkParts.shift();\n    if (version.slice(0, 1) !== \"E\") {\n      throw new Error(`Bad unicode version \"${version}\" for: ${code}`);\n    }\n    const name = secondChunkParts.join(\" \");\n    const sequence = getEmojiSequenceFromString(code);\n    const key = getEmojiSequenceKeyword(sequence);\n    if (results[key]) {\n      throw new Error(`Duplicate entry for \"${code}\"`);\n    }\n    results[key] = {\n      group,\n      subgroup,\n      sequence,\n      emoji,\n      status,\n      version,\n      name\n    };\n  });\n  return getQualifiedTestData(results);\n}\nexport { componentStatus, parseEmojiTestFile };","map":{"version":3,"names":["getEmojiSequenceFromString","getUnqualifiedEmojiSequence","getEmojiSequenceKeyword","componentStatus","allowedStatus","Set","getQualifiedTestData","data","results","Object","create","key","item","sequence","shortKey","length","parseEmojiTestFile","group","subgroup","split","forEach","line","trim","parts","firstChunk","shift","secondChunk","join","commentParts","key2","value","firstChunkParts","code","match","status","has","Error","secondChunkParts","emoji","version","slice","name"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/@iconify/utils/lib/emoji/test/parse.mjs"],"sourcesContent":["import { getEmojiSequenceFromString, getUnqualifiedEmojiSequence } from '../cleanup.mjs';\nimport { getEmojiSequenceKeyword } from '../format.mjs';\nimport '../convert.mjs';\nimport '../data.mjs';\n\nconst componentStatus = \"component\";\nconst allowedStatus = /* @__PURE__ */ new Set([\n  componentStatus,\n  \"fully-qualified\",\n  \"minimally-qualified\",\n  \"unqualified\"\n]);\nfunction getQualifiedTestData(data) {\n  const results = /* @__PURE__ */ Object.create(null);\n  for (const key in data) {\n    const item = data[key];\n    const sequence = getUnqualifiedEmojiSequence(item.sequence);\n    const shortKey = getEmojiSequenceKeyword(sequence);\n    if (!results[shortKey] || results[shortKey].sequence.length < sequence.length) {\n      results[shortKey] = item;\n    }\n  }\n  return results;\n}\nfunction parseEmojiTestFile(data) {\n  const results = /* @__PURE__ */ Object.create(null);\n  let group;\n  let subgroup;\n  data.split(\"\\n\").forEach((line) => {\n    line = line.trim();\n    const parts = line.split(\"#\");\n    if (parts.length < 2) {\n      return;\n    }\n    const firstChunk = parts.shift().trim();\n    const secondChunk = parts.join(\"#\").trim();\n    if (!firstChunk) {\n      const commentParts = secondChunk.split(\":\");\n      if (commentParts.length === 2) {\n        const key2 = commentParts[0].trim();\n        const value = commentParts[1].trim();\n        switch (key2) {\n          case \"group\":\n            group = value;\n            subgroup = void 0;\n            break;\n          case \"subgroup\":\n            subgroup = value;\n            break;\n        }\n      }\n      return;\n    }\n    if (!group || !subgroup) {\n      return;\n    }\n    const firstChunkParts = firstChunk.split(\";\");\n    if (firstChunkParts.length !== 2) {\n      return;\n    }\n    const code = firstChunkParts[0].trim();\n    if (!code || !code.match(/^[A-F0-9]+[A-F0-9\\s]*[A-F0-9]+$/)) {\n      return;\n    }\n    const status = firstChunkParts[1].trim();\n    if (!allowedStatus.has(status)) {\n      throw new Error(`Bad emoji type: ${status}`);\n    }\n    const secondChunkParts = secondChunk.split(/\\s+/);\n    if (secondChunkParts.length < 3) {\n      throw new Error(`Bad emoji comment for: ${code}`);\n    }\n    const emoji = secondChunkParts.shift();\n    const version = secondChunkParts.shift();\n    if (version.slice(0, 1) !== \"E\") {\n      throw new Error(`Bad unicode version \"${version}\" for: ${code}`);\n    }\n    const name = secondChunkParts.join(\" \");\n    const sequence = getEmojiSequenceFromString(code);\n    const key = getEmojiSequenceKeyword(sequence);\n    if (results[key]) {\n      throw new Error(`Duplicate entry for \"${code}\"`);\n    }\n    results[key] = {\n      group,\n      subgroup,\n      sequence,\n      emoji,\n      status,\n      version,\n      name\n    };\n  });\n  return getQualifiedTestData(results);\n}\n\nexport { componentStatus, parseEmojiTestFile };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}