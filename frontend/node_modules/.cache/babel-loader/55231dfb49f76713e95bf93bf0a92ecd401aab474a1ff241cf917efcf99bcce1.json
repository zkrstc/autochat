{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { minUTF32, startUTF32Pair1, startUTF32Pair2, endUTF32Pair } from './data.mjs';\nfunction getEmojiCodePoint(code) {\n  return parseInt(code, 16);\n}\nfunction utf32FirstNum(code) {\n  return (code - minUTF32 >> 10 | 0) + startUTF32Pair1;\n}\nfunction utf32SecondNum(code) {\n  return (code - minUTF32 & 1023) + startUTF32Pair2;\n}\nfunction splitUTF32Number(code) {\n  if (code >= minUTF32) {\n    return [utf32FirstNum(code), utf32SecondNum(code)];\n  }\n}\nfunction isUTF32SplitNumber(value) {\n  if (value >= startUTF32Pair1) {\n    if (value < startUTF32Pair2) {\n      return 1;\n    }\n    if (value < endUTF32Pair) {\n      return 2;\n    }\n  }\n  return false;\n}\nfunction mergeUTF32Numbers(part1, part2) {\n  if (part1 < startUTF32Pair1 || part1 >= startUTF32Pair2 || part2 < startUTF32Pair2 || part2 >= endUTF32Pair) {\n    return;\n  }\n  return (part1 - startUTF32Pair1 << 10) + (part2 - startUTF32Pair2) + minUTF32;\n}\nfunction getEmojiUnicode(code) {\n  return String.fromCodePoint(typeof code === \"number\" ? code : getEmojiCodePoint(code));\n}\nfunction convertEmojiSequenceToUTF16(numbers) {\n  const results = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const code = numbers[i];\n    if (code >= minUTF32) {\n      results.push(utf32FirstNum(code));\n      results.push(utf32SecondNum(code));\n    } else {\n      results.push(code);\n    }\n  }\n  return results;\n}\nfunction convertEmojiSequenceToUTF32(numbers, throwOnError = true) {\n  const results = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const code = numbers[i];\n    if (code >= minUTF32) {\n      results.push(code);\n      continue;\n    }\n    const part = isUTF32SplitNumber(code);\n    if (!part) {\n      results.push(code);\n      continue;\n    }\n    if (part === 1 && numbers.length > i + 1) {\n      const merged = mergeUTF32Numbers(code, numbers[i + 1]);\n      if (merged) {\n        i++;\n        results.push(merged);\n        continue;\n      }\n    }\n    if (throwOnError) {\n      const nextCode = numbers[i + 1];\n      throw new Error(`Invalid UTF-16 sequence: ${code.toString(16)}-${nextCode ? nextCode.toString(16) : \"undefined\"}`);\n    }\n    results.push(code);\n  }\n  return results;\n}\nexport { convertEmojiSequenceToUTF16, convertEmojiSequenceToUTF32, getEmojiCodePoint, getEmojiUnicode, isUTF32SplitNumber, mergeUTF32Numbers, splitUTF32Number };","map":{"version":3,"names":["minUTF32","startUTF32Pair1","startUTF32Pair2","endUTF32Pair","getEmojiCodePoint","code","parseInt","utf32FirstNum","utf32SecondNum","splitUTF32Number","isUTF32SplitNumber","value","mergeUTF32Numbers","part1","part2","getEmojiUnicode","String","fromCodePoint","convertEmojiSequenceToUTF16","numbers","results","i","length","push","convertEmojiSequenceToUTF32","throwOnError","part","merged","nextCode","Error","toString"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/@iconify/utils/lib/emoji/convert.mjs"],"sourcesContent":["import { minUTF32, startUTF32Pair1, startUTF32Pair2, endUTF32Pair } from './data.mjs';\n\nfunction getEmojiCodePoint(code) {\n  return parseInt(code, 16);\n}\nfunction utf32FirstNum(code) {\n  return (code - minUTF32 >> 10 | 0) + startUTF32Pair1;\n}\nfunction utf32SecondNum(code) {\n  return (code - minUTF32 & 1023) + startUTF32Pair2;\n}\nfunction splitUTF32Number(code) {\n  if (code >= minUTF32) {\n    return [utf32FirstNum(code), utf32SecondNum(code)];\n  }\n}\nfunction isUTF32SplitNumber(value) {\n  if (value >= startUTF32Pair1) {\n    if (value < startUTF32Pair2) {\n      return 1;\n    }\n    if (value < endUTF32Pair) {\n      return 2;\n    }\n  }\n  return false;\n}\nfunction mergeUTF32Numbers(part1, part2) {\n  if (part1 < startUTF32Pair1 || part1 >= startUTF32Pair2 || part2 < startUTF32Pair2 || part2 >= endUTF32Pair) {\n    return;\n  }\n  return (part1 - startUTF32Pair1 << 10) + (part2 - startUTF32Pair2) + minUTF32;\n}\nfunction getEmojiUnicode(code) {\n  return String.fromCodePoint(\n    typeof code === \"number\" ? code : getEmojiCodePoint(code)\n  );\n}\nfunction convertEmojiSequenceToUTF16(numbers) {\n  const results = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const code = numbers[i];\n    if (code >= minUTF32) {\n      results.push(utf32FirstNum(code));\n      results.push(utf32SecondNum(code));\n    } else {\n      results.push(code);\n    }\n  }\n  return results;\n}\nfunction convertEmojiSequenceToUTF32(numbers, throwOnError = true) {\n  const results = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const code = numbers[i];\n    if (code >= minUTF32) {\n      results.push(code);\n      continue;\n    }\n    const part = isUTF32SplitNumber(code);\n    if (!part) {\n      results.push(code);\n      continue;\n    }\n    if (part === 1 && numbers.length > i + 1) {\n      const merged = mergeUTF32Numbers(code, numbers[i + 1]);\n      if (merged) {\n        i++;\n        results.push(merged);\n        continue;\n      }\n    }\n    if (throwOnError) {\n      const nextCode = numbers[i + 1];\n      throw new Error(\n        `Invalid UTF-16 sequence: ${code.toString(16)}-${nextCode ? nextCode.toString(16) : \"undefined\"}`\n      );\n    }\n    results.push(code);\n  }\n  return results;\n}\n\nexport { convertEmojiSequenceToUTF16, convertEmojiSequenceToUTF32, getEmojiCodePoint, getEmojiUnicode, isUTF32SplitNumber, mergeUTF32Numbers, splitUTF32Number };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}