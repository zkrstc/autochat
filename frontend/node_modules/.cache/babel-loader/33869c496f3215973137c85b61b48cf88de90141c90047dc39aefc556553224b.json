{"ast":null,"code":"import { feasibleTree } from './feasible-tree.js';\nimport { networkSimplex } from './network-simplex.js';\nimport { longestPath } from './util.js';\nexport { rank };\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch (g.graph().ranker) {\n    case 'network-simplex':\n      networkSimplexRanker(g);\n      break;\n    case 'tight-tree':\n      tightTreeRanker(g);\n      break;\n    case 'longest-path':\n      longestPathRanker(g);\n      break;\n    default:\n      networkSimplexRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = longestPath;\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}","map":{"version":3,"names":["feasibleTree","networkSimplex","longestPath","rank","g","graph","ranker","networkSimplexRanker","tightTreeRanker","longestPathRanker"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/dagre-d3-es/src/dagre/rank/index.js"],"sourcesContent":["import { feasibleTree } from './feasible-tree.js';\nimport { networkSimplex } from './network-simplex.js';\nimport { longestPath } from './util.js';\n\nexport { rank };\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch (g.graph().ranker) {\n    case 'network-simplex':\n      networkSimplexRanker(g);\n      break;\n    case 'tight-tree':\n      tightTreeRanker(g);\n      break;\n    case 'longest-path':\n      longestPathRanker(g);\n      break;\n    default:\n      networkSimplexRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = longestPath;\n\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\n\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,oBAAoB;AACjD,SAASC,cAAc,QAAQ,sBAAsB;AACrD,SAASC,WAAW,QAAQ,WAAW;AAEvC,SAASC,IAAI;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,IAAIA,CAACC,CAAC,EAAE;EACf,QAAQA,CAAC,CAACC,KAAK,CAAC,CAAC,CAACC,MAAM;IACtB,KAAK,iBAAiB;MACpBC,oBAAoB,CAACH,CAAC,CAAC;MACvB;IACF,KAAK,YAAY;MACfI,eAAe,CAACJ,CAAC,CAAC;MAClB;IACF,KAAK,cAAc;MACjBK,iBAAiB,CAACL,CAAC,CAAC;MACpB;IACF;MACEG,oBAAoB,CAACH,CAAC,CAAC;EAC3B;AACF;;AAEA;AACA,IAAIK,iBAAiB,GAAGP,WAAW;AAEnC,SAASM,eAAeA,CAACJ,CAAC,EAAE;EAC1BF,WAAW,CAACE,CAAC,CAAC;EACdJ,YAAY,CAACI,CAAC,CAAC;AACjB;AAEA,SAASG,oBAAoBA,CAACH,CAAC,EAAE;EAC/BH,cAAc,CAACG,CAAC,CAAC;AACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}