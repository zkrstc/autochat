{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport { decodeEntities } from \"./chunk-O4NI6UNU.mjs\";\nimport { __name, common_default, getConfig2 as getConfig, hasKatex, log, renderKatex } from \"./chunk-YTJNT7DU.mjs\";\n\n// src/rendering-util/createText.ts\nimport { select } from \"d3\";\n\n// src/rendering-util/handle-markdown-text.ts\nimport { marked } from \"marked\";\nimport { dedent } from \"ts-dedent\";\nfunction preprocessMarkdown(markdown, {\n  markdownAutoWrap\n}) {\n  const withoutBR = markdown.replace(/<br\\/>/g, \"\\n\");\n  const withoutMultipleNewlines = withoutBR.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = dedent(withoutMultipleNewlines);\n  if (markdownAutoWrap === false) {\n    return withoutExtraSpaces.replace(/ /g, \"&nbsp;\");\n  }\n  return withoutExtraSpaces;\n}\n__name(preprocessMarkdown, \"preprocessMarkdown\");\nfunction markdownToLines(markdown, config = {}) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown, config);\n  const nodes = marked.lexer(preprocessedMarkdown);\n  const lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType = \"normal\") {\n    if (node.type === \"text\") {\n      const textLines = node.text.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach(word => {\n          word = word.replace(/&#39;/g, `'`);\n          if (word) {\n            lines[currentLine].push({\n              content: word,\n              type: parentType\n            });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"em\") {\n      node.tokens.forEach(contentNode => {\n        processNode(contentNode, node.type);\n      });\n    } else if (node.type === \"html\") {\n      lines[currentLine].push({\n        content: node.text,\n        type: \"normal\"\n      });\n    }\n  }\n  __name(processNode, \"processNode\");\n  nodes.forEach(treeNode => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.tokens?.forEach(contentNode => {\n        processNode(contentNode);\n      });\n    } else if (treeNode.type === \"html\") {\n      lines[currentLine].push({\n        content: treeNode.text,\n        type: \"normal\"\n      });\n    }\n  });\n  return lines;\n}\n__name(markdownToLines, \"markdownToLines\");\nfunction markdownToHTML(markdown, {\n  markdownAutoWrap\n} = {}) {\n  const nodes = marked.lexer(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      if (markdownAutoWrap === false) {\n        return node.text.replace(/\\n */g, \"<br/>\").replace(/ /g, \"&nbsp;\");\n      }\n      return node.text.replace(/\\n */g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.tokens?.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"em\") {\n      return `<em>${node.tokens?.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.tokens?.map(output).join(\"\")}</p>`;\n    } else if (node.type === \"space\") {\n      return \"\";\n    } else if (node.type === \"html\") {\n      return `${node.text}`;\n    } else if (node.type === \"escape\") {\n      return node.text;\n    }\n    return `Unsupported markdown: ${node.type}`;\n  }\n  __name(output, \"output\");\n  return nodes.map(output).join(\"\");\n}\n__name(markdownToHTML, \"markdownToHTML\");\n\n// src/rendering-util/splitText.ts\nfunction splitTextToChars(text) {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map(s => s.segment);\n  }\n  return [...text];\n}\n__name(splitTextToChars, \"splitTextToChars\");\nfunction splitWordToFitWidth(checkFit, word) {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\n__name(splitWordToFitWidth, \"splitWordToFitWidth\");\nfunction splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {\n  if (remainingChars.length === 0) {\n    return [{\n      content: usedChars.join(\"\"),\n      type\n    }, {\n      content: \"\",\n      type\n    }];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{\n    content: newWord.join(\"\"),\n    type\n  }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [{\n    content: usedChars.join(\"\"),\n    type\n  }, {\n    content: remainingChars.join(\"\"),\n    type\n  }];\n}\n__name(splitWordToFitWidthRecursion, \"splitWordToFitWidthRecursion\");\nfunction splitLineToFitWidth(line, checkFit) {\n  if (line.some(({\n    content\n  }) => content.includes(\"\\n\"))) {\n    throw new Error(\"splitLineToFitWidth does not support newlines in the line\");\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\n__name(splitLineToFitWidth, \"splitLineToFitWidth\");\nfunction splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {\n  if (words.length === 0) {\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = \"\";\n  if (words[0].content === \" \") {\n    joiner = \" \";\n    words.shift();\n  }\n  const nextWord = words.shift() ?? {\n    content: \" \",\n    type: \"normal\"\n  };\n  const lineWithNextWord = [...newLine];\n  if (joiner !== \"\") {\n    lineWithNextWord.push({\n      content: joiner,\n      type: \"normal\"\n    });\n  }\n  lineWithNextWord.push(nextWord);\n  if (checkFit(lineWithNextWord)) {\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n  if (newLine.length > 0) {\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\n__name(splitLineToFitWidthRecursion, \"splitLineToFitWidthRecursion\");\n\n// src/rendering-util/createText.ts\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\n__name(applyStyle, \"applyStyle\");\nasync function addHtmlSpan(element, node, width, classes, addBackground = false) {\n  const fo = element.append(\"foreignObject\");\n  fo.attr(\"width\", `${10 * width}px`);\n  fo.attr(\"height\", `${10 * width}px`);\n  const div = fo.append(\"xhtml:div\");\n  let label = node.label;\n  if (node.label && hasKatex(node.label)) {\n    label = await renderKatex(node.label.replace(common_default.lineBreakRegex, \"\\n\"), getConfig());\n  }\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  const span = div.append(\"span\");\n  span.html(label);\n  applyStyle(span, node.labelStyle);\n  span.attr(\"class\", `${labelClass} ${classes}`);\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"line-height\", \"1.5\");\n  div.style(\"max-width\", width + \"px\");\n  div.style(\"text-align\", \"center\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  if (addBackground) {\n    div.attr(\"class\", \"labelBkg\");\n  }\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  return fo.node();\n}\n__name(addHtmlSpan, \"addHtmlSpan\");\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\n__name(createTspan, \"createTspan\");\nfunction computeWidthOfText(parentNode, lineHeight, line) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\n__name(computeWidthOfText, \"computeWidthOfText\");\nfunction computeDimensionOfText(parentNode, lineHeight, text) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{\n    content: text,\n    type: \"normal\"\n  }]);\n  const textDimension = testSpan.node()?.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\n__name(computeDimensionOfText, \"computeDimensionOfText\");\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  const bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\").attr(\"style\", \"stroke: none\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    const checkWidth = /* @__PURE__ */__name(line2 => computeWidthOfText(labelGroup, lineHeight, line2) <= width, \"checkWidth\");\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", bbox.x - padding).attr(\"y\", bbox.y - padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\n__name(createFormattedText, \"createFormattedText\");\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"em\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\n__name(updateTextContentAndStyles, \"updateTextContentAndStyles\");\nfunction replaceIconSubstring(text) {\n  return text.replace(/fa[bklrs]?:fa-[\\w-]+/g,\n  // cspell: disable-line\n  s => `<i class='${s.replace(\":\", \" \")}'></i>`);\n}\n__name(replaceIconSubstring, \"replaceIconSubstring\");\nvar createText = /* @__PURE__ */__name(async (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width = 200,\n  addSvgBackground = false\n} = {}, config) => {\n  log.debug(\"XYZ createText\", text, style, isTitle, classes, useHtmlLabels, isNode, \"addSvgBackground: \", addSvgBackground);\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text, config);\n    const decodedReplacedText = replaceIconSubstring(decodeEntities(htmlText));\n    const inputForKatex = text.replace(/\\\\\\\\/g, \"\\\\\");\n    const node = {\n      isNode,\n      label: hasKatex(text) ? inputForKatex : decodedReplacedText,\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    const vertexNode = await addHtmlSpan(el, node, width, classes, addSvgBackground);\n    return vertexNode;\n  } else {\n    const sanitizeBR = text.replace(/<br\\s*\\/?>/g, \"<br/>\");\n    const structuredText = markdownToLines(sanitizeBR.replace(\"<br>\", \"<br/>\"), config);\n    const svgLabel = createFormattedText(width, el, structuredText, text ? addSvgBackground : false);\n    if (isNode) {\n      if (/stroke:/.exec(style)) {\n        style = style.replace(\"stroke:\", \"lineColor:\");\n      }\n      const nodeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).attr(\"style\", nodeLabelTextStyle);\n    } else {\n      const edgeLabelRectStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/background:/g, \"fill:\");\n      select(svgLabel).select(\"rect\").attr(\"style\", edgeLabelRectStyle.replace(/background:/g, \"fill:\"));\n      const edgeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).select(\"text\").attr(\"style\", edgeLabelTextStyle);\n    }\n    return svgLabel;\n  }\n}, \"createText\");\nexport { computeDimensionOfText, replaceIconSubstring, createText };","map":{"version":3,"names":["decodeEntities","__name","common_default","getConfig2","getConfig","hasKatex","log","renderKatex","select","marked","dedent","preprocessMarkdown","markdown","markdownAutoWrap","withoutBR","replace","withoutMultipleNewlines","withoutExtraSpaces","markdownToLines","config","preprocessedMarkdown","nodes","lexer","lines","currentLine","processNode","node","parentType","type","textLines","text","split","forEach","textLine","index","push","word","content","tokens","contentNode","treeNode","markdownToHTML","output","map","join","splitTextToChars","Intl","Segmenter","segment","s","splitWordToFitWidth","checkFit","characters","splitWordToFitWidthRecursion","usedChars","remainingChars","length","nextChar","rest","newWord","shift","splitLineToFitWidth","line","some","includes","Error","splitLineToFitWidthRecursion","words","newLine","joiner","nextWord","lineWithNextWord","unshift","applyStyle","dom","styleFn","attr","addHtmlSpan","element","width","classes","addBackground","fo","append","div","label","lineBreakRegex","labelClass","isNode","span","html","labelStyle","style","bbox","getBoundingClientRect","createTspan","textElement","lineIndex","lineHeight","computeWidthOfText","parentNode","testElement","testSpan","updateTextContentAndStyles","textLength","getComputedTextLength","remove","computeDimensionOfText","textDimension","createFormattedText","g","structuredText","labelGroup","bkg","insert","checkWidth","line2","linesUnderWidth","preparedLine","tspan","getBBox","padding","x","y","height","wrappedLine","innerTspan","replaceIconSubstring","createText","el","isTitle","useHtmlLabels","addSvgBackground","debug","htmlText","decodedReplacedText","inputForKatex","vertexNode","sanitizeBR","svgLabel","exec","nodeLabelTextStyle","edgeLabelRectStyle","edgeLabelTextStyle"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/mermaid/dist/chunks/mermaid.core/chunk-C3MQ5ANM.mjs"],"sourcesContent":["import {\n  decodeEntities\n} from \"./chunk-O4NI6UNU.mjs\";\nimport {\n  __name,\n  common_default,\n  getConfig2 as getConfig,\n  hasKatex,\n  log,\n  renderKatex\n} from \"./chunk-YTJNT7DU.mjs\";\n\n// src/rendering-util/createText.ts\nimport { select } from \"d3\";\n\n// src/rendering-util/handle-markdown-text.ts\nimport { marked } from \"marked\";\nimport { dedent } from \"ts-dedent\";\nfunction preprocessMarkdown(markdown, { markdownAutoWrap }) {\n  const withoutBR = markdown.replace(/<br\\/>/g, \"\\n\");\n  const withoutMultipleNewlines = withoutBR.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = dedent(withoutMultipleNewlines);\n  if (markdownAutoWrap === false) {\n    return withoutExtraSpaces.replace(/ /g, \"&nbsp;\");\n  }\n  return withoutExtraSpaces;\n}\n__name(preprocessMarkdown, \"preprocessMarkdown\");\nfunction markdownToLines(markdown, config = {}) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown, config);\n  const nodes = marked.lexer(preprocessedMarkdown);\n  const lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType = \"normal\") {\n    if (node.type === \"text\") {\n      const textLines = node.text.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach((word) => {\n          word = word.replace(/&#39;/g, `'`);\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"em\") {\n      node.tokens.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    } else if (node.type === \"html\") {\n      lines[currentLine].push({ content: node.text, type: \"normal\" });\n    }\n  }\n  __name(processNode, \"processNode\");\n  nodes.forEach((treeNode) => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.tokens?.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    } else if (treeNode.type === \"html\") {\n      lines[currentLine].push({ content: treeNode.text, type: \"normal\" });\n    }\n  });\n  return lines;\n}\n__name(markdownToLines, \"markdownToLines\");\nfunction markdownToHTML(markdown, { markdownAutoWrap } = {}) {\n  const nodes = marked.lexer(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      if (markdownAutoWrap === false) {\n        return node.text.replace(/\\n */g, \"<br/>\").replace(/ /g, \"&nbsp;\");\n      }\n      return node.text.replace(/\\n */g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.tokens?.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"em\") {\n      return `<em>${node.tokens?.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.tokens?.map(output).join(\"\")}</p>`;\n    } else if (node.type === \"space\") {\n      return \"\";\n    } else if (node.type === \"html\") {\n      return `${node.text}`;\n    } else if (node.type === \"escape\") {\n      return node.text;\n    }\n    return `Unsupported markdown: ${node.type}`;\n  }\n  __name(output, \"output\");\n  return nodes.map(output).join(\"\");\n}\n__name(markdownToHTML, \"markdownToHTML\");\n\n// src/rendering-util/splitText.ts\nfunction splitTextToChars(text) {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map((s) => s.segment);\n  }\n  return [...text];\n}\n__name(splitTextToChars, \"splitTextToChars\");\nfunction splitWordToFitWidth(checkFit, word) {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\n__name(splitWordToFitWidth, \"splitWordToFitWidth\");\nfunction splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {\n  if (remainingChars.length === 0) {\n    return [\n      { content: usedChars.join(\"\"), type },\n      { content: \"\", type }\n    ];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{ content: newWord.join(\"\"), type }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [\n    { content: usedChars.join(\"\"), type },\n    { content: remainingChars.join(\"\"), type }\n  ];\n}\n__name(splitWordToFitWidthRecursion, \"splitWordToFitWidthRecursion\");\nfunction splitLineToFitWidth(line, checkFit) {\n  if (line.some(({ content }) => content.includes(\"\\n\"))) {\n    throw new Error(\"splitLineToFitWidth does not support newlines in the line\");\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\n__name(splitLineToFitWidth, \"splitLineToFitWidth\");\nfunction splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {\n  if (words.length === 0) {\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = \"\";\n  if (words[0].content === \" \") {\n    joiner = \" \";\n    words.shift();\n  }\n  const nextWord = words.shift() ?? { content: \" \", type: \"normal\" };\n  const lineWithNextWord = [...newLine];\n  if (joiner !== \"\") {\n    lineWithNextWord.push({ content: joiner, type: \"normal\" });\n  }\n  lineWithNextWord.push(nextWord);\n  if (checkFit(lineWithNextWord)) {\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n  if (newLine.length > 0) {\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\n__name(splitLineToFitWidthRecursion, \"splitLineToFitWidthRecursion\");\n\n// src/rendering-util/createText.ts\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\n__name(applyStyle, \"applyStyle\");\nasync function addHtmlSpan(element, node, width, classes, addBackground = false) {\n  const fo = element.append(\"foreignObject\");\n  fo.attr(\"width\", `${10 * width}px`);\n  fo.attr(\"height\", `${10 * width}px`);\n  const div = fo.append(\"xhtml:div\");\n  let label = node.label;\n  if (node.label && hasKatex(node.label)) {\n    label = await renderKatex(node.label.replace(common_default.lineBreakRegex, \"\\n\"), getConfig());\n  }\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  const span = div.append(\"span\");\n  span.html(label);\n  applyStyle(span, node.labelStyle);\n  span.attr(\"class\", `${labelClass} ${classes}`);\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"line-height\", \"1.5\");\n  div.style(\"max-width\", width + \"px\");\n  div.style(\"text-align\", \"center\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  if (addBackground) {\n    div.attr(\"class\", \"labelBkg\");\n  }\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  return fo.node();\n}\n__name(addHtmlSpan, \"addHtmlSpan\");\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\n__name(createTspan, \"createTspan\");\nfunction computeWidthOfText(parentNode, lineHeight, line) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\n__name(computeWidthOfText, \"computeWidthOfText\");\nfunction computeDimensionOfText(parentNode, lineHeight, text) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{ content: text, type: \"normal\" }]);\n  const textDimension = testSpan.node()?.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\n__name(computeDimensionOfText, \"computeDimensionOfText\");\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  const bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\").attr(\"style\", \"stroke: none\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    const checkWidth = /* @__PURE__ */ __name((line2) => computeWidthOfText(labelGroup, lineHeight, line2) <= width, \"checkWidth\");\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", bbox.x - padding).attr(\"y\", bbox.y - padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\n__name(createFormattedText, \"createFormattedText\");\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"em\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\n__name(updateTextContentAndStyles, \"updateTextContentAndStyles\");\nfunction replaceIconSubstring(text) {\n  return text.replace(\n    /fa[bklrs]?:fa-[\\w-]+/g,\n    // cspell: disable-line\n    (s) => `<i class='${s.replace(\":\", \" \")}'></i>`\n  );\n}\n__name(replaceIconSubstring, \"replaceIconSubstring\");\nvar createText = /* @__PURE__ */ __name(async (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width = 200,\n  addSvgBackground = false\n} = {}, config) => {\n  log.debug(\n    \"XYZ createText\",\n    text,\n    style,\n    isTitle,\n    classes,\n    useHtmlLabels,\n    isNode,\n    \"addSvgBackground: \",\n    addSvgBackground\n  );\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text, config);\n    const decodedReplacedText = replaceIconSubstring(decodeEntities(htmlText));\n    const inputForKatex = text.replace(/\\\\\\\\/g, \"\\\\\");\n    const node = {\n      isNode,\n      label: hasKatex(text) ? inputForKatex : decodedReplacedText,\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    const vertexNode = await addHtmlSpan(el, node, width, classes, addSvgBackground);\n    return vertexNode;\n  } else {\n    const sanitizeBR = text.replace(/<br\\s*\\/?>/g, \"<br/>\");\n    const structuredText = markdownToLines(sanitizeBR.replace(\"<br>\", \"<br/>\"), config);\n    const svgLabel = createFormattedText(\n      width,\n      el,\n      structuredText,\n      text ? addSvgBackground : false\n    );\n    if (isNode) {\n      if (/stroke:/.exec(style)) {\n        style = style.replace(\"stroke:\", \"lineColor:\");\n      }\n      const nodeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).attr(\"style\", nodeLabelTextStyle);\n    } else {\n      const edgeLabelRectStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/background:/g, \"fill:\");\n      select(svgLabel).select(\"rect\").attr(\"style\", edgeLabelRectStyle.replace(/background:/g, \"fill:\"));\n      const edgeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).select(\"text\").attr(\"style\", edgeLabelTextStyle);\n    }\n    return svgLabel;\n  }\n}, \"createText\");\n\nexport {\n  computeDimensionOfText,\n  replaceIconSubstring,\n  createText\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}