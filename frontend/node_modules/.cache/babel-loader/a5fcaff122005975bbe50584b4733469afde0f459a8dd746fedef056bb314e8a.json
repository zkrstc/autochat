{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { splitUTF32Number } from '../convert.mjs';\nimport { createUTF16EmojiRegexItem, createSequenceEmojiRegexItem, createSetEmojiRegexItem, createOptionalEmojiRegexItem } from './base.mjs';\nimport { vs16Emoji } from '../data.mjs';\nfunction createEmojiRegexItemForNumbers(numbers) {\n  const utf32 = [];\n  const utf16 = [];\n  numbers.sort((a, b) => a - b);\n  let lastNumber;\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n    if (number === lastNumber) {\n      continue;\n    }\n    lastNumber = number;\n    const split = splitUTF32Number(number);\n    if (!split) {\n      utf16.push(number);\n      continue;\n    }\n    const [first, second] = split;\n    const item = utf32.find(item2 => item2.first === first);\n    if (item) {\n      item.second.push(second);\n      item.numbers.push(number);\n    } else {\n      utf32.push({\n        first,\n        second: [second],\n        numbers: [number]\n      });\n    }\n  }\n  const results = [];\n  if (utf16.length) {\n    results.push(createUTF16EmojiRegexItem(utf16));\n  }\n  if (utf32.length) {\n    const utf32Set = [];\n    for (let i = 0; i < utf32.length; i++) {\n      const item = utf32[i];\n      const secondRegex = createUTF16EmojiRegexItem(item.second);\n      const listItem = utf32Set.find(item2 => item2.second.regex === secondRegex.regex);\n      if (listItem) {\n        listItem.first.push(item.first);\n        listItem.numbers = [...listItem.numbers, ...item.numbers];\n      } else {\n        utf32Set.push({\n          second: secondRegex,\n          first: [item.first],\n          numbers: [...item.numbers]\n        });\n      }\n    }\n    for (let i = 0; i < utf32Set.length; i++) {\n      const item = utf32Set[i];\n      const firstRegex = createUTF16EmojiRegexItem(item.first);\n      const secondRegex = item.second;\n      results.push(createSequenceEmojiRegexItem([firstRegex, secondRegex], item.numbers));\n    }\n  }\n  return results.length === 1 ? results[0] : createSetEmojiRegexItem(results);\n}\nfunction createRegexForNumbersSequence(numbers, optionalVariations = true) {\n  const items = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const num = numbers[i];\n    const split = splitUTF32Number(num);\n    if (!split) {\n      const item = createUTF16EmojiRegexItem([num]);\n      if (optionalVariations && num === vs16Emoji) {\n        items.push(createOptionalEmojiRegexItem(item));\n      } else {\n        items.push(item);\n      }\n    } else {\n      items.push(createUTF16EmojiRegexItem([split[0]]));\n      items.push(createUTF16EmojiRegexItem([split[1]]));\n    }\n  }\n  if (items.length === 1) {\n    return items[0];\n  }\n  const result = createSequenceEmojiRegexItem(items);\n  if (numbers.length === 1 && items[0].type === \"utf16\") {\n    result.numbers = [...numbers];\n  }\n  return result;\n}\nfunction optimiseNumbersSet(set) {\n  const mandatoryMatches = {\n    numbers: [],\n    items: []\n  };\n  const optionalMatches = {\n    numbers: [],\n    items: []\n  };\n  const filteredItems = set.sets.filter(item => {\n    if (item.type === \"optional\") {\n      const parentItem = item.item;\n      if (parentItem.numbers) {\n        optionalMatches.items.push(item);\n        optionalMatches.numbers = optionalMatches.numbers.concat(parentItem.numbers);\n        return false;\n      }\n      return true;\n    }\n    if (item.numbers) {\n      mandatoryMatches.items.push(item);\n      mandatoryMatches.numbers = mandatoryMatches.numbers.concat(item.numbers);\n      return false;\n    }\n    return true;\n  });\n  if (mandatoryMatches.items.length + optionalMatches.items.length < 2) {\n    return set;\n  }\n  const optionalNumbers = new Set(optionalMatches.numbers);\n  let foundMatches = false;\n  mandatoryMatches.numbers = mandatoryMatches.numbers.filter(number => {\n    if (optionalNumbers.has(number)) {\n      foundMatches = true;\n      return false;\n    }\n    return true;\n  });\n  if (mandatoryMatches.items.length) {\n    if (!foundMatches && mandatoryMatches.items.length === 1) {\n      filteredItems.push(mandatoryMatches.items[0]);\n    } else if (mandatoryMatches.numbers.length) {\n      filteredItems.push(createEmojiRegexItemForNumbers(mandatoryMatches.numbers));\n    }\n  }\n  switch (optionalMatches.items.length) {\n    case 0:\n      break;\n    case 1:\n      filteredItems.push(optionalMatches.items[0]);\n      break;\n    default:\n      filteredItems.push(createOptionalEmojiRegexItem(createEmojiRegexItemForNumbers(optionalMatches.numbers)));\n  }\n  return filteredItems.length === 1 ? filteredItems[0] : createSetEmojiRegexItem(filteredItems);\n}\nexport { createEmojiRegexItemForNumbers, createRegexForNumbersSequence, optimiseNumbersSet };","map":{"version":3,"names":["splitUTF32Number","createUTF16EmojiRegexItem","createSequenceEmojiRegexItem","createSetEmojiRegexItem","createOptionalEmojiRegexItem","vs16Emoji","createEmojiRegexItemForNumbers","numbers","utf32","utf16","sort","a","b","lastNumber","i","length","number","split","push","first","second","item","find","item2","results","utf32Set","secondRegex","listItem","regex","firstRegex","createRegexForNumbersSequence","optionalVariations","items","num","result","type","optimiseNumbersSet","set","mandatoryMatches","optionalMatches","filteredItems","sets","filter","parentItem","concat","optionalNumbers","Set","foundMatches","has"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/@iconify/utils/lib/emoji/regex/numbers.mjs"],"sourcesContent":["import { splitUTF32Number } from '../convert.mjs';\nimport { createUTF16EmojiRegexItem, createSequenceEmojiRegexItem, createSetEmojiRegexItem, createOptionalEmojiRegexItem } from './base.mjs';\nimport { vs16Emoji } from '../data.mjs';\n\nfunction createEmojiRegexItemForNumbers(numbers) {\n  const utf32 = [];\n  const utf16 = [];\n  numbers.sort((a, b) => a - b);\n  let lastNumber;\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n    if (number === lastNumber) {\n      continue;\n    }\n    lastNumber = number;\n    const split = splitUTF32Number(number);\n    if (!split) {\n      utf16.push(number);\n      continue;\n    }\n    const [first, second] = split;\n    const item = utf32.find((item2) => item2.first === first);\n    if (item) {\n      item.second.push(second);\n      item.numbers.push(number);\n    } else {\n      utf32.push({\n        first,\n        second: [second],\n        numbers: [number]\n      });\n    }\n  }\n  const results = [];\n  if (utf16.length) {\n    results.push(createUTF16EmojiRegexItem(utf16));\n  }\n  if (utf32.length) {\n    const utf32Set = [];\n    for (let i = 0; i < utf32.length; i++) {\n      const item = utf32[i];\n      const secondRegex = createUTF16EmojiRegexItem(item.second);\n      const listItem = utf32Set.find(\n        (item2) => item2.second.regex === secondRegex.regex\n      );\n      if (listItem) {\n        listItem.first.push(item.first);\n        listItem.numbers = [...listItem.numbers, ...item.numbers];\n      } else {\n        utf32Set.push({\n          second: secondRegex,\n          first: [item.first],\n          numbers: [...item.numbers]\n        });\n      }\n    }\n    for (let i = 0; i < utf32Set.length; i++) {\n      const item = utf32Set[i];\n      const firstRegex = createUTF16EmojiRegexItem(item.first);\n      const secondRegex = item.second;\n      results.push(\n        createSequenceEmojiRegexItem(\n          [firstRegex, secondRegex],\n          item.numbers\n        )\n      );\n    }\n  }\n  return results.length === 1 ? results[0] : createSetEmojiRegexItem(results);\n}\nfunction createRegexForNumbersSequence(numbers, optionalVariations = true) {\n  const items = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const num = numbers[i];\n    const split = splitUTF32Number(num);\n    if (!split) {\n      const item = createUTF16EmojiRegexItem([num]);\n      if (optionalVariations && num === vs16Emoji) {\n        items.push(createOptionalEmojiRegexItem(item));\n      } else {\n        items.push(item);\n      }\n    } else {\n      items.push(createUTF16EmojiRegexItem([split[0]]));\n      items.push(createUTF16EmojiRegexItem([split[1]]));\n    }\n  }\n  if (items.length === 1) {\n    return items[0];\n  }\n  const result = createSequenceEmojiRegexItem(items);\n  if (numbers.length === 1 && items[0].type === \"utf16\") {\n    result.numbers = [...numbers];\n  }\n  return result;\n}\nfunction optimiseNumbersSet(set) {\n  const mandatoryMatches = {\n    numbers: [],\n    items: []\n  };\n  const optionalMatches = {\n    numbers: [],\n    items: []\n  };\n  const filteredItems = set.sets.filter((item) => {\n    if (item.type === \"optional\") {\n      const parentItem = item.item;\n      if (parentItem.numbers) {\n        optionalMatches.items.push(item);\n        optionalMatches.numbers = optionalMatches.numbers.concat(\n          parentItem.numbers\n        );\n        return false;\n      }\n      return true;\n    }\n    if (item.numbers) {\n      mandatoryMatches.items.push(item);\n      mandatoryMatches.numbers = mandatoryMatches.numbers.concat(\n        item.numbers\n      );\n      return false;\n    }\n    return true;\n  });\n  if (mandatoryMatches.items.length + optionalMatches.items.length < 2) {\n    return set;\n  }\n  const optionalNumbers = new Set(optionalMatches.numbers);\n  let foundMatches = false;\n  mandatoryMatches.numbers = mandatoryMatches.numbers.filter((number) => {\n    if (optionalNumbers.has(number)) {\n      foundMatches = true;\n      return false;\n    }\n    return true;\n  });\n  if (mandatoryMatches.items.length) {\n    if (!foundMatches && mandatoryMatches.items.length === 1) {\n      filteredItems.push(mandatoryMatches.items[0]);\n    } else if (mandatoryMatches.numbers.length) {\n      filteredItems.push(\n        createEmojiRegexItemForNumbers(mandatoryMatches.numbers)\n      );\n    }\n  }\n  switch (optionalMatches.items.length) {\n    case 0:\n      break;\n    case 1:\n      filteredItems.push(optionalMatches.items[0]);\n      break;\n    default:\n      filteredItems.push(\n        createOptionalEmojiRegexItem(\n          createEmojiRegexItemForNumbers(optionalMatches.numbers)\n        )\n      );\n  }\n  return filteredItems.length === 1 ? filteredItems[0] : createSetEmojiRegexItem(filteredItems);\n}\n\nexport { createEmojiRegexItemForNumbers, createRegexForNumbersSequence, optimiseNumbersSet };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}