{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { assertUnreachable } from '../index.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { isOperationCancelled } from '../utils/promise-utils.js';\nimport { stream } from '../utils/stream.js';\n/**\n * Create DiagnosticData for a given diagnostic code. The result can be put into the `data` field of a DiagnosticInfo.\n */\nexport function diagnosticData(code) {\n  return {\n    code\n  };\n}\nexport var ValidationCategory;\n(function (ValidationCategory) {\n  ValidationCategory.all = ['fast', 'slow', 'built-in'];\n})(ValidationCategory || (ValidationCategory = {}));\n/**\n * Manages a set of `ValidationCheck`s to be applied when documents are validated.\n */\nexport class ValidationRegistry {\n  constructor(services) {\n    this.entries = new MultiMap();\n    this.entriesBefore = [];\n    this.entriesAfter = [];\n    this.reflection = services.shared.AstReflection;\n  }\n  /**\n   * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\n   * or an array of validation checks.\n   *\n   * @param checksRecord Set of validation checks to register.\n   * @param category Optional category for the validation checks (defaults to `'fast'`).\n   * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n   */\n  register(checksRecord, thisObj = this, category = 'fast') {\n    if (category === 'built-in') {\n      throw new Error(\"The 'built-in' category is reserved for lexer, parser, and linker errors.\");\n    }\n    for (const [type, ch] of Object.entries(checksRecord)) {\n      const callbacks = ch;\n      if (Array.isArray(callbacks)) {\n        for (const check of callbacks) {\n          const entry = {\n            check: this.wrapValidationException(check, thisObj),\n            category\n          };\n          this.addEntry(type, entry);\n        }\n      } else if (typeof callbacks === 'function') {\n        const entry = {\n          check: this.wrapValidationException(callbacks, thisObj),\n          category\n        };\n        this.addEntry(type, entry);\n      } else {\n        assertUnreachable(callbacks);\n      }\n    }\n  }\n  wrapValidationException(check, thisObj) {\n    return async (node, accept, cancelToken) => {\n      await this.handleException(() => check.call(thisObj, node, accept, cancelToken), 'An error occurred during validation', accept, node);\n    };\n  }\n  async handleException(functionality, messageContext, accept, node) {\n    try {\n      await functionality();\n    } catch (err) {\n      if (isOperationCancelled(err)) {\n        throw err;\n      }\n      console.error(`${messageContext}:`, err);\n      if (err instanceof Error && err.stack) {\n        console.error(err.stack);\n      }\n      const messageDetails = err instanceof Error ? err.message : String(err);\n      accept('error', `${messageContext}: ${messageDetails}`, {\n        node\n      });\n    }\n  }\n  addEntry(type, entry) {\n    if (type === 'AstNode') {\n      this.entries.add('AstNode', entry);\n      return;\n    }\n    for (const subtype of this.reflection.getAllSubTypes(type)) {\n      this.entries.add(subtype, entry);\n    }\n  }\n  getChecks(type, categories) {\n    let checks = stream(this.entries.get(type)).concat(this.entries.get('AstNode'));\n    if (categories) {\n      checks = checks.filter(entry => categories.includes(entry.category));\n    }\n    return checks.map(entry => entry.check);\n  }\n  /**\n   * Register logic which will be executed once before validating all the nodes of an AST/Langium document.\n   * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.\n   *\n   * As an example, for validating unique fully-qualified names of nodes in the AST,\n   * here the map for mapping names to nodes could be established.\n   * During the usual checks on the nodes, they are put into this map with their name.\n   *\n   * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n   * Therefore it is recommended to clear stored information\n   * _before_ validating an AST to validate each AST unaffected from other ASTs\n   * AND _after_ validating the AST to free memory by information which are no longer used.\n   *\n   * @param checkBefore a set-up function which will be called once before actually validating an AST\n   * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n   */\n  registerBeforeDocument(checkBefore, thisObj = this) {\n    this.entriesBefore.push(this.wrapPreparationException(checkBefore, 'An error occurred during set-up of the validation', thisObj));\n  }\n  /**\n   * Register logic which will be executed once after validating all the nodes of an AST/Langium document.\n   * This helps to finally evaluate information which are collected during the checks on the AstNodes.\n   *\n   * As an example, for validating unique fully-qualified names of nodes in the AST,\n   * here the map with all the collected nodes and their names is checked\n   * and validation hints are created for all nodes with the same name.\n   *\n   * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n   * Therefore it is recommended to clear stored information\n   * _before_ validating an AST to validate each AST unaffected from other ASTs\n   * AND _after_ validating the AST to free memory by information which are no longer used.\n   *\n   * @param checkBefore a set-up function which will be called once before actually validating an AST\n   * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n   */\n  registerAfterDocument(checkAfter, thisObj = this) {\n    this.entriesAfter.push(this.wrapPreparationException(checkAfter, 'An error occurred during tear-down of the validation', thisObj));\n  }\n  wrapPreparationException(check, messageContext, thisObj) {\n    return async (rootNode, accept, categories, cancelToken) => {\n      await this.handleException(() => check.call(thisObj, rootNode, accept, categories, cancelToken), messageContext, accept, rootNode);\n    };\n  }\n  get checksBefore() {\n    return this.entriesBefore;\n  }\n  get checksAfter() {\n    return this.entriesAfter;\n  }\n}","map":{"version":3,"names":["assertUnreachable","MultiMap","isOperationCancelled","stream","diagnosticData","code","ValidationCategory","all","ValidationRegistry","constructor","services","entries","entriesBefore","entriesAfter","reflection","shared","AstReflection","register","checksRecord","thisObj","category","Error","type","ch","Object","callbacks","Array","isArray","check","entry","wrapValidationException","addEntry","node","accept","cancelToken","handleException","call","functionality","messageContext","err","console","error","stack","messageDetails","message","String","add","subtype","getAllSubTypes","getChecks","categories","checks","get","concat","filter","includes","map","registerBeforeDocument","checkBefore","push","wrapPreparationException","registerAfterDocument","checkAfter","rootNode","checksBefore","checksAfter"],"sources":["../../src/validation/validation-registry.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}