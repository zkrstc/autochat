{"ast":null,"code":"import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\nimport * as util from '../util.js';\nimport { addSubgraphConstraints } from './add-subgraph-constraints.js';\nimport { buildLayerGraph } from './build-layer-graph.js';\nimport { crossCount } from './cross-count.js';\nimport { initOrder } from './init-order.js';\nimport { sortSubgraph } from './sort-subgraph.js';\nexport { order };\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), 'inEdges'),\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), 'outEdges');\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n  var bestCC = Number.POSITIVE_INFINITY,\n    best;\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n  assignOrder(g, best);\n}\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function (rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function (lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function (v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, i) {\n      g.node(v).order = i;\n    });\n  });\n}","map":{"version":3,"names":["_","Graph","util","addSubgraphConstraints","buildLayerGraph","crossCount","initOrder","sortSubgraph","order","g","maxRank","downLayerGraphs","buildLayerGraphs","range","upLayerGraphs","layering","assignOrder","bestCC","Number","POSITIVE_INFINITY","best","i","lastBest","sweepLayerGraphs","buildLayerMatrix","cc","cloneDeep","ranks","relationship","map","rank","layerGraphs","biasRight","cg","forEach","lg","root","graph","sorted","vs","v","node","layer"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/dagre-d3-es/src/dagre/order/index.js"],"sourcesContent":["import * as _ from 'lodash-es';\nimport { Graph } from '../../graphlib/index.js';\nimport * as util from '../util.js';\nimport { addSubgraphConstraints } from './add-subgraph-constraints.js';\nimport { buildLayerGraph } from './build-layer-graph.js';\nimport { crossCount } from './cross-count.js';\nimport { initOrder } from './init-order.js';\nimport { sortSubgraph } from './sort-subgraph.js';\n\nexport { order };\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), 'inEdges'),\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), 'outEdges');\n\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n\n  var bestCC = Number.POSITIVE_INFINITY,\n    best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function (rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function (lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function (v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, i) {\n      g.node(v).order = i;\n    });\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}