{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { getSequenceFromEmojiStringOrKeyword } from '../cleanup.mjs';\nimport { convertEmojiSequenceToUTF32 } from '../convert.mjs';\nimport { getQualifiedEmojiVariations } from '../test/variations.mjs';\nimport { createEmojisTree, parseEmojiTree } from './tree.mjs';\nimport '../data.mjs';\nimport '../format.mjs';\nimport './base.mjs';\nimport './numbers.mjs';\nimport './similar.mjs';\nfunction createOptimisedRegexForEmojiSequences(sequences) {\n  sequences = sequences.map(item => convertEmojiSequenceToUTF32(item));\n  const tree = createEmojisTree(sequences);\n  const regex = parseEmojiTree(tree);\n  return regex.regex;\n}\nfunction createOptimisedRegex(emojis) {\n  let sequences = emojis.map(item => typeof item === \"string\" ? getSequenceFromEmojiStringOrKeyword(item) : item);\n  sequences = getQualifiedEmojiVariations(sequences.map(sequence => {\n    return {\n      sequence\n    };\n  })).map(item => item.sequence);\n  return createOptimisedRegexForEmojiSequences(sequences);\n}\nexport { createOptimisedRegex, createOptimisedRegexForEmojiSequences };","map":{"version":3,"names":["getSequenceFromEmojiStringOrKeyword","convertEmojiSequenceToUTF32","getQualifiedEmojiVariations","createEmojisTree","parseEmojiTree","createOptimisedRegexForEmojiSequences","sequences","map","item","tree","regex","createOptimisedRegex","emojis","sequence"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/@iconify/utils/lib/emoji/regex/create.mjs"],"sourcesContent":["import { getSequenceFromEmojiStringOrKeyword } from '../cleanup.mjs';\nimport { convertEmojiSequenceToUTF32 } from '../convert.mjs';\nimport { getQualifiedEmojiVariations } from '../test/variations.mjs';\nimport { createEmojisTree, parseEmojiTree } from './tree.mjs';\nimport '../data.mjs';\nimport '../format.mjs';\nimport './base.mjs';\nimport './numbers.mjs';\nimport './similar.mjs';\n\nfunction createOptimisedRegexForEmojiSequences(sequences) {\n  sequences = sequences.map((item) => convertEmojiSequenceToUTF32(item));\n  const tree = createEmojisTree(sequences);\n  const regex = parseEmojiTree(tree);\n  return regex.regex;\n}\nfunction createOptimisedRegex(emojis) {\n  let sequences = emojis.map(\n    (item) => typeof item === \"string\" ? getSequenceFromEmojiStringOrKeyword(item) : item\n  );\n  sequences = getQualifiedEmojiVariations(\n    sequences.map((sequence) => {\n      return {\n        sequence\n      };\n    })\n  ).map((item) => item.sequence);\n  return createOptimisedRegexForEmojiSequences(sequences);\n}\n\nexport { createOptimisedRegex, createOptimisedRegexForEmojiSequences };\n"],"mappings":";;AAAA,SAASA,mCAAmC,QAAQ,gBAAgB;AACpE,SAASC,2BAA2B,QAAQ,gBAAgB;AAC5D,SAASC,2BAA2B,QAAQ,wBAAwB;AACpE,SAASC,gBAAgB,EAAEC,cAAc,QAAQ,YAAY;AAC7D,OAAO,aAAa;AACpB,OAAO,eAAe;AACtB,OAAO,YAAY;AACnB,OAAO,eAAe;AACtB,OAAO,eAAe;AAEtB,SAASC,qCAAqCA,CAACC,SAAS,EAAE;EACxDA,SAAS,GAAGA,SAAS,CAACC,GAAG,CAAEC,IAAI,IAAKP,2BAA2B,CAACO,IAAI,CAAC,CAAC;EACtE,MAAMC,IAAI,GAAGN,gBAAgB,CAACG,SAAS,CAAC;EACxC,MAAMI,KAAK,GAAGN,cAAc,CAACK,IAAI,CAAC;EAClC,OAAOC,KAAK,CAACA,KAAK;AACpB;AACA,SAASC,oBAAoBA,CAACC,MAAM,EAAE;EACpC,IAAIN,SAAS,GAAGM,MAAM,CAACL,GAAG,CACvBC,IAAI,IAAK,OAAOA,IAAI,KAAK,QAAQ,GAAGR,mCAAmC,CAACQ,IAAI,CAAC,GAAGA,IACnF,CAAC;EACDF,SAAS,GAAGJ,2BAA2B,CACrCI,SAAS,CAACC,GAAG,CAAEM,QAAQ,IAAK;IAC1B,OAAO;MACLA;IACF,CAAC;EACH,CAAC,CACH,CAAC,CAACN,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACK,QAAQ,CAAC;EAC9B,OAAOR,qCAAqC,CAACC,SAAS,CAAC;AACzD;AAEA,SAASK,oBAAoB,EAAEN,qCAAqC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}