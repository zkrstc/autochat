{"ast":null,"code":"import { defineComponent, inject, toRefs, ref, getCurrentInstance, computed, watch, nextTick, reactive, onMounted, onUnmounted, openBlock, createElementBlock, Fragment, createElementVNode, mergeProps, unref, renderSlot, createBlock, withCtx, createCommentVNode } from 'vue';\nimport { isCollapsible, getCollapsible } from './hooks/usePanel.mjs';\nimport SplitBar from './split-bar.mjs';\nimport { splitterPanelProps } from './split-panel2.mjs';\nimport { splitterRootContextKey } from './type.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { isPct, getPct, isPx, getPx } from './hooks/useSize.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nconst COMPONENT_NAME = \"ElSplitterPanel\";\nconst __default__ = defineComponent({\n  name: COMPONENT_NAME\n});\nconst _sfc_main = /* @__PURE__ */defineComponent({\n  ...__default__,\n  props: splitterPanelProps,\n  emits: [\"update:size\"],\n  setup(__props, {\n    emit: emits\n  }) {\n    const props = __props;\n    const ns = useNamespace(\"splitter-panel\");\n    const splitterContext = inject(splitterRootContextKey);\n    if (!splitterContext) throwError(COMPONENT_NAME, \"usage: <el-splitter><el-splitter-panel /></el-splitter/>\");\n    const {\n      panels,\n      layout,\n      containerSize,\n      pxSizes\n    } = toRefs(splitterContext);\n    const {\n      registerPanel,\n      sortPanel,\n      unregisterPanel,\n      onCollapse,\n      onMoveEnd,\n      onMoveStart,\n      onMoving\n    } = splitterContext;\n    const panelEl = ref();\n    const uid = getCurrentInstance().uid;\n    const index = ref(0);\n    const panel = computed(() => panels.value[index.value]);\n    const setIndex = val => {\n      index.value = val;\n    };\n    const panelSize = computed(() => {\n      var _a;\n      if (!panel.value) return 0;\n      return (_a = pxSizes.value[index.value]) != null ? _a : 0;\n    });\n    const nextSize = computed(() => {\n      var _a;\n      if (!panel.value) return 0;\n      return (_a = pxSizes.value[index.value + 1]) != null ? _a : 0;\n    });\n    const nextPanel = computed(() => {\n      if (panel.value) {\n        return panels.value[index.value + 1];\n      }\n      return null;\n    });\n    const isResizable = computed(() => {\n      var _a;\n      if (!nextPanel.value) return false;\n      return props.resizable && ((_a = nextPanel.value) == null ? void 0 : _a.resizable) && (panelSize.value !== 0 || !props.min) && (nextSize.value !== 0 || !nextPanel.value.min);\n    });\n    const isShowBar = computed(() => {\n      if (!panel.value) return false;\n      return index.value !== panels.value.length - 1;\n    });\n    const startCollapsible = computed(() => isCollapsible(panel.value, panelSize.value, nextPanel.value, nextSize.value));\n    const endCollapsible = computed(() => isCollapsible(nextPanel.value, nextSize.value, panel.value, panelSize.value));\n    function sizeToPx(str) {\n      if (isPct(str)) {\n        return getPct(str) * containerSize.value || 0;\n      } else if (isPx(str)) {\n        return getPx(str);\n      }\n      return str != null ? str : 0;\n    }\n    let isSizeUpdating = false;\n    watch(() => props.size, () => {\n      if (panel.value) {\n        const size = sizeToPx(props.size);\n        const maxSize = sizeToPx(props.max);\n        const minSize = sizeToPx(props.min);\n        const finalSize = Math.min(Math.max(size, minSize || 0), maxSize || size);\n        if (finalSize !== size) {\n          isSizeUpdating = true;\n          emits(\"update:size\", finalSize);\n        }\n        panel.value.size = finalSize;\n        nextTick(() => isSizeUpdating = false);\n      }\n    });\n    watch(() => {\n      var _a;\n      return (_a = panel.value) == null ? void 0 : _a.size;\n    }, val => {\n      if (!isSizeUpdating && val !== props.size) {\n        emits(\"update:size\", val);\n      }\n    });\n    watch(() => props.resizable, val => {\n      if (panel.value) {\n        panel.value.resizable = val;\n      }\n    });\n    const _panel = reactive({\n      el: panelEl.value,\n      uid,\n      setIndex,\n      ...props,\n      collapsible: getCollapsible(props.collapsible)\n    });\n    registerPanel(_panel);\n    onMounted(() => {\n      sortPanel(_panel);\n    });\n    onUnmounted(() => unregisterPanel == null ? void 0 : unregisterPanel(uid));\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(Fragment, null, [createElementVNode(\"div\", mergeProps({\n        ref_key: \"panelEl\",\n        ref: panelEl,\n        class: [unref(ns).b()],\n        style: {\n          flexBasis: `${unref(panelSize)}px`\n        }\n      }, _ctx.$attrs), [renderSlot(_ctx.$slots, \"default\")], 16), unref(isShowBar) ? (openBlock(), createBlock(SplitBar, {\n        key: 0,\n        index: index.value,\n        layout: unref(layout),\n        resizable: unref(isResizable),\n        \"start-collapsible\": unref(startCollapsible),\n        \"end-collapsible\": unref(endCollapsible),\n        onMoveStart: unref(onMoveStart),\n        onMoving: unref(onMoving),\n        onMoveEnd: unref(onMoveEnd),\n        onCollapse: unref(onCollapse)\n      }, {\n        \"start-collapsible\": withCtx(() => [renderSlot(_ctx.$slots, \"start-collapsible\")]),\n        \"end-collapsible\": withCtx(() => [renderSlot(_ctx.$slots, \"end-collapsible\")]),\n        _: 3\n      }, 8, [\"index\", \"layout\", \"resizable\", \"start-collapsible\", \"end-collapsible\", \"onMoveStart\", \"onMoving\", \"onMoveEnd\", \"onCollapse\"])) : createCommentVNode(\"v-if\", true)], 64);\n    };\n  }\n});\nvar SplitPanel = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"split-panel.vue\"]]);\nexport { SplitPanel as default };","map":{"version":3,"names":["name","COMPONENT_NAME","ns","useNamespace","splitterContext","inject","splitterRootContextKey","throwError","panels","layout","containerSize","pxSizes","toRefs","registerPanel","sortPanel","unregisterPanel","onCollapse","onMoveEnd","onMoveStart","onMoving","panelEl","ref","uid","getCurrentInstance","index","panel","computed","value","setIndex","val","panelSize","_a","nextSize","nextPanel","isResizable","props","resizable","min","isShowBar","length","startCollapsible","isCollapsible","endCollapsible","sizeToPx","str","isPct","getPct","isPx","getPx","isSizeUpdating","watch","size","maxSize","max","minSize","finalSize","Math","emits","nextTick","_panel","reactive","el","collapsible","getCollapsible","onMounted","onUnmounted","_ctx","_cache","openBlock","createElementBlock","Fragment","createElementVNode","mergeProps","ref_key","class","unref","b","style","flexBasis"],"sources":["../../../../../../packages/components/splitter/src/split-panel.vue"],"sourcesContent":["<script setup lang=\"ts\">\nimport {\n  computed,\n  getCurrentInstance,\n  inject,\n  nextTick,\n  onMounted,\n  onUnmounted,\n  reactive,\n  ref,\n  toRefs,\n  watch,\n} from 'vue'\nimport { useNamespace } from '@element-plus/hooks'\nimport { throwError } from '@element-plus/utils'\nimport { getCollapsible, isCollapsible } from './hooks/usePanel'\nimport SplitBar from './split-bar.vue'\nimport { splitterPanelProps } from './split-panel'\nimport { getPct, getPx, isPct, isPx } from './hooks'\nimport { splitterRootContextKey } from './type'\n\nconst ns = useNamespace('splitter-panel')\n\nconst COMPONENT_NAME = 'ElSplitterPanel'\ndefineOptions({\n  name: COMPONENT_NAME,\n})\n\nconst props = defineProps(splitterPanelProps)\n\nconst emits = defineEmits<{\n  (e: 'update:size', value: number): void\n}>()\nconst splitterContext = inject(splitterRootContextKey)\nif (!splitterContext)\n  throwError(\n    COMPONENT_NAME,\n    'usage: <el-splitter><el-splitter-panel /></el-splitter/>'\n  )\n\nconst { panels, layout, containerSize, pxSizes } = toRefs(splitterContext)\n\nconst {\n  registerPanel,\n  sortPanel,\n  unregisterPanel,\n  onCollapse,\n  onMoveEnd,\n  onMoveStart,\n  onMoving,\n} = splitterContext\n\nconst panelEl = ref<HTMLDivElement>()\nconst uid = getCurrentInstance()!.uid\n\nconst index = ref(0)\nconst panel = computed(() => panels.value[index.value])\n\nconst setIndex = (val: number) => {\n  index.value = val\n}\n\nconst panelSize = computed(() => {\n  if (!panel.value) return 0\n  return pxSizes.value[index.value] ?? 0\n})\n\nconst nextSize = computed(() => {\n  if (!panel.value) return 0\n  return pxSizes.value[index.value + 1] ?? 0\n})\n\nconst nextPanel = computed(() => {\n  if (panel.value) {\n    return panels.value[index.value + 1]\n  }\n  return null\n})\n\nconst isResizable = computed(() => {\n  if (!nextPanel.value) return false\n  return (\n    props.resizable &&\n    nextPanel.value?.resizable &&\n    // If it is 0, it means it is collapsed => check if the minimum value is set\n    (panelSize.value !== 0 || !props.min) &&\n    (nextSize.value !== 0 || !nextPanel.value.min)\n  )\n})\n\n// The last panel doesn't need a drag bar\nconst isShowBar = computed(() => {\n  if (!panel.value) return false\n  return index.value !== panels.value.length - 1\n})\n\nconst startCollapsible = computed(() =>\n  isCollapsible(panel.value, panelSize.value, nextPanel.value, nextSize.value)\n)\n\nconst endCollapsible = computed(() =>\n  isCollapsible(nextPanel.value, nextSize.value, panel.value, panelSize.value)\n)\n\nfunction sizeToPx(str: string | number | undefined) {\n  if (isPct(str)) {\n    return getPct(str) * containerSize.value || 0\n  } else if (isPx(str)) {\n    return getPx(str)\n  }\n  return str ?? 0\n}\n\n// Two-way binding for size\nlet isSizeUpdating = false\nwatch(\n  () => props.size,\n  () => {\n    if (panel.value) {\n      const size = sizeToPx(props.size)\n      const maxSize = sizeToPx(props.max)\n      const minSize = sizeToPx(props.min)\n\n      // Ensure it is within the maximum and minimum value range\n      const finalSize = Math.min(Math.max(size, minSize || 0), maxSize || size)\n\n      if (finalSize !== size) {\n        isSizeUpdating = true\n        emits('update:size', finalSize)\n      }\n\n      panel.value.size = finalSize\n      nextTick(() => (isSizeUpdating = false))\n    }\n  }\n)\n\nwatch(\n  () => panel.value?.size,\n  (val) => {\n    if (!isSizeUpdating && val !== props.size) {\n      emits('update:size', val as number)\n    }\n  }\n)\n\nwatch(\n  () => props.resizable,\n  (val) => {\n    if (panel.value) {\n      panel.value.resizable = val\n    }\n  }\n)\n\nconst _panel = reactive({\n  el: panelEl.value!,\n  uid,\n  setIndex,\n  ...props,\n  collapsible: getCollapsible(props.collapsible),\n})\n\nregisterPanel(_panel)\nonMounted(() => {\n  sortPanel(_panel)\n})\n\nonUnmounted(() => unregisterPanel?.(uid))\n</script>\n\n<template>\n  <div\n    ref=\"panelEl\"\n    :class=\"[ns.b()]\"\n    :style=\"{ flexBasis: `${panelSize}px` }\"\n    v-bind=\"$attrs\"\n  >\n    <slot />\n  </div>\n  <SplitBar\n    v-if=\"isShowBar\"\n    :index=\"index\"\n    :layout=\"layout\"\n    :resizable=\"isResizable\"\n    :start-collapsible=\"startCollapsible\"\n    :end-collapsible=\"endCollapsible\"\n    @move-start=\"onMoveStart\"\n    @moving=\"onMoving\"\n    @move-end=\"onMoveEnd\"\n    @collapse=\"onCollapse\"\n  >\n    <template #start-collapsible>\n      <slot name=\"start-collapsible\" />\n    </template>\n    <template #end-collapsible>\n      <slot name=\"end-collapsible\" />\n    </template>\n  </SplitBar>\n</template>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}