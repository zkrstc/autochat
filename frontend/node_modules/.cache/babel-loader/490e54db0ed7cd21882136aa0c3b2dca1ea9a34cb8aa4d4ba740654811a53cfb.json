{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { EMPTY_ALT, EOF } from 'chevrotain';\nimport { isAction, isAlternatives, isEndOfFile, isAssignment, isConjunction, isCrossReference, isDisjunction, isGroup, isKeyword, isNegation, isParameterReference, isParserRule, isRuleCall, isTerminalRule, isUnorderedGroup, isBooleanLiteral } from '../languages/generated/ast.js';\nimport { assertUnreachable, ErrorWithLocation } from '../utils/errors.js';\nimport { stream } from '../utils/stream.js';\nimport { findNameAssignment, getAllReachableRules, getTypeName } from '../utils/grammar-utils.js';\nexport function createParser(grammar, parser, tokens) {\n  const parserContext = {\n    parser,\n    tokens,\n    ruleNames: new Map()\n  };\n  buildRules(parserContext, grammar);\n  return parser;\n}\nfunction buildRules(parserContext, grammar) {\n  const reachable = getAllReachableRules(grammar, false);\n  const parserRules = stream(grammar.rules).filter(isParserRule).filter(rule => reachable.has(rule));\n  for (const rule of parserRules) {\n    const ctx = Object.assign(Object.assign({}, parserContext), {\n      consume: 1,\n      optional: 1,\n      subrule: 1,\n      many: 1,\n      or: 1\n    });\n    parserContext.parser.rule(rule, buildElement(ctx, rule.definition));\n  }\n}\nfunction buildElement(ctx, element, ignoreGuard = false) {\n  let method;\n  if (isKeyword(element)) {\n    method = buildKeyword(ctx, element);\n  } else if (isAction(element)) {\n    method = buildAction(ctx, element);\n  } else if (isAssignment(element)) {\n    method = buildElement(ctx, element.terminal);\n  } else if (isCrossReference(element)) {\n    method = buildCrossReference(ctx, element);\n  } else if (isRuleCall(element)) {\n    method = buildRuleCall(ctx, element);\n  } else if (isAlternatives(element)) {\n    method = buildAlternatives(ctx, element);\n  } else if (isUnorderedGroup(element)) {\n    method = buildUnorderedGroup(ctx, element);\n  } else if (isGroup(element)) {\n    method = buildGroup(ctx, element);\n  } else if (isEndOfFile(element)) {\n    const idx = ctx.consume++;\n    method = () => ctx.parser.consume(idx, EOF, element);\n  } else {\n    throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\n  }\n  return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);\n}\nfunction buildAction(ctx, action) {\n  const actionType = getTypeName(action);\n  return () => ctx.parser.action(actionType, action);\n}\nfunction buildRuleCall(ctx, ruleCall) {\n  const rule = ruleCall.rule.ref;\n  if (isParserRule(rule)) {\n    const idx = ctx.subrule++;\n    const fragment = rule.fragment;\n    const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\n    return args => ctx.parser.subrule(idx, getRule(ctx, rule), fragment, ruleCall, predicate(args));\n  } else if (isTerminalRule(rule)) {\n    const idx = ctx.consume++;\n    const method = getToken(ctx, rule.name);\n    return () => ctx.parser.consume(idx, method, ruleCall);\n  } else if (!rule) {\n    throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule: ${ruleCall.rule.$refText}`);\n  } else {\n    assertUnreachable(rule);\n  }\n}\nfunction buildRuleCallPredicate(rule, namedArgs) {\n  const predicates = namedArgs.map(e => buildPredicate(e.value));\n  return args => {\n    const ruleArgs = {};\n    for (let i = 0; i < predicates.length; i++) {\n      const ruleTarget = rule.parameters[i];\n      const predicate = predicates[i];\n      ruleArgs[ruleTarget.name] = predicate(args);\n    }\n    return ruleArgs;\n  };\n}\nfunction buildPredicate(condition) {\n  if (isDisjunction(condition)) {\n    const left = buildPredicate(condition.left);\n    const right = buildPredicate(condition.right);\n    return args => left(args) || right(args);\n  } else if (isConjunction(condition)) {\n    const left = buildPredicate(condition.left);\n    const right = buildPredicate(condition.right);\n    return args => left(args) && right(args);\n  } else if (isNegation(condition)) {\n    const value = buildPredicate(condition.value);\n    return args => !value(args);\n  } else if (isParameterReference(condition)) {\n    const name = condition.parameter.ref.name;\n    return args => args !== undefined && args[name] === true;\n  } else if (isBooleanLiteral(condition)) {\n    const value = Boolean(condition.true);\n    return () => value;\n  }\n  assertUnreachable(condition);\n}\nfunction buildAlternatives(ctx, alternatives) {\n  if (alternatives.elements.length === 1) {\n    return buildElement(ctx, alternatives.elements[0]);\n  } else {\n    const methods = [];\n    for (const element of alternatives.elements) {\n      const predicatedMethod = {\n        // Since we handle the guard condition in the alternative already\n        // We can ignore the group guard condition inside\n        ALT: buildElement(ctx, element, true)\n      };\n      const guard = getGuardCondition(element);\n      if (guard) {\n        predicatedMethod.GATE = buildPredicate(guard);\n      }\n      methods.push(predicatedMethod);\n    }\n    const idx = ctx.or++;\n    return args => ctx.parser.alternatives(idx, methods.map(method => {\n      const alt = {\n        ALT: () => method.ALT(args)\n      };\n      const gate = method.GATE;\n      if (gate) {\n        alt.GATE = () => gate(args);\n      }\n      return alt;\n    }));\n  }\n}\nfunction buildUnorderedGroup(ctx, group) {\n  if (group.elements.length === 1) {\n    return buildElement(ctx, group.elements[0]);\n  }\n  const methods = [];\n  for (const element of group.elements) {\n    const predicatedMethod = {\n      // Since we handle the guard condition in the alternative already\n      // We can ignore the group guard condition inside\n      ALT: buildElement(ctx, element, true)\n    };\n    const guard = getGuardCondition(element);\n    if (guard) {\n      predicatedMethod.GATE = buildPredicate(guard);\n    }\n    methods.push(predicatedMethod);\n  }\n  const orIdx = ctx.or++;\n  const idFunc = (groupIdx, lParser) => {\n    const stackId = lParser.getRuleStack().join('-');\n    return `uGroup_${groupIdx}_${stackId}`;\n  };\n  const alternatives = args => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\n    const alt = {\n      ALT: () => true\n    };\n    const parser = ctx.parser;\n    alt.ALT = () => {\n      method.ALT(args);\n      if (!parser.isRecording()) {\n        const key = idFunc(orIdx, parser);\n        if (!parser.unorderedGroups.get(key)) {\n          // init after clear state\n          parser.unorderedGroups.set(key, []);\n        }\n        const groupState = parser.unorderedGroups.get(key);\n        if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === 'undefined') {\n          // Not accessed yet\n          groupState[idx] = true;\n        }\n      }\n    };\n    const gate = method.GATE;\n    if (gate) {\n      alt.GATE = () => gate(args);\n    } else {\n      alt.GATE = () => {\n        const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\n        const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);\n        return allow;\n      };\n    }\n    return alt;\n  }));\n  const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');\n  return args => {\n    wrapped(args);\n    if (!ctx.parser.isRecording()) {\n      ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\n    }\n  };\n}\nfunction buildGroup(ctx, group) {\n  const methods = group.elements.map(e => buildElement(ctx, e));\n  return args => methods.forEach(method => method(args));\n}\nfunction getGuardCondition(element) {\n  if (isGroup(element)) {\n    return element.guardCondition;\n  }\n  return undefined;\n}\nfunction buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {\n  if (!terminal) {\n    if (!crossRef.type.ref) {\n      throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);\n    }\n    const assignment = findNameAssignment(crossRef.type.ref);\n    const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;\n    if (!assignTerminal) {\n      throw new Error('Could not find name assignment for type: ' + getTypeName(crossRef.type.ref));\n    }\n    return buildCrossReference(ctx, crossRef, assignTerminal);\n  } else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\n    // The terminal is a data type rule here. Everything else will result in a validation error.\n    const rule = terminal.rule.ref;\n    const idx = ctx.subrule++;\n    return args => ctx.parser.subrule(idx, getRule(ctx, rule), false, crossRef, args);\n  } else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\n    const idx = ctx.consume++;\n    const terminalRule = getToken(ctx, terminal.rule.ref.name);\n    return () => ctx.parser.consume(idx, terminalRule, crossRef);\n  } else if (isKeyword(terminal)) {\n    const idx = ctx.consume++;\n    const keyword = getToken(ctx, terminal.value);\n    return () => ctx.parser.consume(idx, keyword, crossRef);\n  } else {\n    throw new Error('Could not build cross reference parser');\n  }\n}\nfunction buildKeyword(ctx, keyword) {\n  const idx = ctx.consume++;\n  const token = ctx.tokens[keyword.value];\n  if (!token) {\n    throw new Error('Could not find token for keyword: ' + keyword.value);\n  }\n  return () => ctx.parser.consume(idx, token, keyword);\n}\nfunction wrap(ctx, guard, method, cardinality) {\n  const gate = guard && buildPredicate(guard);\n  if (!cardinality) {\n    if (gate) {\n      const idx = ctx.or++;\n      return args => ctx.parser.alternatives(idx, [{\n        ALT: () => method(args),\n        GATE: () => gate(args)\n      }, {\n        ALT: EMPTY_ALT(),\n        GATE: () => !gate(args)\n      }]);\n    } else {\n      return method;\n    }\n  }\n  if (cardinality === '*') {\n    const idx = ctx.many++;\n    return args => ctx.parser.many(idx, {\n      DEF: () => method(args),\n      GATE: gate ? () => gate(args) : undefined\n    });\n  } else if (cardinality === '+') {\n    const idx = ctx.many++;\n    if (gate) {\n      const orIdx = ctx.or++;\n      // In the case of a guard condition for the `+` group\n      // We combine it with an empty alternative\n      // If the condition returns true, it needs to parse at least a single iteration\n      // If its false, it is not allowed to parse anything\n      return args => ctx.parser.alternatives(orIdx, [{\n        ALT: () => ctx.parser.atLeastOne(idx, {\n          DEF: () => method(args)\n        }),\n        GATE: () => gate(args)\n      }, {\n        ALT: EMPTY_ALT(),\n        GATE: () => !gate(args)\n      }]);\n    } else {\n      return args => ctx.parser.atLeastOne(idx, {\n        DEF: () => method(args)\n      });\n    }\n  } else if (cardinality === '?') {\n    const idx = ctx.optional++;\n    return args => ctx.parser.optional(idx, {\n      DEF: () => method(args),\n      GATE: gate ? () => gate(args) : undefined\n    });\n  } else {\n    assertUnreachable(cardinality);\n  }\n}\nfunction getRule(ctx, element) {\n  const name = getRuleName(ctx, element);\n  const rule = ctx.parser.getRule(name);\n  if (!rule) throw new Error(`Rule \"${name}\" not found.\"`);\n  return rule;\n}\nfunction getRuleName(ctx, element) {\n  if (isParserRule(element)) {\n    return element.name;\n  } else if (ctx.ruleNames.has(element)) {\n    return ctx.ruleNames.get(element);\n  } else {\n    let item = element;\n    let parent = item.$container;\n    let ruleName = element.$type;\n    while (!isParserRule(parent)) {\n      if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\n        const index = parent.elements.indexOf(item);\n        ruleName = index.toString() + ':' + ruleName;\n      }\n      item = parent;\n      parent = parent.$container;\n    }\n    const rule = parent;\n    ruleName = rule.name + ':' + ruleName;\n    ctx.ruleNames.set(element, ruleName);\n    return ruleName;\n  }\n}\nfunction getToken(ctx, name) {\n  const token = ctx.tokens[name];\n  if (!token) throw new Error(`Token \"${name}\" not found.\"`);\n  return token;\n}","map":{"version":3,"names":["EMPTY_ALT","EOF","isAction","isAlternatives","isEndOfFile","isAssignment","isConjunction","isCrossReference","isDisjunction","isGroup","isKeyword","isNegation","isParameterReference","isParserRule","isRuleCall","isTerminalRule","isUnorderedGroup","isBooleanLiteral","assertUnreachable","ErrorWithLocation","stream","findNameAssignment","getAllReachableRules","getTypeName","createParser","grammar","parser","tokens","parserContext","ruleNames","Map","buildRules","reachable","parserRules","rules","filter","rule","has","ctx","Object","assign","consume","optional","subrule","many","or","buildElement","definition","element","ignoreGuard","method","buildKeyword","buildAction","terminal","buildCrossReference","buildRuleCall","buildAlternatives","buildUnorderedGroup","buildGroup","idx","$cstNode","$type","wrap","undefined","getGuardCondition","cardinality","action","actionType","ruleCall","ref","fragment","predicate","arguments","length","buildRuleCallPredicate","args","getRule","getToken","name","$refText","namedArgs","predicates","map","e","buildPredicate","value","ruleArgs","i","ruleTarget","parameters","condition","left","right","parameter","Boolean","true","alternatives","elements","methods","predicatedMethod","ALT","guard","GATE","push","alt","gate","group","orIdx","idFunc","groupIdx","lParser","stackId","getRuleStack","join","isRecording","key","unorderedGroups","get","set","groupState","trackedAlternatives","allow","wrapped","delete","forEach","guardCondition","crossRef","type","Error","assignment","assignTerminal","terminalRule","keyword","token","DEF","atLeastOne","getRuleName","item","parent","$container","ruleName","index","indexOf","toString"],"sources":["../../src/parser/parser-builder-base.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}