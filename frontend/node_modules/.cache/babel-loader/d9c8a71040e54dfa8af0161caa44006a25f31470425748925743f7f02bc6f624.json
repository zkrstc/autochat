{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { MapScope, StreamScope } from './scope.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { WorkspaceCache } from '../utils/caching.js';\nexport class DefaultScopeProvider {\n  constructor(services) {\n    this.reflection = services.shared.AstReflection;\n    this.nameProvider = services.references.NameProvider;\n    this.descriptions = services.workspace.AstNodeDescriptionProvider;\n    this.indexManager = services.shared.workspace.IndexManager;\n    this.globalScopeCache = new WorkspaceCache(services.shared);\n  }\n  getScope(context) {\n    const scopes = [];\n    const referenceType = this.reflection.getReferenceType(context);\n    const precomputed = getDocument(context.container).precomputedScopes;\n    if (precomputed) {\n      let currentNode = context.container;\n      do {\n        const allDescriptions = precomputed.get(currentNode);\n        if (allDescriptions.length > 0) {\n          scopes.push(stream(allDescriptions).filter(desc => this.reflection.isSubtype(desc.type, referenceType)));\n        }\n        currentNode = currentNode.$container;\n      } while (currentNode);\n    }\n    let result = this.getGlobalScope(referenceType, context);\n    for (let i = scopes.length - 1; i >= 0; i--) {\n      result = this.createScope(scopes[i], result);\n    }\n    return result;\n  }\n  /**\n   * Create a scope for the given collection of AST node descriptions.\n   */\n  createScope(elements, outerScope, options) {\n    return new StreamScope(stream(elements), outerScope, options);\n  }\n  /**\n   * Create a scope for the given collection of AST nodes, which need to be transformed into respective\n   * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\n   */\n  createScopeForNodes(elements, outerScope, options) {\n    const s = stream(elements).map(e => {\n      const name = this.nameProvider.getName(e);\n      if (name) {\n        return this.descriptions.createDescription(e, name);\n      }\n      return undefined;\n    }).nonNullable();\n    return new StreamScope(s, outerScope, options);\n  }\n  /**\n   * Create a global scope filtered for the given reference type.\n   */\n  getGlobalScope(referenceType, _context) {\n    return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\n  }\n}","map":{"version":3,"names":["MapScope","StreamScope","getDocument","stream","WorkspaceCache","DefaultScopeProvider","constructor","services","reflection","shared","AstReflection","nameProvider","references","NameProvider","descriptions","workspace","AstNodeDescriptionProvider","indexManager","IndexManager","globalScopeCache","getScope","context","scopes","referenceType","getReferenceType","precomputed","container","precomputedScopes","currentNode","allDescriptions","get","length","push","filter","desc","isSubtype","type","$container","result","getGlobalScope","i","createScope","elements","outerScope","options","createScopeForNodes","s","map","e","name","getName","createDescription","undefined","nonNullable","_context","allElements"],"sources":["../../src/references/scope-provider.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}