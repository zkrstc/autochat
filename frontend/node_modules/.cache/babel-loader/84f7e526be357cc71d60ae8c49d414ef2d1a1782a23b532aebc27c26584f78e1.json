{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nexport function isAstNode(obj) {\n  return typeof obj === 'object' && obj !== null && typeof obj.$type === 'string';\n}\nexport function isReference(obj) {\n  return typeof obj === 'object' && obj !== null && typeof obj.$refText === 'string';\n}\nexport function isAstNodeDescription(obj) {\n  return typeof obj === 'object' && obj !== null && typeof obj.name === 'string' && typeof obj.type === 'string' && typeof obj.path === 'string';\n}\nexport function isLinkingError(obj) {\n  return typeof obj === 'object' && obj !== null && isAstNode(obj.container) && isReference(obj.reference) && typeof obj.message === 'string';\n}\n/**\n * An abstract implementation of the {@link AstReflection} interface.\n * Serves to cache subtype computation results to improve performance throughout different parts of Langium.\n */\nexport class AbstractAstReflection {\n  constructor() {\n    this.subtypes = {};\n    this.allSubtypes = {};\n  }\n  isInstance(node, type) {\n    return isAstNode(node) && this.isSubtype(node.$type, type);\n  }\n  isSubtype(subtype, supertype) {\n    if (subtype === supertype) {\n      return true;\n    }\n    let nested = this.subtypes[subtype];\n    if (!nested) {\n      nested = this.subtypes[subtype] = {};\n    }\n    const existing = nested[supertype];\n    if (existing !== undefined) {\n      return existing;\n    } else {\n      const result = this.computeIsSubtype(subtype, supertype);\n      nested[supertype] = result;\n      return result;\n    }\n  }\n  getAllSubTypes(type) {\n    const existing = this.allSubtypes[type];\n    if (existing) {\n      return existing;\n    } else {\n      const allTypes = this.getAllTypes();\n      const types = [];\n      for (const possibleSubType of allTypes) {\n        if (this.isSubtype(possibleSubType, type)) {\n          types.push(possibleSubType);\n        }\n      }\n      this.allSubtypes[type] = types;\n      return types;\n    }\n  }\n}\nexport function isCompositeCstNode(node) {\n  return typeof node === 'object' && node !== null && Array.isArray(node.content);\n}\nexport function isLeafCstNode(node) {\n  return typeof node === 'object' && node !== null && typeof node.tokenType === 'object';\n}\nexport function isRootCstNode(node) {\n  return isCompositeCstNode(node) && typeof node.fullText === 'string';\n}","map":{"version":3,"names":["isAstNode","obj","$type","isReference","$refText","isAstNodeDescription","name","type","path","isLinkingError","container","reference","message","AbstractAstReflection","constructor","subtypes","allSubtypes","isInstance","node","isSubtype","subtype","supertype","nested","existing","undefined","result","computeIsSubtype","getAllSubTypes","allTypes","getAllTypes","types","possibleSubType","push","isCompositeCstNode","Array","isArray","content","isLeafCstNode","tokenType","isRootCstNode","fullText"],"sources":["../src/syntax-tree.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}