{"ast":null,"code":"import _defineProperty from \"C:/Users/ASUS/Desktop/autochat/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar LIB;\n(() => {\n  \"use strict\";\n\n  var t = {\n      470: t => {\n        function e(t) {\n          if (\"string\" != typeof t) throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(t));\n        }\n        function r(t, e) {\n          for (var r, n = \"\", i = 0, o = -1, s = 0, h = 0; h <= t.length; ++h) {\n            if (h < t.length) r = t.charCodeAt(h);else {\n              if (47 === r) break;\n              r = 47;\n            }\n            if (47 === r) {\n              if (o === h - 1 || 1 === s) ;else if (o !== h - 1 && 2 === s) {\n                if (n.length < 2 || 2 !== i || 46 !== n.charCodeAt(n.length - 1) || 46 !== n.charCodeAt(n.length - 2)) if (n.length > 2) {\n                  var a = n.lastIndexOf(\"/\");\n                  if (a !== n.length - 1) {\n                    -1 === a ? (n = \"\", i = 0) : i = (n = n.slice(0, a)).length - 1 - n.lastIndexOf(\"/\"), o = h, s = 0;\n                    continue;\n                  }\n                } else if (2 === n.length || 1 === n.length) {\n                  n = \"\", i = 0, o = h, s = 0;\n                  continue;\n                }\n                e && (n.length > 0 ? n += \"/..\" : n = \"..\", i = 2);\n              } else n.length > 0 ? n += \"/\" + t.slice(o + 1, h) : n = t.slice(o + 1, h), i = h - o - 1;\n              o = h, s = 0;\n            } else 46 === r && -1 !== s ? ++s : s = -1;\n          }\n          return n;\n        }\n        var n = {\n          resolve: function () {\n            for (var t, n = \"\", i = !1, o = arguments.length - 1; o >= -1 && !i; o--) {\n              var s;\n              o >= 0 ? s = arguments[o] : (void 0 === t && (t = process.cwd()), s = t), e(s), 0 !== s.length && (n = s + \"/\" + n, i = 47 === s.charCodeAt(0));\n            }\n            return n = r(n, !i), i ? n.length > 0 ? \"/\" + n : \"/\" : n.length > 0 ? n : \".\";\n          },\n          normalize: function (t) {\n            if (e(t), 0 === t.length) return \".\";\n            var n = 47 === t.charCodeAt(0),\n              i = 47 === t.charCodeAt(t.length - 1);\n            return 0 !== (t = r(t, !n)).length || n || (t = \".\"), t.length > 0 && i && (t += \"/\"), n ? \"/\" + t : t;\n          },\n          isAbsolute: function (t) {\n            return e(t), t.length > 0 && 47 === t.charCodeAt(0);\n          },\n          join: function () {\n            if (0 === arguments.length) return \".\";\n            for (var t, r = 0; r < arguments.length; ++r) {\n              var i = arguments[r];\n              e(i), i.length > 0 && (void 0 === t ? t = i : t += \"/\" + i);\n            }\n            return void 0 === t ? \".\" : n.normalize(t);\n          },\n          relative: function (t, r) {\n            if (e(t), e(r), t === r) return \"\";\n            if ((t = n.resolve(t)) === (r = n.resolve(r))) return \"\";\n            for (var i = 1; i < t.length && 47 === t.charCodeAt(i); ++i);\n            for (var o = t.length, s = o - i, h = 1; h < r.length && 47 === r.charCodeAt(h); ++h);\n            for (var a = r.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u) {\n              if (u === c) {\n                if (a > c) {\n                  if (47 === r.charCodeAt(h + u)) return r.slice(h + u + 1);\n                  if (0 === u) return r.slice(h + u);\n                } else s > c && (47 === t.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));\n                break;\n              }\n              var l = t.charCodeAt(i + u);\n              if (l !== r.charCodeAt(h + u)) break;\n              47 === l && (f = u);\n            }\n            var g = \"\";\n            for (u = i + f + 1; u <= o; ++u) u !== o && 47 !== t.charCodeAt(u) || (0 === g.length ? g += \"..\" : g += \"/..\");\n            return g.length > 0 ? g + r.slice(h + f) : (h += f, 47 === r.charCodeAt(h) && ++h, r.slice(h));\n          },\n          _makeLong: function (t) {\n            return t;\n          },\n          dirname: function (t) {\n            if (e(t), 0 === t.length) return \".\";\n            for (var r = t.charCodeAt(0), n = 47 === r, i = -1, o = !0, s = t.length - 1; s >= 1; --s) if (47 === (r = t.charCodeAt(s))) {\n              if (!o) {\n                i = s;\n                break;\n              }\n            } else o = !1;\n            return -1 === i ? n ? \"/\" : \".\" : n && 1 === i ? \"//\" : t.slice(0, i);\n          },\n          basename: function (t, r) {\n            if (void 0 !== r && \"string\" != typeof r) throw new TypeError('\"ext\" argument must be a string');\n            e(t);\n            var n,\n              i = 0,\n              o = -1,\n              s = !0;\n            if (void 0 !== r && r.length > 0 && r.length <= t.length) {\n              if (r.length === t.length && r === t) return \"\";\n              var h = r.length - 1,\n                a = -1;\n              for (n = t.length - 1; n >= 0; --n) {\n                var c = t.charCodeAt(n);\n                if (47 === c) {\n                  if (!s) {\n                    i = n + 1;\n                    break;\n                  }\n                } else -1 === a && (s = !1, a = n + 1), h >= 0 && (c === r.charCodeAt(h) ? -1 == --h && (o = n) : (h = -1, o = a));\n              }\n              return i === o ? o = a : -1 === o && (o = t.length), t.slice(i, o);\n            }\n            for (n = t.length - 1; n >= 0; --n) if (47 === t.charCodeAt(n)) {\n              if (!s) {\n                i = n + 1;\n                break;\n              }\n            } else -1 === o && (s = !1, o = n + 1);\n            return -1 === o ? \"\" : t.slice(i, o);\n          },\n          extname: function (t) {\n            e(t);\n            for (var r = -1, n = 0, i = -1, o = !0, s = 0, h = t.length - 1; h >= 0; --h) {\n              var a = t.charCodeAt(h);\n              if (47 !== a) -1 === i && (o = !1, i = h + 1), 46 === a ? -1 === r ? r = h : 1 !== s && (s = 1) : -1 !== r && (s = -1);else if (!o) {\n                n = h + 1;\n                break;\n              }\n            }\n            return -1 === r || -1 === i || 0 === s || 1 === s && r === i - 1 && r === n + 1 ? \"\" : t.slice(r, i);\n          },\n          format: function (t) {\n            if (null === t || \"object\" != typeof t) throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof t);\n            return function (t, e) {\n              var r = e.dir || e.root,\n                n = e.base || (e.name || \"\") + (e.ext || \"\");\n              return r ? r === e.root ? r + n : r + \"/\" + n : n;\n            }(0, t);\n          },\n          parse: function (t) {\n            e(t);\n            var r = {\n              root: \"\",\n              dir: \"\",\n              base: \"\",\n              ext: \"\",\n              name: \"\"\n            };\n            if (0 === t.length) return r;\n            var n,\n              i = t.charCodeAt(0),\n              o = 47 === i;\n            o ? (r.root = \"/\", n = 1) : n = 0;\n            for (var s = -1, h = 0, a = -1, c = !0, f = t.length - 1, u = 0; f >= n; --f) if (47 !== (i = t.charCodeAt(f))) -1 === a && (c = !1, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);else if (!c) {\n              h = f + 1;\n              break;\n            }\n            return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r.base = r.name = 0 === h && o ? t.slice(1, a) : t.slice(h, a)) : (0 === h && o ? (r.name = t.slice(1, s), r.base = t.slice(1, a)) : (r.name = t.slice(h, s), r.base = t.slice(h, a)), r.ext = t.slice(s, a)), h > 0 ? r.dir = t.slice(0, h - 1) : o && (r.dir = \"/\"), r;\n          },\n          sep: \"/\",\n          delimiter: \":\",\n          win32: null,\n          posix: null\n        };\n        n.posix = n, t.exports = n;\n      }\n    },\n    e = {};\n  function r(n) {\n    var i = e[n];\n    if (void 0 !== i) return i.exports;\n    var o = e[n] = {\n      exports: {}\n    };\n    return t[n](o, o.exports, r), o.exports;\n  }\n  r.d = (t, e) => {\n    for (var n in e) r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, {\n      enumerable: !0,\n      get: e[n]\n    });\n  }, r.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), r.r = t => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n  };\n  var n = {};\n  (() => {\n    let t;\n    if (r.r(n), r.d(n, {\n      URI: () => f,\n      Utils: () => P\n    }), \"object\" == typeof process) t = \"win32\" === process.platform;else if (\"object\" == typeof navigator) {\n      let e = navigator.userAgent;\n      t = e.indexOf(\"Windows\") >= 0;\n    }\n    const e = /^\\w[\\w\\d+.-]*$/,\n      i = /^\\//,\n      o = /^\\/\\//;\n    function s(t, r) {\n      if (!t.scheme && r) throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${t.authority}\", path: \"${t.path}\", query: \"${t.query}\", fragment: \"${t.fragment}\"}`);\n      if (t.scheme && !e.test(t.scheme)) throw new Error(\"[UriError]: Scheme contains illegal characters.\");\n      if (t.path) if (t.authority) {\n        if (!i.test(t.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n      } else if (o.test(t.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n    }\n    const h = \"\",\n      a = \"/\",\n      c = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n    class f {\n      static isUri(t) {\n        return t instanceof f || !!t && \"string\" == typeof t.authority && \"string\" == typeof t.fragment && \"string\" == typeof t.path && \"string\" == typeof t.query && \"string\" == typeof t.scheme && \"string\" == typeof t.fsPath && \"function\" == typeof t.with && \"function\" == typeof t.toString;\n      }\n      constructor(t, e, r, n, i, o = !1) {\n        _defineProperty(this, \"scheme\", void 0);\n        _defineProperty(this, \"authority\", void 0);\n        _defineProperty(this, \"path\", void 0);\n        _defineProperty(this, \"query\", void 0);\n        _defineProperty(this, \"fragment\", void 0);\n        \"object\" == typeof t ? (this.scheme = t.scheme || h, this.authority = t.authority || h, this.path = t.path || h, this.query = t.query || h, this.fragment = t.fragment || h) : (this.scheme = function (t, e) {\n          return t || e ? t : \"file\";\n        }(t, o), this.authority = e || h, this.path = function (t, e) {\n          switch (t) {\n            case \"https\":\n            case \"http\":\n            case \"file\":\n              e ? e[0] !== a && (e = a + e) : e = a;\n          }\n          return e;\n        }(this.scheme, r || h), this.query = n || h, this.fragment = i || h, s(this, o));\n      }\n      get fsPath() {\n        return m(this, !1);\n      }\n      with(t) {\n        if (!t) return this;\n        let {\n          scheme: e,\n          authority: r,\n          path: n,\n          query: i,\n          fragment: o\n        } = t;\n        return void 0 === e ? e = this.scheme : null === e && (e = h), void 0 === r ? r = this.authority : null === r && (r = h), void 0 === n ? n = this.path : null === n && (n = h), void 0 === i ? i = this.query : null === i && (i = h), void 0 === o ? o = this.fragment : null === o && (o = h), e === this.scheme && r === this.authority && n === this.path && i === this.query && o === this.fragment ? this : new l(e, r, n, i, o);\n      }\n      static parse(t, e = !1) {\n        const r = c.exec(t);\n        return r ? new l(r[2] || h, C(r[4] || h), C(r[5] || h), C(r[7] || h), C(r[9] || h), e) : new l(h, h, h, h, h);\n      }\n      static file(e) {\n        let r = h;\n        if (t && (e = e.replace(/\\\\/g, a)), e[0] === a && e[1] === a) {\n          const t = e.indexOf(a, 2);\n          -1 === t ? (r = e.substring(2), e = a) : (r = e.substring(2, t), e = e.substring(t) || a);\n        }\n        return new l(\"file\", r, e, h, h);\n      }\n      static from(t) {\n        const e = new l(t.scheme, t.authority, t.path, t.query, t.fragment);\n        return s(e, !0), e;\n      }\n      toString(t = !1) {\n        return y(this, t);\n      }\n      toJSON() {\n        return this;\n      }\n      static revive(t) {\n        if (t) {\n          if (t instanceof f) return t;\n          {\n            const e = new l(t);\n            return e._formatted = t.external, e._fsPath = t._sep === u ? t.fsPath : null, e;\n          }\n        }\n        return t;\n      }\n    }\n    const u = t ? 1 : void 0;\n    class l extends f {\n      constructor(...args) {\n        super(...args);\n        _defineProperty(this, \"_formatted\", null);\n        _defineProperty(this, \"_fsPath\", null);\n      }\n      get fsPath() {\n        return this._fsPath || (this._fsPath = m(this, !1)), this._fsPath;\n      }\n      toString(t = !1) {\n        return t ? y(this, !0) : (this._formatted || (this._formatted = y(this, !1)), this._formatted);\n      }\n      toJSON() {\n        const t = {\n          $mid: 1\n        };\n        return this._fsPath && (t.fsPath = this._fsPath, t._sep = u), this._formatted && (t.external = this._formatted), this.path && (t.path = this.path), this.scheme && (t.scheme = this.scheme), this.authority && (t.authority = this.authority), this.query && (t.query = this.query), this.fragment && (t.fragment = this.fragment), t;\n      }\n    }\n    const g = {\n      58: \"%3A\",\n      47: \"%2F\",\n      63: \"%3F\",\n      35: \"%23\",\n      91: \"%5B\",\n      93: \"%5D\",\n      64: \"%40\",\n      33: \"%21\",\n      36: \"%24\",\n      38: \"%26\",\n      39: \"%27\",\n      40: \"%28\",\n      41: \"%29\",\n      42: \"%2A\",\n      43: \"%2B\",\n      44: \"%2C\",\n      59: \"%3B\",\n      61: \"%3D\",\n      32: \"%20\"\n    };\n    function d(t, e, r) {\n      let n,\n        i = -1;\n      for (let o = 0; o < t.length; o++) {\n        const s = t.charCodeAt(o);\n        if (s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57 || 45 === s || 46 === s || 95 === s || 126 === s || e && 47 === s || r && 91 === s || r && 93 === s || r && 58 === s) -1 !== i && (n += encodeURIComponent(t.substring(i, o)), i = -1), void 0 !== n && (n += t.charAt(o));else {\n          void 0 === n && (n = t.substr(0, o));\n          const e = g[s];\n          void 0 !== e ? (-1 !== i && (n += encodeURIComponent(t.substring(i, o)), i = -1), n += e) : -1 === i && (i = o);\n        }\n      }\n      return -1 !== i && (n += encodeURIComponent(t.substring(i))), void 0 !== n ? n : t;\n    }\n    function p(t) {\n      let e;\n      for (let r = 0; r < t.length; r++) {\n        const n = t.charCodeAt(r);\n        35 === n || 63 === n ? (void 0 === e && (e = t.substr(0, r)), e += g[n]) : void 0 !== e && (e += t[r]);\n      }\n      return void 0 !== e ? e : t;\n    }\n    function m(e, r) {\n      let n;\n      return n = e.authority && e.path.length > 1 && \"file\" === e.scheme ? `//${e.authority}${e.path}` : 47 === e.path.charCodeAt(0) && (e.path.charCodeAt(1) >= 65 && e.path.charCodeAt(1) <= 90 || e.path.charCodeAt(1) >= 97 && e.path.charCodeAt(1) <= 122) && 58 === e.path.charCodeAt(2) ? r ? e.path.substr(1) : e.path[1].toLowerCase() + e.path.substr(2) : e.path, t && (n = n.replace(/\\//g, \"\\\\\")), n;\n    }\n    function y(t, e) {\n      const r = e ? p : d;\n      let n = \"\",\n        {\n          scheme: i,\n          authority: o,\n          path: s,\n          query: h,\n          fragment: c\n        } = t;\n      if (i && (n += i, n += \":\"), (o || \"file\" === i) && (n += a, n += a), o) {\n        let t = o.indexOf(\"@\");\n        if (-1 !== t) {\n          const e = o.substr(0, t);\n          o = o.substr(t + 1), t = e.lastIndexOf(\":\"), -1 === t ? n += r(e, !1, !1) : (n += r(e.substr(0, t), !1, !1), n += \":\", n += r(e.substr(t + 1), !1, !0)), n += \"@\";\n        }\n        o = o.toLowerCase(), t = o.lastIndexOf(\":\"), -1 === t ? n += r(o, !1, !0) : (n += r(o.substr(0, t), !1, !0), n += o.substr(t));\n      }\n      if (s) {\n        if (s.length >= 3 && 47 === s.charCodeAt(0) && 58 === s.charCodeAt(2)) {\n          const t = s.charCodeAt(1);\n          t >= 65 && t <= 90 && (s = `/${String.fromCharCode(t + 32)}:${s.substr(3)}`);\n        } else if (s.length >= 2 && 58 === s.charCodeAt(1)) {\n          const t = s.charCodeAt(0);\n          t >= 65 && t <= 90 && (s = `${String.fromCharCode(t + 32)}:${s.substr(2)}`);\n        }\n        n += r(s, !0, !1);\n      }\n      return h && (n += \"?\", n += r(h, !1, !1)), c && (n += \"#\", n += e ? c : d(c, !1, !1)), n;\n    }\n    function v(t) {\n      try {\n        return decodeURIComponent(t);\n      } catch {\n        return t.length > 3 ? t.substr(0, 3) + v(t.substr(3)) : t;\n      }\n    }\n    const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n    function C(t) {\n      return t.match(b) ? t.replace(b, t => v(t)) : t;\n    }\n    var A = r(470);\n    const w = A.posix || A,\n      x = \"/\";\n    var P;\n    !function (t) {\n      t.joinPath = function (t, ...e) {\n        return t.with({\n          path: w.join(t.path, ...e)\n        });\n      }, t.resolvePath = function (t, ...e) {\n        let r = t.path,\n          n = !1;\n        r[0] !== x && (r = x + r, n = !0);\n        let i = w.resolve(r, ...e);\n        return n && i[0] === x && !t.authority && (i = i.substring(1)), t.with({\n          path: i\n        });\n      }, t.dirname = function (t) {\n        if (0 === t.path.length || t.path === x) return t;\n        let e = w.dirname(t.path);\n        return 1 === e.length && 46 === e.charCodeAt(0) && (e = \"\"), t.with({\n          path: e\n        });\n      }, t.basename = function (t) {\n        return w.basename(t.path);\n      }, t.extname = function (t) {\n        return w.extname(t.path);\n      };\n    }(P || (P = {}));\n  })(), LIB = n;\n})();\nexport const {\n  URI,\n  Utils\n} = LIB;","map":{"version":3,"names":["e","t","TypeError","JSON","stringify","r","n","i","o","s","h","length","charCodeAt","a","lastIndexOf","slice","resolve","arguments","process","cwd","normalize","isAbsolute","join","relative","c","f","u","l","g","_makeLong","dirname","basename","extname","format","dir","root","base","name","ext","parse","sep","delimiter","win32","posix","exports","d","Object","defineProperty","enumerable","get","prototype","hasOwnProperty","call","Symbol","toStringTag","value","platform","navigator","userAgent","indexOf","scheme","Error","authority","path","query","fragment","test","isUri","fsPath","with","toString","constructor","_defineProperty","m","exec","C","file","replace","substring","from","y","toJSON","revive","_formatted","external","_fsPath","_sep","args","$mid","encodeURIComponent","charAt","substr","p","toLowerCase","String","fromCharCode","v","decodeURIComponent","b","match","w","A","x","P","joinPath","resolvePath"],"sources":["webpack://LIB/node_modules/path-browserify/index.js","webpack://LIB/webpack/bootstrap","webpack://LIB/webpack/runtime/define property getters","webpack://LIB/webpack/runtime/hasOwnProperty shorthand","webpack://LIB/webpack/runtime/make namespace object","webpack://LIB/src/platform.ts","webpack://LIB/src/uri.ts","webpack://LIB/src/utils.ts"],"sourcesContent":["// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\n// !!!!!\n// SEE https://github.com/microsoft/vscode/blob/master/src/vs/base/common/platform.ts\n// !!!!!\n\ndeclare const process: { platform: 'win32' };\ndeclare const navigator: { userAgent: string };\n\nexport let isWindows: boolean;\n\nif (typeof process === 'object') {\n\tisWindows = process.platform === 'win32';\n} else if (typeof navigator === 'object') {\n\tlet userAgent = navigator.userAgent;\n\tisWindows = userAgent.indexOf('Windows') >= 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { CharCode } from './charCode'\nimport { isWindows } from './platform';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme && _strict) {\n\t\tthrow new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (!scheme && !_strict) {\n\t\treturn 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: any): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'string'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn uriToFsPath(this, false);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\twith(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new Uri(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tstatic parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new Uri(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new Uri(\n\t\t\tmatch[2] || _empty,\n\t\t\tpercentDecode(match[4] || _empty),\n\t\t\tpercentDecode(match[5] || _empty),\n\t\t\tpercentDecode(match[7] || _empty),\n\t\t\tpercentDecode(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tstatic file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new Uri('file', authority, path, _empty, _empty);\n\t}\n\n\tstatic from(components: { scheme: string; authority?: string; path?: string; query?: string; fragment?: string }): URI {\n\t\tconst result = new Uri(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t);\n\t\t_validateUri(result, true);\n\t\treturn result;\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\ttoString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\ttoJSON(): UriComponents {\n\t\treturn this;\n\t}\n\n\tstatic revive(data: UriComponents | URI): URI;\n\tstatic revive(data: UriComponents | URI | undefined): URI | undefined;\n\tstatic revive(data: UriComponents | URI | null): URI | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null {\n\t\tif (!data) {\n\t\t\treturn <any>data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new Uri(data);\n\t\t\tresult._formatted = (<UriState>data).external;\n\t\t\tresult._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath : null;\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority: string;\n\tpath: string;\n\tquery: string;\n\tfragment: string;\n}\n\ninterface UriState extends UriComponents {\n\t$mid: number;\n\texternal: string;\n\tfsPath: string;\n\t_sep: 1 | undefined;\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined;\n\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\toverride get fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = uriToFsPath(this, false);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\toverride toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\toverride toJSON(): UriComponents {\n\t\tconst res = <UriState>{\n\t\t\t$mid: 1\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t\tres._sep = _pathSepMarker;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t// uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, isPath: boolean, isAuthority: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (isPath && code === CharCode.Slash)\n\t\t\t|| (isAuthority && code === CharCode.OpenSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.CloseSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.Colon)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tif (!keepDriveLetterCasing) {\n\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t\t} else {\n\t\t\tvalue = uri.path.substr(1);\n\t\t}\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.lastIndexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false, false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false, true);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.lastIndexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false, true);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false, true);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true, false);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\n\t}\n\treturn res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch {\n\t\tif (str.length > 3) {\n\t\t\treturn str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n\tif (!str.match(_rEncodedAsHex)) {\n\t\treturn str;\n\t}\n\treturn str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\n/**\n * Mapped-type that replaces all occurrences of URI with UriComponents\n */\nexport type UriDto<T> = { [K in keyof T]: T[K] extends URI\n\t? UriComponents\n\t: UriDto<T[K]> };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport { CharCode } from './charCode';\nimport { URI } from './uri';\nimport * as nodePath from 'path';\n\nconst posixPath = nodePath.posix || nodePath;\nconst slash = '/';\n\nexport namespace Utils {\n\n    /**\n     * Joins one or more input paths to the path of URI. \n     * '/' is used as the directory separation character. \n     * \n     * The resolved path will be normalized. That means:\n     *  - all '..' and '.' segments are resolved.\n     *  - multiple, sequential occurences of '/' are replaced by a single instance of '/'.\n     *  - trailing separators are preserved.\n     * \n     * @param uri The input URI.\n     * @param paths The paths to be joined with the path of URI.\n     * @returns A URI with the joined path. All other properties of the URI (scheme, authority, query, fragments, ...) will be taken from the input URI.\n     */\n    export function joinPath(uri: URI, ...paths: string[]): URI {\n        return uri.with({ path: posixPath.join(uri.path, ...paths) });\n    }\n\n\n    /**\n     * Resolves one or more paths against the path of a URI. \n     * '/' is used as the directory separation character. \n     * \n     * The resolved path will be normalized. That means:\n     *  - all '..' and '.' segments are resolved. \n     *  - multiple, sequential occurences of '/' are replaced by a single instance of '/'.\n     *  - trailing separators are removed.\n     * \n     * @param uri The input URI.\n     * @param paths The paths to resolve against the path of URI.\n     * @returns A URI with the resolved path. All other properties of the URI (scheme, authority, query, fragments, ...) will be taken from the input URI.\n     */\n    export function resolvePath(uri: URI, ...paths: string[]): URI {\n        let path = uri.path; \n        let slashAdded = false;\n        if (path[0] !== slash) {\n            path = slash + path; // make the path abstract: for posixPath.resolve the first segments has to be absolute or cwd is used.\n            slashAdded = true;\n        }\n        let resolvedPath = posixPath.resolve(path, ...paths);\n        if (slashAdded && resolvedPath[0] === slash && !uri.authority) {\n            resolvedPath = resolvedPath.substring(1);\n        }\n        return uri.with({ path: resolvedPath });\n    }\n\n    /**\n     * Returns a URI where the path is the directory name of the input uri, similar to the Unix dirname command. \n     * In the path, '/' is recognized as the directory separation character. Trailing directory separators are ignored.\n     * The orignal URI is returned if the URIs path is empty or does not contain any path segments.\n     * \n     * @param uri The input URI.\n     * @return The last segment of the URIs path.\n     */\n    export function dirname(uri: URI): URI {\n        if (uri.path.length === 0 || uri.path === slash) {\n            return uri;\n        }\n        let path = posixPath.dirname(uri.path);\n        if (path.length === 1 && path.charCodeAt(0) === CharCode.Period) {\n            path = '';\n        }\n        return uri.with({ path });\n    }\n\n    /**\n     * Returns the last segment of the path of a URI, similar to the Unix basename command. \n     * In the path, '/' is recognized as the directory separation character. Trailing directory separators are ignored.\n     * The empty string is returned if the URIs path is empty or does not contain any path segments.\n     * \n     * @param uri The input URI.\n     * @return The base name of the URIs path.\n     */\n    export function basename(uri: URI): string {\n        return posixPath.basename(uri.path);\n    }\n\n    /**\n     * Returns the extension name of the path of a URI, similar to the Unix extname command. \n     * In the path, '/' is recognized as the directory separation character. Trailing directory separators are ignored.\n     * The empty string is returned if the URIs path is empty or does not contain any path segments.\n     * \n     * @param uri The input URI.\n     * @return The extension name of the URIs path.\n     */\n    export function extname(uri: URI): string {\n        return posixPath.extname(uri.path);\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}