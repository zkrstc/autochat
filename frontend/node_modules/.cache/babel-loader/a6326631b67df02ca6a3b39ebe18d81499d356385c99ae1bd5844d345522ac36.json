{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { createSequenceEmojiRegexItem, createSetEmojiRegexItem, createOptionalEmojiRegexItem, cloneEmojiRegexItem } from './base.mjs';\nimport { optimiseNumbersSet } from './numbers.mjs';\nimport '../convert.mjs';\nimport '../data.mjs';\nfunction findSimilarRegexItemSequences(items) {\n  const startRegex = /* @__PURE__ */Object.create(null);\n  const endRegex = /* @__PURE__ */Object.create(null);\n  const addMapItem = (target, index, regex, slice) => {\n    if (!target[regex]) {\n      target[regex] = {\n        // Start with 0. One item will remain after replacement\n        score: 0,\n        slices: [{\n          index,\n          slice\n        }]\n      };\n      return;\n    }\n    const item = target[regex];\n    item.score += regex.length;\n    item.slices.push({\n      index,\n      slice\n    });\n  };\n  for (let index = 0; index < items.length; index++) {\n    const baseItem = items[index];\n    switch (baseItem.type) {\n      case \"optional\":\n      case \"utf16\":\n        {\n          addMapItem(startRegex, index, baseItem.regex, \"full\");\n          addMapItem(endRegex, index, baseItem.regex, \"full\");\n          break;\n        }\n      case \"sequence\":\n        {\n          addMapItem(startRegex, index, baseItem.regex, \"full\");\n          addMapItem(endRegex, index, baseItem.regex, \"full\");\n          const sequence = baseItem.items;\n          for (let i = 1; i < sequence.length; i++) {\n            const startSequence = createSequenceEmojiRegexItem(sequence.slice(0, i));\n            addMapItem(startRegex, index, startSequence.regex, i);\n            const endSequence = createSequenceEmojiRegexItem(sequence.slice(i));\n            addMapItem(endRegex, index, endSequence.regex, i);\n          }\n          break;\n        }\n      case \"set\":\n        throw new Error(\"Unexpected set within a set\");\n    }\n  }\n  let result;\n  const checkResults = (target, type) => {\n    for (const regex in target) {\n      const item = target[regex];\n      if (!item.score) {\n        continue;\n      }\n      if (!result || result.score < item.score) {\n        result = {\n          score: item.score,\n          sequences: [{\n            type,\n            slices: item.slices\n          }]\n        };\n        continue;\n      }\n      if (result.score === item.score) {\n        result.sequences.push({\n          type,\n          slices: item.slices\n        });\n      }\n    }\n  };\n  checkResults(startRegex, \"start\");\n  checkResults(endRegex, \"end\");\n  return result;\n}\nfunction mergeSimilarRegexItemSequences(items, merge, optimise) {\n  const {\n    type,\n    slices\n  } = merge;\n  const indexes = /* @__PURE__ */new Set();\n  let hasFullSequence = false;\n  let longestMatch = 0;\n  let longestMatchIndex = -1;\n  const differentSequences = [];\n  for (let i = 0; i < slices.length; i++) {\n    const {\n      index,\n      slice\n    } = slices[i];\n    const item = items[index];\n    let length;\n    if (slice === \"full\") {\n      hasFullSequence = true;\n      if (item.type === \"sequence\") {\n        length = item.items.length;\n      } else {\n        length = 1;\n      }\n    } else {\n      if (item.type !== \"sequence\") {\n        throw new Error(`Unexpected partial match for type \"${item.type}\"`);\n      }\n      length = type === \"start\" ? slice : item.items.length - slice;\n      differentSequences.push(type === \"start\" ? item.items.slice(slice) : item.items.slice(0, slice));\n    }\n    if (length > longestMatch) {\n      longestMatchIndex = index;\n      longestMatch = length;\n    }\n    indexes.add(index);\n  }\n  if (longestMatch < 1 || longestMatchIndex < 0) {\n    throw new Error(\"Cannot find common sequence\");\n  }\n  const commonItem = items[longestMatchIndex];\n  let sequence;\n  if (commonItem.type !== \"sequence\") {\n    if (longestMatch !== 1) {\n      throw new Error(\"Something went wrong. Cannot have long match in non-sequence\");\n    }\n    sequence = [commonItem];\n  } else {\n    sequence = type === \"start\" ? commonItem.items.slice(0, longestMatch) : commonItem.items.slice(commonItem.items.length - longestMatch);\n  }\n  const setItems = [];\n  for (let i = 0; i < differentSequences.length; i++) {\n    const list = differentSequences[i];\n    if (list.length === 1) {\n      setItems.push(list[0]);\n    } else {\n      setItems.push(createSequenceEmojiRegexItem(list));\n    }\n  }\n  const set = createSetEmojiRegexItem(setItems);\n  let mergedChunk = set.sets.length === 1 ?\n  // Do not run callback if only 1 item\n  set.sets[0] : optimise ?\n  // Run callback to optimise it\n  optimise(set) :\n  // Use set as is\n  set;\n  if (hasFullSequence) {\n    mergedChunk = createOptionalEmojiRegexItem(mergedChunk);\n  }\n  sequence[type === \"start\" ? \"push\" : \"unshift\"](mergedChunk);\n  const results = [createSequenceEmojiRegexItem(sequence), ...items.filter((item, index) => !indexes.has(index))];\n  return results;\n}\nfunction mergeSimilarItemsInSet(set) {\n  const updatedSet = optimiseNumbersSet(set);\n  if (updatedSet.type !== \"set\") {\n    return updatedSet;\n  }\n  set = updatedSet;\n  let merges;\n  while (merges = findSimilarRegexItemSequences(set.sets)) {\n    const sequences = merges.sequences;\n    if (sequences.length === 1) {\n      const merged = mergeSimilarRegexItemSequences(set.sets.map(item => cloneEmojiRegexItem(item, true)), sequences[0], mergeSimilarItemsInSet);\n      if (merged.length === 1) {\n        return merged[0];\n      }\n      set = createSetEmojiRegexItem(merged);\n      continue;\n    }\n    let newItem;\n    for (let i = 0; i < sequences.length; i++) {\n      const merged = mergeSimilarRegexItemSequences(set.sets.map(item => cloneEmojiRegexItem(item, true)), sequences[i], mergeSimilarItemsInSet);\n      const mergedItem = merged.length === 1 ? merged[0] : createSetEmojiRegexItem(merged);\n      if (!newItem || mergedItem.regex.length < newItem.regex.length) {\n        newItem = mergedItem;\n      }\n    }\n    if (!newItem) {\n      throw new Error(\"Empty sequences list\");\n    }\n    if (newItem.type !== \"set\") {\n      return newItem;\n    }\n    set = newItem;\n  }\n  return set;\n}\nexport { findSimilarRegexItemSequences, mergeSimilarItemsInSet, mergeSimilarRegexItemSequences };","map":{"version":3,"names":["createSequenceEmojiRegexItem","createSetEmojiRegexItem","createOptionalEmojiRegexItem","cloneEmojiRegexItem","optimiseNumbersSet","findSimilarRegexItemSequences","items","startRegex","Object","create","endRegex","addMapItem","target","index","regex","slice","score","slices","item","length","push","baseItem","type","sequence","i","startSequence","endSequence","Error","result","checkResults","sequences","mergeSimilarRegexItemSequences","merge","optimise","indexes","Set","hasFullSequence","longestMatch","longestMatchIndex","differentSequences","add","commonItem","setItems","list","set","mergedChunk","sets","results","filter","has","mergeSimilarItemsInSet","updatedSet","merges","merged","map","newItem","mergedItem"],"sources":["C:/Users/ASUS/Desktop/autochat/frontend/node_modules/@iconify/utils/lib/emoji/regex/similar.mjs"],"sourcesContent":["import { createSequenceEmojiRegexItem, createSetEmojiRegexItem, createOptionalEmojiRegexItem, cloneEmojiRegexItem } from './base.mjs';\nimport { optimiseNumbersSet } from './numbers.mjs';\nimport '../convert.mjs';\nimport '../data.mjs';\n\nfunction findSimilarRegexItemSequences(items) {\n  const startRegex = /* @__PURE__ */ Object.create(null);\n  const endRegex = /* @__PURE__ */ Object.create(null);\n  const addMapItem = (target, index, regex, slice) => {\n    if (!target[regex]) {\n      target[regex] = {\n        // Start with 0. One item will remain after replacement\n        score: 0,\n        slices: [\n          {\n            index,\n            slice\n          }\n        ]\n      };\n      return;\n    }\n    const item = target[regex];\n    item.score += regex.length;\n    item.slices.push({\n      index,\n      slice\n    });\n  };\n  for (let index = 0; index < items.length; index++) {\n    const baseItem = items[index];\n    switch (baseItem.type) {\n      case \"optional\":\n      case \"utf16\": {\n        addMapItem(startRegex, index, baseItem.regex, \"full\");\n        addMapItem(endRegex, index, baseItem.regex, \"full\");\n        break;\n      }\n      case \"sequence\": {\n        addMapItem(startRegex, index, baseItem.regex, \"full\");\n        addMapItem(endRegex, index, baseItem.regex, \"full\");\n        const sequence = baseItem.items;\n        for (let i = 1; i < sequence.length; i++) {\n          const startSequence = createSequenceEmojiRegexItem(\n            sequence.slice(0, i)\n          );\n          addMapItem(startRegex, index, startSequence.regex, i);\n          const endSequence = createSequenceEmojiRegexItem(\n            sequence.slice(i)\n          );\n          addMapItem(endRegex, index, endSequence.regex, i);\n        }\n        break;\n      }\n      case \"set\":\n        throw new Error(\"Unexpected set within a set\");\n    }\n  }\n  let result;\n  const checkResults = (target, type) => {\n    for (const regex in target) {\n      const item = target[regex];\n      if (!item.score) {\n        continue;\n      }\n      if (!result || result.score < item.score) {\n        result = {\n          score: item.score,\n          sequences: [\n            {\n              type,\n              slices: item.slices\n            }\n          ]\n        };\n        continue;\n      }\n      if (result.score === item.score) {\n        result.sequences.push({\n          type,\n          slices: item.slices\n        });\n      }\n    }\n  };\n  checkResults(startRegex, \"start\");\n  checkResults(endRegex, \"end\");\n  return result;\n}\nfunction mergeSimilarRegexItemSequences(items, merge, optimise) {\n  const { type, slices } = merge;\n  const indexes = /* @__PURE__ */ new Set();\n  let hasFullSequence = false;\n  let longestMatch = 0;\n  let longestMatchIndex = -1;\n  const differentSequences = [];\n  for (let i = 0; i < slices.length; i++) {\n    const { index, slice } = slices[i];\n    const item = items[index];\n    let length;\n    if (slice === \"full\") {\n      hasFullSequence = true;\n      if (item.type === \"sequence\") {\n        length = item.items.length;\n      } else {\n        length = 1;\n      }\n    } else {\n      if (item.type !== \"sequence\") {\n        throw new Error(\n          `Unexpected partial match for type \"${item.type}\"`\n        );\n      }\n      length = type === \"start\" ? slice : item.items.length - slice;\n      differentSequences.push(\n        type === \"start\" ? item.items.slice(slice) : item.items.slice(0, slice)\n      );\n    }\n    if (length > longestMatch) {\n      longestMatchIndex = index;\n      longestMatch = length;\n    }\n    indexes.add(index);\n  }\n  if (longestMatch < 1 || longestMatchIndex < 0) {\n    throw new Error(\"Cannot find common sequence\");\n  }\n  const commonItem = items[longestMatchIndex];\n  let sequence;\n  if (commonItem.type !== \"sequence\") {\n    if (longestMatch !== 1) {\n      throw new Error(\n        \"Something went wrong. Cannot have long match in non-sequence\"\n      );\n    }\n    sequence = [commonItem];\n  } else {\n    sequence = type === \"start\" ? commonItem.items.slice(0, longestMatch) : commonItem.items.slice(\n      commonItem.items.length - longestMatch\n    );\n  }\n  const setItems = [];\n  for (let i = 0; i < differentSequences.length; i++) {\n    const list = differentSequences[i];\n    if (list.length === 1) {\n      setItems.push(list[0]);\n    } else {\n      setItems.push(createSequenceEmojiRegexItem(list));\n    }\n  }\n  const set = createSetEmojiRegexItem(setItems);\n  let mergedChunk = set.sets.length === 1 ? (\n    // Do not run callback if only 1 item\n    set.sets[0]\n  ) : optimise ? (\n    // Run callback to optimise it\n    optimise(set)\n  ) : (\n    // Use set as is\n    set\n  );\n  if (hasFullSequence) {\n    mergedChunk = createOptionalEmojiRegexItem(mergedChunk);\n  }\n  sequence[type === \"start\" ? \"push\" : \"unshift\"](mergedChunk);\n  const results = [\n    createSequenceEmojiRegexItem(sequence),\n    ...items.filter((item, index) => !indexes.has(index))\n  ];\n  return results;\n}\nfunction mergeSimilarItemsInSet(set) {\n  const updatedSet = optimiseNumbersSet(set);\n  if (updatedSet.type !== \"set\") {\n    return updatedSet;\n  }\n  set = updatedSet;\n  let merges;\n  while (merges = findSimilarRegexItemSequences(set.sets)) {\n    const sequences = merges.sequences;\n    if (sequences.length === 1) {\n      const merged = mergeSimilarRegexItemSequences(\n        set.sets.map((item) => cloneEmojiRegexItem(item, true)),\n        sequences[0],\n        mergeSimilarItemsInSet\n      );\n      if (merged.length === 1) {\n        return merged[0];\n      }\n      set = createSetEmojiRegexItem(merged);\n      continue;\n    }\n    let newItem;\n    for (let i = 0; i < sequences.length; i++) {\n      const merged = mergeSimilarRegexItemSequences(\n        set.sets.map((item) => cloneEmojiRegexItem(item, true)),\n        sequences[i],\n        mergeSimilarItemsInSet\n      );\n      const mergedItem = merged.length === 1 ? merged[0] : createSetEmojiRegexItem(merged);\n      if (!newItem || mergedItem.regex.length < newItem.regex.length) {\n        newItem = mergedItem;\n      }\n    }\n    if (!newItem) {\n      throw new Error(\"Empty sequences list\");\n    }\n    if (newItem.type !== \"set\") {\n      return newItem;\n    }\n    set = newItem;\n  }\n  return set;\n}\n\nexport { findSimilarRegexItemSequences, mergeSimilarItemsInSet, mergeSimilarRegexItemSequences };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}